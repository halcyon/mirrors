<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    
<!-- Mirrored from learnxinyminutes.com/docs/haskell/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 02 Sep 2016 16:33:58 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn Haskell in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="../../css/normalize.css">
        <link rel="stylesheet" href="../../css/main.css">
        <link href="../../css/screen.css" media="screen" rel="stylesheet" type="text/css" />
        <link href="../../css/github.css" media="screen" rel="stylesheet" type="text/css" />

        <link rel="canonical" href="index.html">
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fhaskell%2F&amp;text=Learn+X+in+Y+minutes%2C+where+X%3DHaskell">
        Share this page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <h1><a href="../../index.html">Learn X in Y minutes</a></h2>
  <h2>Where X=Haskell</h2>
  
  <div id="doc">
    <p>Haskell was designed as a practical, purely functional programming
language. It&rsquo;s famous for its monads and its type system, but I keep coming back
to it because of its elegance. Haskell makes coding a real joy for me.</p>
<pre class="highlight haskell"><code><span class="c1">-- Single line comments start with two dashes.</span>
<span class="cm">{- Multiline comments can be enclosed
in a block like this.
-}</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 1. Primitive Datatypes and Operators</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- You have numbers</span>
<span class="mi">3</span> <span class="c1">-- 3</span>

<span class="c1">-- Math is what you would expect</span>
<span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">-- 2</span>
<span class="mi">8</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">-- 7</span>
<span class="mi">10</span> <span class="o">*</span> <span class="mi">2</span> <span class="c1">-- 20</span>
<span class="mi">35</span> <span class="o">/</span> <span class="mi">5</span> <span class="c1">-- 7.0</span>

<span class="c1">-- Division is not integer division by default</span>
<span class="mi">35</span> <span class="o">/</span> <span class="mi">4</span> <span class="c1">-- 8.75</span>

<span class="c1">-- integer division</span>
<span class="mi">35</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="mi">4</span> <span class="c1">-- 8</span>

<span class="c1">-- Boolean values are primitives</span>
<span class="kt">True</span>
<span class="kt">False</span>

<span class="c1">-- Boolean operations</span>
<span class="n">not</span> <span class="kt">True</span> <span class="c1">-- False</span>
<span class="n">not</span> <span class="kt">False</span> <span class="c1">-- True</span>
<span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span> <span class="c1">-- True</span>
<span class="mi">1</span> <span class="o">/=</span> <span class="mi">1</span> <span class="c1">-- False</span>
<span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="c1">-- True</span>

<span class="c1">-- In the above examples, `not` is a function that takes one value.</span>
<span class="c1">-- Haskell doesn't need parentheses for function calls...all the arguments</span>
<span class="c1">-- are just listed after the function. So the general pattern is:</span>
<span class="c1">-- func arg1 arg2 arg3...</span>
<span class="c1">-- See the section on functions for information on how to write your own.</span>

<span class="c1">-- Strings and characters</span>
<span class="s">"This is a string."</span>
<span class="sc">'a'</span> <span class="c1">-- character</span>
<span class="sc">'Y</span><span class="err">o</span><span class="n">u</span> <span class="n">cant</span> <span class="n">use</span> <span class="n">single</span> <span class="n">quotes</span> <span class="n">for</span> <span class="n">strings</span><span class="o">.</span><span class="sc">' </span><span class="err">-</span><span class="o">-</span> <span class="ne">error</span><span class="o">!</span>

<span class="c1">-- Strings can be concatenated</span>
<span class="s">"Hello "</span> <span class="o">++</span> <span class="s">"world!"</span> <span class="c1">-- "Hello world!"</span>

<span class="c1">-- A string is a list of characters</span>
<span class="p">[</span><span class="sc">'H'</span><span class="p">,</span> <span class="sc">'e'</span><span class="p">,</span> <span class="sc">'l'</span><span class="p">,</span> <span class="sc">'l'</span><span class="p">,</span> <span class="sc">'o'</span><span class="p">]</span> <span class="c1">-- "Hello"</span>
<span class="s">"This is a string"</span> <span class="o">!!</span> <span class="mi">0</span> <span class="c1">-- 'T'</span>


<span class="c1">----------------------------------------------------</span>
<span class="c1">-- Lists and Tuples</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Every element in a list must have the same type.</span>
<span class="c1">-- These two lists are the same:</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>

<span class="c1">-- Ranges are versatile.</span>
<span class="p">[</span><span class="sc">'A'</span><span class="o">..</span><span class="sc">'F'</span><span class="p">]</span> <span class="c1">-- "ABCDEF"</span>

<span class="c1">-- You can create a step in a range.</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span> <span class="c1">-- [0, 2, 4, 6, 8, 10]</span>
<span class="p">[</span><span class="mi">5</span><span class="o">..</span><span class="mi">1</span><span class="p">]</span> <span class="c1">-- This doesn't work because Haskell defaults to incrementing.</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="o">..</span><span class="mi">1</span><span class="p">]</span> <span class="c1">-- [5, 4, 3, 2, 1]</span>

<span class="c1">-- indexing into a list</span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span> <span class="o">!!</span> <span class="mi">3</span> <span class="c1">-- 4</span>

<span class="c1">-- You can also have infinite lists in Haskell!</span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span> <span class="c1">-- a list of all the natural numbers</span>

<span class="c1">-- Infinite lists work because Haskell has "lazy evaluation". This means</span>
<span class="c1">-- that Haskell only evaluates things when it needs to. So you can ask for</span>
<span class="c1">-- the 1000th element of your list and Haskell will give it to you:</span>

<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span> <span class="o">!!</span> <span class="mi">999</span> <span class="c1">-- 1000</span>

<span class="c1">-- And now Haskell has evaluated elements 1 - 1000 of this list...but the</span>
<span class="c1">-- rest of the elements of this "infinite" list don't exist yet! Haskell won't</span>
<span class="c1">-- actually evaluate them until it needs to.</span>

<span class="c1">-- joining two lists</span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="o">++</span> <span class="p">[</span><span class="mi">6</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>

<span class="c1">-- adding to the head of a list</span>
<span class="mi">0</span><span class="o">:</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="c1">-- [0, 1, 2, 3, 4, 5]</span>

<span class="c1">-- more list operations</span>
<span class="n">head</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="c1">-- 1</span>
<span class="n">tail</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="c1">-- [2, 3, 4, 5]</span>
<span class="n">init</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="c1">-- [1, 2, 3, 4]</span>
<span class="n">last</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="c1">-- 5</span>

<span class="c1">-- list comprehensions</span>
<span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]]</span> <span class="c1">-- [2, 4, 6, 8, 10]</span>

<span class="c1">-- with a conditional</span>
<span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">],</span> <span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">]</span> <span class="c1">-- [6, 8, 10]</span>

<span class="c1">-- Every element in a tuple can be a different type, but a tuple has a</span>
<span class="c1">-- fixed length.</span>
<span class="c1">-- A tuple:</span>
<span class="p">(</span><span class="s">"haskell"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1">-- accessing elements of a pair (i.e. a tuple of length 2)</span>
<span class="n">fst</span> <span class="p">(</span><span class="s">"haskell"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">-- "haskell"</span>
<span class="n">snd</span> <span class="p">(</span><span class="s">"haskell"</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">-- 1</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 3. Functions</span>
<span class="c1">----------------------------------------------------</span>
<span class="c1">-- A simple function that takes two variables</span>
<span class="n">add</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="c1">-- Note that if you are using ghci (the Haskell interpreter)</span>
<span class="c1">-- You'll need to use `let`, i.e.</span>
<span class="c1">-- let add a b = a + b</span>

<span class="c1">-- Using the function</span>
<span class="n">add</span> <span class="mi">1</span> <span class="mi">2</span> <span class="c1">-- 3</span>

<span class="c1">-- You can also put the function name between the two arguments</span>
<span class="c1">-- with backticks:</span>
<span class="mi">1</span> <span class="p">`</span><span class="n">add</span><span class="p">`</span> <span class="mi">2</span> <span class="c1">-- 3</span>

<span class="c1">-- You can also define functions that have no letters! This lets</span>
<span class="c1">-- you define your own operators! Here's an operator that does</span>
<span class="c1">-- integer division</span>
<span class="p">(</span><span class="o">//</span><span class="p">)</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="n">b</span>
<span class="mi">35</span> <span class="o">//</span> <span class="mi">4</span> <span class="c1">-- 8</span>

<span class="c1">-- Guards: an easy way to do branching in functions</span>
<span class="n">fib</span> <span class="n">x</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="n">fib</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1">-- Pattern matching is similar. Here we have given three different</span>
<span class="c1">-- definitions for fib. Haskell will automatically call the first</span>
<span class="c1">-- function that matches the pattern of the value.</span>
<span class="n">fib</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">fib</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">fib</span> <span class="n">x</span> <span class="o">=</span> <span class="n">fib</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1">-- Pattern matching on tuples:</span>
<span class="n">foo</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1">-- Pattern matching on lists. Here `x` is the first element</span>
<span class="c1">-- in the list, and `xs` is the rest of the list. We can write</span>
<span class="c1">-- our own map function:</span>
<span class="n">myMap</span> <span class="n">func</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">myMap</span> <span class="n">func</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">func</span> <span class="n">x</span><span class="o">:</span><span class="p">(</span><span class="n">myMap</span> <span class="n">func</span> <span class="n">xs</span><span class="p">)</span>

<span class="c1">-- Anonymous functions are created with a backslash followed by</span>
<span class="c1">-- all the arguments.</span>
<span class="n">myMap</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="c1">-- [3, 4, 5, 6, 7]</span>

<span class="c1">-- using fold (called `inject` in some languages) with an anonymous</span>
<span class="c1">-- function. foldl1 means fold left, and use the first value in the</span>
<span class="c1">-- list as the initial value for the accumulator.</span>
<span class="n">foldl1</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="c1">-- 15</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 4. More functions</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- partial application: if you don't pass in all the arguments to a function,</span>
<span class="c1">-- it gets "partially applied". That means it returns a function that takes the</span>
<span class="c1">-- rest of the arguments.</span>

<span class="n">add</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="n">foo</span> <span class="o">=</span> <span class="n">add</span> <span class="mi">10</span> <span class="c1">-- foo is now a function that takes a number and adds 10 to it</span>
<span class="n">foo</span> <span class="mi">5</span> <span class="c1">-- 15</span>

<span class="c1">-- Another way to write the same thing</span>
<span class="n">foo</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="o">+</span><span class="p">)</span>
<span class="n">foo</span> <span class="mi">5</span> <span class="c1">-- 15</span>

<span class="c1">-- function composition</span>
<span class="c1">-- the operator `.` chains functions together.</span>
<span class="c1">-- For example, here foo is a function that takes a value. It adds 10 to it,</span>
<span class="c1">-- multiplies the result of that by 4, and then returns the final value.</span>
<span class="n">foo</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="p">)</span> <span class="o">.</span> <span class="p">(</span><span class="mi">10</span><span class="o">+</span><span class="p">)</span>

<span class="c1">-- 4*(10 + 5) = 60</span>
<span class="n">foo</span> <span class="mi">5</span> <span class="c1">-- 60</span>

<span class="c1">-- fixing precedence</span>
<span class="c1">-- Haskell has another operator called `$`. This operator applies a function </span>
<span class="c1">-- to a given parameter. In contrast to standard function application, which </span>
<span class="c1">-- has highest possible priority of 10 and is left-associative, the `$` operator </span>
<span class="c1">-- has priority of 0 and is right-associative. Such a low priority means that</span>
<span class="c1">-- the expression on its right is applied as the parameter to the function on its left.</span>

<span class="c1">-- before</span>
<span class="n">even</span> <span class="p">(</span><span class="n">fib</span> <span class="mi">7</span><span class="p">)</span> <span class="c1">-- false</span>

<span class="c1">-- equivalently</span>
<span class="n">even</span> <span class="o">$</span> <span class="n">fib</span> <span class="mi">7</span> <span class="c1">-- false</span>

<span class="c1">-- composing functions</span>
<span class="n">even</span> <span class="o">.</span> <span class="n">fib</span> <span class="o">$</span> <span class="mi">7</span> <span class="c1">-- false</span>


<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 5. Type signatures</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Haskell has a very strong type system, and every valid expression has a type. </span>

<span class="c1">-- Some basic types:</span>
<span class="mi">5</span> <span class="o">::</span> <span class="kt">Integer</span>
<span class="s">"hello"</span> <span class="o">::</span> <span class="kt">String</span>
<span class="kt">True</span> <span class="o">::</span> <span class="kt">Bool</span>

<span class="c1">-- Functions have types too.</span>
<span class="c1">-- `not` takes a boolean and returns a boolean:</span>
<span class="c1">-- not :: Bool -&gt; Bool</span>

<span class="c1">-- Here's a function that takes two arguments:</span>
<span class="c1">-- add :: Integer -&gt; Integer -&gt; Integer</span>

<span class="c1">-- When you define a value, it's good practice to write its type above it:</span>
<span class="n">double</span> <span class="o">::</span> <span class="kt">Integer</span> <span class="o">-&gt;</span> <span class="kt">Integer</span>
<span class="n">double</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 6. Control Flow and If Expressions</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- if expressions</span>
<span class="n">haskell</span> <span class="o">=</span> <span class="kr">if</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span> <span class="kr">then</span> <span class="s">"awesome"</span> <span class="kr">else</span> <span class="s">"awful"</span> <span class="c1">-- haskell = "awesome"</span>

<span class="c1">-- if expressions can be on multiple lines too, indentation is important</span>
<span class="n">haskell</span> <span class="o">=</span> <span class="kr">if</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="kr">then</span> <span class="s">"awesome"</span>
            <span class="kr">else</span> <span class="s">"awful"</span>

<span class="c1">-- case expressions: Here's how you could parse command line arguments</span>
<span class="kr">case</span> <span class="n">args</span> <span class="kr">of</span>
  <span class="s">"help"</span> <span class="o">-&gt;</span> <span class="n">printHelp</span>
  <span class="s">"start"</span> <span class="o">-&gt;</span> <span class="n">startProgram</span>
  <span class="kr">_</span> <span class="o">-&gt;</span> <span class="n">putStrLn</span> <span class="s">"bad args"</span>

<span class="c1">-- Haskell doesn't have loops; it uses recursion instead.</span>
<span class="c1">-- map applies a function over every element in a list</span>

<span class="n">map</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="c1">-- [2, 4, 6, 8, 10]</span>

<span class="c1">-- you can make a for function using map</span>
<span class="n">for</span> <span class="n">array</span> <span class="n">func</span> <span class="o">=</span> <span class="n">map</span> <span class="n">func</span> <span class="n">array</span>

<span class="c1">-- and then use it</span>
<span class="n">for</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="o">$</span> <span class="nf">\</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">show</span> <span class="n">i</span>

<span class="c1">-- we could've written that like this too:</span>
<span class="n">for</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span> <span class="n">show</span>

<span class="c1">-- You can use foldl or foldr to reduce a list</span>
<span class="c1">-- foldl &lt;fn&gt; &lt;initial value&gt; &lt;list&gt;</span>
<span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="mi">4</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="c1">-- 43</span>

<span class="c1">-- This is the same as</span>
<span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span>

<span class="c1">-- foldl is left-handed, foldr is right-handed</span>
<span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="mi">4</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="c1">-- 16</span>

<span class="c1">-- This is now the same as</span>
<span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)))</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 7. Data Types</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Here's how you make your own data type in Haskell</span>

<span class="kr">data</span> <span class="kt">Color</span> <span class="o">=</span> <span class="kt">Red</span> <span class="o">|</span> <span class="kt">Blue</span> <span class="o">|</span> <span class="kt">Green</span>

<span class="c1">-- Now you can use it in a function:</span>


<span class="n">say</span> <span class="o">::</span> <span class="kt">Color</span> <span class="o">-&gt;</span> <span class="kt">String</span>
<span class="n">say</span> <span class="kt">Red</span> <span class="o">=</span> <span class="s">"You are Red!"</span>
<span class="n">say</span> <span class="kt">Blue</span> <span class="o">=</span> <span class="s">"You are Blue!"</span>
<span class="n">say</span> <span class="kt">Green</span> <span class="o">=</span>  <span class="s">"You are Green!"</span>

<span class="c1">-- Your data types can have parameters too:</span>

<span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Nothing</span> <span class="o">|</span> <span class="kt">Just</span> <span class="n">a</span>

<span class="c1">-- These are all of type Maybe</span>
<span class="kt">Just</span> <span class="s">"hello"</span>    <span class="c1">-- of type `Maybe String`</span>
<span class="kt">Just</span> <span class="mi">1</span>          <span class="c1">-- of type `Maybe Int`</span>
<span class="kt">Nothing</span>         <span class="c1">-- of type `Maybe a` for any `a`</span>

<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 8. Haskell IO</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- While IO can't be explained fully without explaining monads,</span>
<span class="c1">-- it is not hard to explain enough to get going.</span>

<span class="c1">-- When a Haskell program is executed, `main` is</span>
<span class="c1">-- called. It must return a value of type `IO a` for some type `a`. For example:</span>

<span class="n">main</span> <span class="o">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="n">main</span> <span class="o">=</span> <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">"Hello, sky! "</span> <span class="o">++</span> <span class="p">(</span><span class="n">say</span> <span class="kt">Blue</span><span class="p">)</span>
<span class="c1">-- putStrLn has type String -&gt; IO ()</span>

<span class="c1">-- It is easiest to do IO if you can implement your program as</span>
<span class="c1">-- a function from String to String. The function</span>
<span class="c1">--    interact :: (String -&gt; String) -&gt; IO ()</span>
<span class="c1">-- inputs some text, runs a function on it, and prints out the</span>
<span class="c1">-- output.</span>

<span class="n">countLines</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">String</span>
<span class="n">countLines</span> <span class="o">=</span> <span class="n">show</span> <span class="o">.</span> <span class="n">length</span> <span class="o">.</span> <span class="n">lines</span>

<span class="n">main'</span> <span class="o">=</span> <span class="n">interact</span> <span class="n">countLines</span>

<span class="c1">-- You can think of a value of type `IO ()` as representing a</span>
<span class="c1">-- sequence of actions for the computer to do, much like a</span>
<span class="c1">-- computer program written in an imperative language. We can use</span>
<span class="c1">-- the `do` notation to chain actions together. For example:</span>

<span class="n">sayHello</span> <span class="o">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="n">sayHello</span> <span class="o">=</span> <span class="kr">do</span>
   <span class="n">putStrLn</span> <span class="s">"What is your name?"</span>
   <span class="n">name</span> <span class="o">&lt;-</span> <span class="n">getLine</span> <span class="c1">-- this gets a line and gives it the name "name"</span>
   <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">"Hello, "</span> <span class="o">++</span> <span class="n">name</span>

<span class="c1">-- Exercise: write your own version of `interact` that only reads</span>
<span class="c1">--           one line of input.</span>

<span class="c1">-- The code in `sayHello` will never be executed, however. The only</span>
<span class="c1">-- action that ever gets executed is the value of `main`.</span>
<span class="c1">-- To run `sayHello` comment out the above definition of `main`</span>
<span class="c1">-- and replace it with:</span>
<span class="c1">--   main = sayHello</span>

<span class="c1">-- Let's understand better how the function `getLine` we just</span>
<span class="c1">-- used works. Its type is:</span>
<span class="c1">--    getLine :: IO String</span>
<span class="c1">-- You can think of a value of type `IO a` as representing a</span>
<span class="c1">-- computer program that will generate a value of type `a`</span>
<span class="c1">-- when executed (in addition to anything else it does). We can</span>
<span class="c1">-- name and reuse this value using `&lt;-`. We can also</span>
<span class="c1">-- make our own action of type `IO String`:</span>

<span class="n">action</span> <span class="o">::</span> <span class="kt">IO</span> <span class="kt">String</span>
<span class="n">action</span> <span class="o">=</span> <span class="kr">do</span>
   <span class="n">putStrLn</span> <span class="s">"This is a line. Duh"</span>
   <span class="n">input1</span> <span class="o">&lt;-</span> <span class="n">getLine</span>
   <span class="n">input2</span> <span class="o">&lt;-</span> <span class="n">getLine</span>
   <span class="c1">-- The type of the `do` statement is that of its last line.</span>
   <span class="c1">-- `return` is not a keyword, but merely a function</span>
   <span class="n">return</span> <span class="p">(</span><span class="n">input1</span> <span class="o">++</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span> <span class="o">++</span> <span class="n">input2</span><span class="p">)</span> <span class="c1">-- return :: String -&gt; IO String</span>

<span class="c1">-- We can use this just like we used `getLine`:</span>

<span class="n">main''</span> <span class="o">=</span> <span class="kr">do</span>
    <span class="n">putStrLn</span> <span class="s">"I will echo two lines!"</span>
    <span class="n">result</span> <span class="o">&lt;-</span> <span class="n">action</span>
    <span class="n">putStrLn</span> <span class="n">result</span>
    <span class="n">putStrLn</span> <span class="s">"This was all, folks!"</span>

<span class="c1">-- The type `IO` is an example of a "monad". The way Haskell uses a monad to</span>
<span class="c1">-- do IO allows it to be a purely functional language. Any function that</span>
<span class="c1">-- interacts with the outside world (i.e. does IO) gets marked as `IO` in its</span>
<span class="c1">-- type signature. This lets us reason about what functions are "pure" (don't</span>
<span class="c1">-- interact with the outside world or modify state) and what functions aren't.</span>

<span class="c1">-- This is a powerful feature, because it's easy to run pure functions</span>
<span class="c1">-- concurrently; so, concurrency in Haskell is very easy.</span>


<span class="c1">----------------------------------------------------</span>
<span class="c1">-- 9. The Haskell REPL</span>
<span class="c1">----------------------------------------------------</span>

<span class="c1">-- Start the repl by typing `ghci`.</span>
<span class="c1">-- Now you can type in Haskell code. Any new values</span>
<span class="c1">-- need to be created with `let`:</span>

<span class="kr">let</span> <span class="n">foo</span> <span class="o">=</span> <span class="mi">5</span>

<span class="c1">-- You can see the type of any value or expression with `:t`:</span>

<span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="n">foo</span>
<span class="n">foo</span> <span class="o">::</span> <span class="kt">Integer</span>

<span class="c1">-- Operators, such as `+`, `:` and `$`, are functions.</span>
<span class="c1">-- Their type can be inspected by putting the operator in parentheses:</span>

<span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="p">(</span><span class="o">:</span><span class="p">)</span>
<span class="p">(</span><span class="o">:</span><span class="p">)</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>

<span class="c1">-- You can get additional information on any `name` using `:i`:</span>

<span class="o">&gt;</span> <span class="o">:</span><span class="n">i</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span>
<span class="kr">class</span> <span class="kt">Num</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
  <span class="o">...</span>
    <span class="c1">-- Defined in ‘GHC.Num’</span>
<span class="kr">infixl</span> <span class="mi">6</span> <span class="o">+</span>

<span class="c1">-- You can also run any action of type `IO ()`</span>

<span class="o">&gt;</span> <span class="n">sayHello</span>
<span class="kt">What</span> <span class="n">is</span> <span class="n">your</span> <span class="n">name</span><span class="o">?</span>
<span class="kt">Friend</span><span class="o">!</span>
<span class="kt">Hello</span><span class="p">,</span> <span class="kt">Friend</span><span class="o">!</span>

</code></pre>

<p>There&rsquo;s a lot more to Haskell, including typeclasses and monads. These are the
big ideas that make Haskell such fun to code in. I&rsquo;ll leave you with one final
Haskell example: an implementation of a quicksort variant in Haskell:</p>
<pre class="highlight haskell"><code><span class="n">qsort</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">qsort</span> <span class="p">(</span><span class="n">p</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">qsort</span> <span class="n">lesser</span> <span class="o">++</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">++</span> <span class="n">qsort</span> <span class="n">greater</span>
    <span class="kr">where</span> <span class="n">lesser</span>  <span class="o">=</span> <span class="n">filter</span> <span class="p">(</span><span class="o">&lt;</span> <span class="n">p</span><span class="p">)</span> <span class="n">xs</span>
          <span class="n">greater</span> <span class="o">=</span> <span class="n">filter</span> <span class="p">(</span><span class="o">&gt;=</span> <span class="n">p</span><span class="p">)</span> <span class="n">xs</span>
</code></pre>

<p>There are two popular ways to install Haskell: The traditional <a href="http://www.haskell.org/platform/">Cabal-based installation</a>, and the newer <a href="https://www.stackage.org/install">Stack-based process</a>.</p>

<p>You can find a much gentler introduction from the excellent
<a href="http://learnyouahaskell.com/">Learn you a Haskell</a> or
<a href="http://book.realworldhaskell.org/">Real World Haskell</a>.</p>

    <hr>
    <p>Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the Github Repo, or make a pull request yourself!
    </p>
    <p class="contributed">
    Originally contributed by Adit Bhargava, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/haskell.html.markdown">25 contributor(s)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2016
    
      
        <a href="http://adit.io/">Adit Bhargava</a>
      
    
    </p>

    <p>
    

    </footer>
  </div>

        </div>

        <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="../../js/script.js"></script>

        <script>
            var _gaq=[['_setAccount','UA-3525624-21'],['_trackPageview']];
            (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)}(document,'script'));
        </script>
    </body>

<!-- Mirrored from learnxinyminutes.com/docs/haskell/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 02 Sep 2016 16:33:58 GMT -->
</html>
