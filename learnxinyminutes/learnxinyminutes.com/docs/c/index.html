<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    
<!-- Mirrored from learnxinyminutes.com/docs/c/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 02 Sep 2016 16:31:19 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn c in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="../../css/normalize.css">
        <link rel="stylesheet" href="../../css/main.css">
        <link href="../../css/screen.css" media="screen" rel="stylesheet" type="text/css" />
        <link href="../../css/github.css" media="screen" rel="stylesheet" type="text/css" />

        <link rel="canonical" href="index.html">
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fc%2F&amp;text=Learn+X+in+Y+minutes%2C+where+X%3Dc">
        Share this page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <h1><a href="../../index.html">Learn X in Y minutes</a></h2>
  <h2>Where X=c</h2>
  
    <p class="filelink">
    Get the code:
    <a href="../files/learnc.c">learnc.c</a>
    </p>
  
  <div id="doc">
    <p>Ah, C. Still <strong>the</strong> language of modern high-performance computing.</p>

<p>C is the lowest-level language most programmers will ever use, but
it more than makes up for it with raw speed. Just be aware of its manual
memory management and C will take you as far as you need to go.</p>
<pre class="highlight c"><code><span class="c1">// Single-line comments start with // - only available in C99 and later.
</span>
<span class="cm">/*
Multi-line comments look like this. They work in C89 as well.
*/</span>

<span class="cm">/*
Multi-line comments don't nest /* Be careful */</span>  <span class="c1">// comment ends on this line...
</span><span class="err">*/</span> <span class="c1">// ...not this one!
</span>
<span class="c1">// Constants: #define &lt;keyword&gt;
// Constants are written in all-caps out of convention, not requirement
</span><span class="cp">#define DAYS_IN_YEAR 365
</span>
<span class="c1">// Enumeration constants are also ways to declare constants.
// All statements must end with a semicolon
</span><span class="k">enum</span> <span class="n">days</span> <span class="p">{</span><span class="n">SUN</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MON</span><span class="p">,</span> <span class="n">TUE</span><span class="p">,</span> <span class="n">WED</span><span class="p">,</span> <span class="n">THU</span><span class="p">,</span> <span class="n">FRI</span><span class="p">,</span> <span class="n">SAT</span><span class="p">};</span>
<span class="c1">// MON gets 2 automatically, TUE gets 3, etc.
</span>
<span class="c1">// Import headers with #include
</span><span class="cp">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
</span>
<span class="c1">// (File names between &lt;angle brackets&gt; are headers from the C standard library.)
// For your own headers, use double quotes instead of angle brackets:
//#include "my_header.h"
</span>
<span class="c1">// Declare function signatures in advance in a .h file, or at the top of
// your .c file.
</span><span class="kt">void</span> <span class="n">function_1</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">function_2</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="c1">// Must declare a 'function prototype' before main() when functions occur after
// your main() function.
</span><span class="kt">int</span> <span class="n">add_two_ints</span><span class="p">(</span><span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x2</span><span class="p">);</span> <span class="c1">// function prototype
// although `int add_two_ints(int, int);` is also valid (no need to name the args),
// it is recommended to name arguments in the prototype as well for easier inspection
</span>
<span class="c1">// Your program's entry point is a function called
// main with an integer return type.
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// your program
</span><span class="p">}</span>

<span class="c1">// The command line arguments used to run your program are also passed to main
// argc being the number of arguments - your program's name counts as 1
// argv is an array of character arrays - containing the arguments themselves
// argv[0] = name of your program, argv[1] = first argument, etc.
</span><span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// print output using printf, for "print formatted"
</span>  <span class="c1">// %d is an integer, \n is a newline
</span>  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// =&gt; Prints 0
</span>
  <span class="c1">///////////////////////////////////////
</span>  <span class="c1">// Types
</span>  <span class="c1">///////////////////////////////////////
</span>
  <span class="c1">// All variables MUST be declared at the top of the current block scope
</span>  <span class="c1">// we declare them dynamically along the code for the sake of the tutorial
</span>
  <span class="c1">// ints are usually 4 bytes
</span>  <span class="kt">int</span> <span class="n">x_int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// shorts are usually 2 bytes
</span>  <span class="kt">short</span> <span class="n">x_short</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// chars are guaranteed to be 1 byte
</span>  <span class="kt">char</span> <span class="n">x_char</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">y_char</span> <span class="o">=</span> <span class="sc">'y'</span><span class="p">;</span> <span class="c1">// Char literals are quoted with ''
</span>
  <span class="c1">// longs are often 4 to 8 bytes; long longs are guaranteed to be at least
</span>  <span class="c1">// 64 bits
</span>  <span class="kt">long</span> <span class="n">x_long</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">long</span> <span class="kt">long</span> <span class="n">x_long_long</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// floats are usually 32-bit floating point numbers
</span>  <span class="kt">float</span> <span class="n">x_float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span> <span class="c1">// 'f' suffix here denotes floating point literal
</span>
  <span class="c1">// doubles are usually 64-bit floating-point numbers
</span>  <span class="kt">double</span> <span class="n">x_double</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span> <span class="c1">// real numbers without any suffix are doubles
</span>
  <span class="c1">// integer types may be unsigned (greater than or equal to zero)
</span>  <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">ux_short</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ux_int</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ux_long_long</span><span class="p">;</span>

  <span class="c1">// chars inside single quotes are integers in machine's character set.
</span>  <span class="sc">'0'</span><span class="p">;</span> <span class="c1">// =&gt; 48 in the ASCII character set.
</span>  <span class="sc">'A'</span><span class="p">;</span> <span class="c1">// =&gt; 65 in the ASCII character set.
</span>
  <span class="c1">// sizeof(T) gives you the size of a variable with type T in bytes
</span>  <span class="c1">// sizeof(obj) yields the size of the expression (variable, literal, etc.).
</span>  <span class="n">printf</span><span class="p">(</span><span class="s">"%zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span> <span class="c1">// =&gt; 4 (on most machines with 4-byte words)
</span>
  <span class="c1">// If the argument of the `sizeof` operator is an expression, then its argument
</span>  <span class="c1">// is not evaluated (except VLAs (see below)).
</span>  <span class="c1">// The value it yields in this case is a compile-time constant.
</span>  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="c1">// size_t is an unsigned integer type of at least 2 bytes used to represent
</span>  <span class="c1">// the size of an object.
</span>  <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="o">++</span><span class="p">);</span> <span class="c1">// a++ is not evaluated
</span>  <span class="n">printf</span><span class="p">(</span><span class="s">"sizeof(a++) = %zu where a = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
  <span class="c1">// prints "sizeof(a++) = 4 where a = 1" (on a 32-bit architecture)
</span>
  <span class="c1">// Arrays must be initialized with a concrete size.
</span>  <span class="kt">char</span> <span class="n">my_char_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span> <span class="c1">// This array occupies 1 * 20 = 20 bytes
</span>  <span class="kt">int</span> <span class="n">my_int_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span> <span class="c1">// This array occupies 4 * 20 = 80 bytes
</span>  <span class="c1">// (assuming 4-byte words)
</span>
  <span class="c1">// You can initialize an array to 0 thusly:
</span>  <span class="kt">char</span> <span class="n">my_array</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

  <span class="c1">// Indexing an array is like other languages -- or,
</span>  <span class="c1">// rather, other languages are like C
</span>  <span class="n">my_array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// =&gt; 0
</span>
  <span class="c1">// Arrays are mutable; it's just memory!
</span>  <span class="n">my_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">my_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// =&gt; 2
</span>
  <span class="c1">// In C99 (and as an optional feature in C11), variable-length arrays (VLAs)
</span>  <span class="c1">// can be declared as well. The size of such an array need not be a compile
</span>  <span class="c1">// time constant:
</span>  <span class="n">printf</span><span class="p">(</span><span class="s">"Enter the array size: "</span><span class="p">);</span> <span class="c1">// ask the user for an array size
</span>  <span class="kt">int</span> <span class="n">array_size</span><span class="p">;</span>
  <span class="n">fscanf</span><span class="p">(</span><span class="n">stdin</span><span class="p">,</span> <span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">array_size</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">var_length_array</span><span class="p">[</span><span class="n">array_size</span><span class="p">];</span> <span class="c1">// declare the VLA
</span>  <span class="n">printf</span><span class="p">(</span><span class="s">"sizeof array = %zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">var_length_array</span><span class="p">);</span>

  <span class="c1">// Example:
</span>  <span class="c1">// &gt; Enter the array size: 10
</span>  <span class="c1">// &gt; sizeof array = 40
</span>
  <span class="c1">// Strings are just arrays of chars terminated by a NULL (0x00) byte,
</span>  <span class="c1">// represented in strings as the special character '\0'.
</span>  <span class="c1">// (We don't have to include the NULL byte in string literals; the compiler
</span>  <span class="c1">//  inserts it at the end of the array for us.)
</span>  <span class="kt">char</span> <span class="n">a_string</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="s">"This is a string"</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a_string</span><span class="p">);</span> <span class="c1">// %s formats a string
</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a_string</span><span class="p">[</span><span class="mi">16</span><span class="p">]);</span> <span class="c1">// =&gt; 0
</span>  <span class="c1">// i.e., byte #17 is 0 (as are 18, 19, and 20)
</span>
  <span class="c1">// If we have characters between single quotes, that's a character literal.
</span>  <span class="c1">// It's of type `int`, and *not* `char` (for historical reasons).
</span>  <span class="kt">int</span> <span class="n">cha</span> <span class="o">=</span> <span class="sc">'a'</span><span class="p">;</span> <span class="c1">// fine
</span>  <span class="kt">char</span> <span class="n">chb</span> <span class="o">=</span> <span class="sc">'a'</span><span class="p">;</span> <span class="c1">// fine too (implicit conversion from int to char)
</span>
  <span class="c1">// Multi-dimensional arrays:
</span>  <span class="kt">int</span> <span class="n">multi_array</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">},</span>
    <span class="p">{</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>
  <span class="p">};</span>
  <span class="c1">// access elements:
</span>  <span class="kt">int</span> <span class="n">array_int</span> <span class="o">=</span> <span class="n">multi_array</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// =&gt; 3
</span>
  <span class="c1">///////////////////////////////////////
</span>  <span class="c1">// Operators
</span>  <span class="c1">///////////////////////////////////////
</span>
  <span class="c1">// Shorthands for multiple declarations:
</span>  <span class="kt">int</span> <span class="n">i1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">f1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">f2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>
  <span class="n">b</span> <span class="o">=</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// Arithmetic is straightforward
</span>  <span class="n">i1</span> <span class="o">+</span> <span class="n">i2</span><span class="p">;</span> <span class="c1">// =&gt; 3
</span>  <span class="n">i2</span> <span class="o">-</span> <span class="n">i1</span><span class="p">;</span> <span class="c1">// =&gt; 1
</span>  <span class="n">i2</span> <span class="o">*</span> <span class="n">i1</span><span class="p">;</span> <span class="c1">// =&gt; 2
</span>  <span class="n">i1</span> <span class="o">/</span> <span class="n">i2</span><span class="p">;</span> <span class="c1">// =&gt; 0 (0.5, but truncated towards 0)
</span>
  <span class="c1">// You need to cast at least one integer to float to get a floating-point result
</span>  <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">i1</span> <span class="o">/</span> <span class="n">i2</span><span class="p">;</span> <span class="c1">// =&gt; 0.5f
</span>  <span class="n">i1</span> <span class="o">/</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">i2</span><span class="p">;</span> <span class="c1">// =&gt; 0.5 // Same with double
</span>  <span class="n">f1</span> <span class="o">/</span> <span class="n">f2</span><span class="p">;</span> <span class="c1">// =&gt; 0.5, plus or minus epsilon
</span>  <span class="c1">// Floating-point numbers and calculations are not exact
</span>
  <span class="c1">// Modulo is there as well
</span>  <span class="mi">11</span> <span class="o">%</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// =&gt; 2
</span>
  <span class="c1">// Comparison operators are probably familiar, but
</span>  <span class="c1">// there is no Boolean type in c. We use ints instead.
</span>  <span class="c1">// (Or _Bool or bool in C99.)
</span>  <span class="c1">// 0 is false, anything else is true. (The comparison
</span>  <span class="c1">// operators always yield 0 or 1.)
</span>  <span class="mi">3</span> <span class="o">==</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 0 (false)
</span>  <span class="mi">3</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 1 (true)
</span>  <span class="mi">3</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 1
</span>  <span class="mi">3</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 0
</span>  <span class="mi">2</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 1
</span>  <span class="mi">2</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 1
</span>
  <span class="c1">// C is not Python - comparisons don't chain.
</span>  <span class="c1">// Warning: The line below will compile, but it means `(0 &lt; a) &lt; 2`.
</span>  <span class="c1">// This expression is always true, because (0 &lt; a) could be either 1 or 0.
</span>  <span class="c1">// In this case it's 1, because (0 &lt; 1).
</span>  <span class="kt">int</span> <span class="n">between_0_and_2</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span>
  <span class="c1">// Instead use:
</span>  <span class="kt">int</span> <span class="n">between_0_and_2</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span>

  <span class="c1">// Logic works on ints
</span>  <span class="o">!</span><span class="mi">3</span><span class="p">;</span> <span class="c1">// =&gt; 0 (Logical not)
</span>  <span class="o">!</span><span class="mi">0</span><span class="p">;</span> <span class="c1">// =&gt; 1
</span>  <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 1 (Logical and)
</span>  <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 0
</span>  <span class="mi">0</span> <span class="o">||</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 1 (Logical or)
</span>  <span class="mi">0</span> <span class="o">||</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// =&gt; 0
</span>
  <span class="c1">// Conditional ternary expression ( ? : )
</span>  <span class="kt">int</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">z</span><span class="p">;</span>
  <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">e</span> <span class="o">&gt;</span> <span class="n">f</span><span class="p">)</span> <span class="o">?</span> <span class="n">e</span> <span class="o">:</span> <span class="n">f</span><span class="p">;</span> <span class="c1">// =&gt; 10 "if e &gt; f return e, else return f."
</span>
  <span class="c1">// Increment and decrement operators:
</span>  <span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="s">"ILoveC"</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span> <span class="c1">// =&gt; "I". Returns the j-th item of s THEN increments value of j.
</span>  <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">s</span><span class="p">[</span><span class="o">++</span><span class="n">j</span><span class="p">];</span> <span class="c1">// =&gt; "L". Increments value of j THEN returns j-th value of s.
</span>  <span class="c1">// same with j-- and --j
</span>
  <span class="c1">// Bitwise operators!
</span>  <span class="o">~</span><span class="mh">0x0F</span><span class="p">;</span> <span class="c1">// =&gt; 0xFFFFFFF0 (bitwise negation, "1's complement", example result for 32-bit int)
</span>  <span class="mh">0x0F</span> <span class="o">&amp;</span> <span class="mh">0xF0</span><span class="p">;</span> <span class="c1">// =&gt; 0x00 (bitwise AND)
</span>  <span class="mh">0x0F</span> <span class="o">|</span> <span class="mh">0xF0</span><span class="p">;</span> <span class="c1">// =&gt; 0xFF (bitwise OR)
</span>  <span class="mh">0x04</span> <span class="o">^</span> <span class="mh">0x0F</span><span class="p">;</span> <span class="c1">// =&gt; 0x0B (bitwise XOR)
</span>  <span class="mh">0x01</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 0x02 (bitwise left shift (by 1))
</span>  <span class="mh">0x02</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 0x01 (bitwise right shift (by 1))
</span>
  <span class="c1">// Be careful when shifting signed integers - the following are undefined:
</span>  <span class="c1">// - shifting into the sign bit of a signed integer (int a = 1 &lt;&lt; 31)
</span>  <span class="c1">// - left-shifting a negative number (int a = -1 &lt;&lt; 2)
</span>  <span class="c1">// - shifting by an offset which is &gt;= the width of the type of the LHS:
</span>  <span class="c1">//   int a = 1 &lt;&lt; 32; // UB if int is 32 bits wide
</span>
  <span class="c1">///////////////////////////////////////
</span>  <span class="c1">// Control Structures
</span>  <span class="c1">///////////////////////////////////////
</span>
  <span class="k">if</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"I am never run</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"I am also never run</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"I print</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// While loops exist
</span>  <span class="kt">int</span> <span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">ii</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//ANY value not zero is true.
</span>    <span class="n">printf</span><span class="p">(</span><span class="s">"%d, "</span><span class="p">,</span> <span class="n">ii</span><span class="o">++</span><span class="p">);</span> <span class="c1">// ii++ increments ii AFTER using its current value.
</span>  <span class="p">}</span> <span class="c1">// =&gt; prints "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "
</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

  <span class="kt">int</span> <span class="n">kk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">do</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d, "</span><span class="p">,</span> <span class="n">kk</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">kk</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">);</span> <span class="c1">// ++kk increments kk BEFORE using its current value.
</span>  <span class="c1">// =&gt; prints "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "
</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

  <span class="c1">// For loops too
</span>  <span class="kt">int</span> <span class="n">jj</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">jj</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">jj</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">jj</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d, "</span><span class="p">,</span> <span class="n">jj</span><span class="p">);</span>
  <span class="p">}</span> <span class="c1">// =&gt; prints "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "
</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

  <span class="c1">// *****NOTES*****:
</span>  <span class="c1">// Loops and Functions MUST have a body. If no body is needed:
</span>  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">;</span> <span class="c1">// use semicolon to act as the body (null statement)
</span>  <span class="p">}</span>
  <span class="c1">// Or
</span>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">);</span>

  <span class="c1">// branching with multiple choices: switch()
</span>  <span class="k">switch</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="mi">0</span><span class="p">:</span> <span class="c1">// labels need to be integral *constant* expressions
</span>    <span class="n">printf</span><span class="p">(</span><span class="s">"Hey, 'a' equals 0!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span> <span class="c1">// if you don't break, control flow falls over labels
</span>  <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Huh, 'a' equals 1!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
    <span class="c1">// Be careful - without a "break", execution continues until the
</span>    <span class="c1">// next "break" is reached.
</span>  <span class="k">case</span> <span class="mi">3</span><span class="p">:</span>
  <span class="k">case</span> <span class="mi">4</span><span class="p">:</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Look at that.. 'a' is either 3, or 4</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="nl">default:</span>
    <span class="c1">// if `some_integral_expression` didn't match any of the labels
</span>    <span class="n">fputs</span><span class="p">(</span><span class="s">"Error!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="cm">/*
  using "goto" in C
  */</span>
  <span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">true</span> <span class="p">}</span> <span class="n">bool</span><span class="p">;</span>
  <span class="c1">// for C don't have bool as data type :(
</span>  <span class="n">bool</span> <span class="n">disaster</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">150</span><span class="p">)</span>
        <span class="n">disaster</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">disaster</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">error</span> <span class="o">:</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Error occured at i = %d &amp; j = %d.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
  <span class="cm">/*
  https://ideone.com/GuPhd6
  this will print out "Error occured at i = 52 &amp; j = 99."
  */</span>

  <span class="c1">///////////////////////////////////////
</span>  <span class="c1">// Typecasting
</span>  <span class="c1">///////////////////////////////////////
</span>
  <span class="c1">// Every value in C has a type, but you can cast one value into another type
</span>  <span class="c1">// if you want (with some constraints).
</span>
  <span class="kt">int</span> <span class="n">x_hex</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span> <span class="c1">// You can assign vars with hex literals
</span>
  <span class="c1">// Casting between types will attempt to preserve their numeric values
</span>  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x_hex</span><span class="p">);</span> <span class="c1">// =&gt; Prints 1
</span>  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">short</span><span class="p">)</span> <span class="n">x_hex</span><span class="p">);</span> <span class="c1">// =&gt; Prints 1
</span>  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="n">x_hex</span><span class="p">);</span> <span class="c1">// =&gt; Prints 1
</span>
  <span class="c1">// Types will overflow without warning
</span>  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="mi">257</span><span class="p">);</span> <span class="c1">// =&gt; 1 (Max char = 255 if char is 8 bits long)
</span>
  <span class="c1">// For determining the max value of a `char`, a `signed char` and an `unsigned char`,
</span>  <span class="c1">// respectively, use the CHAR_MAX, SCHAR_MAX and UCHAR_MAX macros from &lt;limits.h&gt;
</span>
  <span class="c1">// Integral types can be cast to floating-point types, and vice-versa.
</span>  <span class="n">printf</span><span class="p">(</span><span class="s">"%f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="mi">100</span><span class="p">);</span> <span class="c1">// %f formats a float
</span>  <span class="n">printf</span><span class="p">(</span><span class="s">"%lf</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="mi">100</span><span class="p">);</span> <span class="c1">// %lf formats a double
</span>  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="mi">100</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>

  <span class="c1">///////////////////////////////////////
</span>  <span class="c1">// Pointers
</span>  <span class="c1">///////////////////////////////////////
</span>
  <span class="c1">// A pointer is a variable declared to store a memory address. Its declaration will
</span>  <span class="c1">// also tell you the type of data it points to. You can retrieve the memory address
</span>  <span class="c1">// of your variables, then mess with them.
</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span> <span class="c1">// Use &amp; to retrieve the address of a variable
</span>  <span class="c1">// (%p formats an object pointer of type void *)
</span>  <span class="c1">// =&gt; Prints some address in memory;
</span>
  <span class="c1">// Pointers start with * in their declaration
</span>  <span class="kt">int</span> <span class="o">*</span><span class="n">px</span><span class="p">,</span> <span class="n">not_a_pointer</span><span class="p">;</span> <span class="c1">// px is a pointer to an int
</span>  <span class="n">px</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span> <span class="c1">// Stores the address of x in px
</span>  <span class="n">printf</span><span class="p">(</span><span class="s">"%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">px</span><span class="p">);</span> <span class="c1">// =&gt; Prints some address in memory
</span>  <span class="n">printf</span><span class="p">(</span><span class="s">"%zu, %zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">px</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">not_a_pointer</span><span class="p">));</span>
  <span class="c1">// =&gt; Prints "8, 4" on a typical 64-bit system
</span>
  <span class="c1">// To retrieve the value at the address a pointer is pointing to,
</span>  <span class="c1">// put * in front to dereference it.
</span>  <span class="c1">// Note: yes, it may be confusing that '*' is used for _both_ declaring a
</span>  <span class="c1">// pointer and dereferencing it.
</span>  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">px</span><span class="p">);</span> <span class="c1">// =&gt; Prints 0, the value of x
</span>
  <span class="c1">// You can also change the value the pointer is pointing to.
</span>  <span class="c1">// We'll have to wrap the dereference in parenthesis because
</span>  <span class="c1">// ++ has a higher precedence than *.
</span>  <span class="p">(</span><span class="o">*</span><span class="n">px</span><span class="p">)</span><span class="o">++</span><span class="p">;</span> <span class="c1">// Increment the value px is pointing to by 1
</span>  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">px</span><span class="p">);</span> <span class="c1">// =&gt; Prints 1
</span>  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span> <span class="c1">// =&gt; Prints 1
</span>
  <span class="c1">// Arrays are a good way to allocate a contiguous block of memory
</span>  <span class="kt">int</span> <span class="n">x_array</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span> <span class="c1">//declares array of size 20 (cannot change size)
</span>  <span class="kt">int</span> <span class="n">xx</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">xx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">xx</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">xx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x_array</span><span class="p">[</span><span class="n">xx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">-</span> <span class="n">xx</span><span class="p">;</span>
  <span class="p">}</span> <span class="c1">// Initialize x_array to 20, 19, 18,... 2, 1
</span>
  <span class="c1">// Declare a pointer of type int and initialize it to point to x_array
</span>  <span class="kt">int</span><span class="o">*</span> <span class="n">x_ptr</span> <span class="o">=</span> <span class="n">x_array</span><span class="p">;</span>
  <span class="c1">// x_ptr now points to the first element in the array (the integer 20).
</span>  <span class="c1">// This works because arrays often decay into pointers to their first element.
</span>  <span class="c1">// For example, when an array is passed to a function or is assigned to a pointer,
</span>  <span class="c1">// it decays into (implicitly converted to) a pointer.
</span>  <span class="c1">// Exceptions: when the array is the argument of the `&amp;` (address-of) operator:
</span>  <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr_to_arr</span><span class="p">)[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">;</span> <span class="c1">// &amp;arr is NOT of type `int *`!
</span>  <span class="c1">// It's of type "pointer to array" (of ten `int`s).
</span>  <span class="c1">// or when the array is a string literal used for initializing a char array:
</span>  <span class="kt">char</span> <span class="n">otherarr</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"foobarbazquirk"</span><span class="p">;</span>
  <span class="c1">// or when it's the argument of the `sizeof` or `alignof` operator:
</span>  <span class="kt">int</span> <span class="n">arraythethird</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">arraythethird</span><span class="p">;</span> <span class="c1">// equivalent with int *ptr = &amp;arr[0];
</span>  <span class="n">printf</span><span class="p">(</span><span class="s">"%zu, %zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">arraythethird</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">ptr</span><span class="p">);</span>
  <span class="c1">// probably prints "40, 4" or "40, 8"
</span>
  <span class="c1">// Pointers are incremented and decremented based on their type
</span>  <span class="c1">// (this is called pointer arithmetic)
</span>  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">x_ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span> <span class="c1">// =&gt; Prints 19
</span>  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// =&gt; Prints 19
</span>
  <span class="c1">// You can also dynamically allocate contiguous blocks of memory with the
</span>  <span class="c1">// standard library function malloc, which takes one argument of type size_t
</span>  <span class="c1">// representing the number of bytes to allocate (usually from the heap, although this
</span>  <span class="c1">// may not be true on e.g. embedded systems - the C standard says nothing about it).
</span>  <span class="kt">int</span> <span class="o">*</span><span class="n">my_ptr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">my_ptr</span><span class="p">)</span> <span class="o">*</span> <span class="mi">20</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">xx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">xx</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">xx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="p">(</span><span class="n">my_ptr</span> <span class="o">+</span> <span class="n">xx</span><span class="p">)</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">-</span> <span class="n">xx</span><span class="p">;</span> <span class="c1">// my_ptr[xx] = 20-xx
</span>  <span class="p">}</span> <span class="c1">// Initialize memory to 20, 19, 18, 17... 2, 1 (as ints)
</span>
  <span class="c1">// Note that there is no standard way to get the length of a
</span>  <span class="c1">// dynamically allocated array in C. Because of this, if your arrays are
</span>  <span class="c1">// going to be passed around your program a lot, you need another variable
</span>  <span class="c1">// to keep track of the number of elements (size) of an array. See the
</span>  <span class="c1">// functions section for more info.
</span>  <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">my_arr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">size</span><span class="p">);</span>
  <span class="c1">// Add an element to the array
</span>  <span class="n">size</span><span class="o">++</span><span class="p">;</span>
  <span class="n">my_arr</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="n">my_arr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">size</span><span class="p">);</span>
  <span class="n">my_arr</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

  <span class="c1">// Dereferencing memory that you haven't allocated gives
</span>  <span class="c1">// "unpredictable results" - the program is said to invoke "undefined behavior"
</span>  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">my_ptr</span> <span class="o">+</span> <span class="mi">21</span><span class="p">));</span> <span class="c1">// =&gt; Prints who-knows-what? It may even crash.
</span>
  <span class="c1">// When you're done with a malloc'd block of memory, you need to free it,
</span>  <span class="c1">// or else no one else can use it until your program terminates
</span>  <span class="c1">// (this is called a "memory leak"):
</span>  <span class="n">free</span><span class="p">(</span><span class="n">my_ptr</span><span class="p">);</span>

  <span class="c1">// Strings are arrays of char, but they are usually represented as a
</span>  <span class="c1">// pointer-to-char (which is a pointer to the first element of the array).
</span>  <span class="c1">// It's good practice to use `const char *' when referring to a string literal,
</span>  <span class="c1">// since string literals shall not be modified (i.e. "foo"[0] = 'a' is ILLEGAL.)
</span>  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">my_str</span> <span class="o">=</span> <span class="s">"This is my very own string literal"</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%c</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">my_str</span><span class="p">);</span> <span class="c1">// =&gt; 'T'
</span>
  <span class="c1">// This is not the case if the string is an array
</span>  <span class="c1">// (potentially initialized with a string literal)
</span>  <span class="c1">// that resides in writable memory, as in:
</span>  <span class="kt">char</span> <span class="n">foo</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"foo"</span><span class="p">;</span>
  <span class="n">foo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'a'</span><span class="p">;</span> <span class="c1">// this is legal, foo now contains "aoo"
</span>
  <span class="n">function_1</span><span class="p">();</span>
<span class="p">}</span> <span class="c1">// end main function
</span>
<span class="c1">///////////////////////////////////////
// Functions
///////////////////////////////////////
</span>
<span class="c1">// Function declaration syntax:
// &lt;return type&gt; &lt;function name&gt;(&lt;args&gt;)
</span>
<span class="kt">int</span> <span class="nf">add_two_ints</span><span class="p">(</span><span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="p">;</span> <span class="c1">// Use return to return a value
</span><span class="p">}</span>

<span class="cm">/*
Functions are call by value. When a function is called, the arguments passed to
the function are copies of the original arguments (except arrays). Anything you
do to the arguments in the function do not change the value of the original
argument where the function was called.

Use pointers if you need to edit the original argument values.

Example: in-place string reversal
*/</span>

<span class="c1">// A void function returns no value
</span><span class="kt">void</span> <span class="nf">str_reverse</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str_in</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">tmp</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str_in</span><span class="p">);</span> <span class="c1">// `strlen()` is part of the c standard library
</span>  <span class="k">for</span> <span class="p">(</span><span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">ii</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">str_in</span><span class="p">[</span><span class="n">ii</span><span class="p">];</span>
    <span class="n">str_in</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">str_in</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span> <span class="c1">// ii-th char from end
</span>    <span class="n">str_in</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*
char c[] = "This is a test.";
str_reverse(c);
printf("%s\n", c); // =&gt; ".tset a si sihT"
*/</span>
<span class="cm">/*
as we can return only one variable
to change values of more than one variables we use call by reference
*/</span>
<span class="kt">void</span> <span class="nf">swapTwoNumbers</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
    <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
    <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
int first = 10;
int second = 20;
printf("first: %d\nsecond: %d\n", first, second);
swapTwoNumbers(&amp;first, &amp;second);
printf("first: %d\nsecond: %d\n", first, second);
// values will be swapped
*/</span>

<span class="cm">/*
With regards to arrays, they will always be passed to functions
as pointers. Even if you statically allocate an array like `arr[10]`,
it still gets passed as a pointer to the first element in any function calls.
Again, there is no standard way to get the size of a dynamically allocated
array in C.
*/</span>
<span class="c1">// Size must be passed!
// Otherwise, this function has no way of knowing how big the array is.
</span><span class="kt">void</span> <span class="nf">printIntArray</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">arr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"arr[%d] is: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*
int my_arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
int size = 10;
printIntArray(my_arr, size);
// will print "arr[0] is: 1" etc
*/</span>

<span class="c1">// if referring to external variables outside function, must use extern keyword.
</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">testFunc</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">extern</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span> <span class="c1">//i here is now using external variable i
</span><span class="p">}</span>

<span class="c1">// make external variables private to source file with static:
</span><span class="k">static</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//other files using testFunc2() cannot access variable j
</span><span class="kt">void</span> <span class="nf">testFunc2</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">extern</span> <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//**You may also declare functions as static to make them private**
</span>
<span class="c1">///////////////////////////////////////
// User-defined types and structs
///////////////////////////////////////
</span>
<span class="c1">// Typedefs can be used to create type aliases
</span><span class="k">typedef</span> <span class="kt">int</span> <span class="n">my_type</span><span class="p">;</span>
<span class="n">my_type</span> <span class="n">my_type_var</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// Structs are just collections of data, the members are allocated sequentially,
// in the order they are written:
</span><span class="k">struct</span> <span class="n">rectangle</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">width</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">height</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// It's not generally true that
// sizeof(struct rectangle) == sizeof(int) + sizeof(int)
// due to potential padding between the structure members (this is for alignment
// reasons). [1]
</span>
<span class="kt">void</span> <span class="nf">function_1</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">rectangle</span> <span class="n">my_rec</span><span class="p">;</span>

  <span class="c1">// Access struct members with .
</span>  <span class="n">my_rec</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="n">my_rec</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

  <span class="c1">// You can declare pointers to structs
</span>  <span class="k">struct</span> <span class="n">rectangle</span> <span class="o">*</span><span class="n">my_rec_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_rec</span><span class="p">;</span>

  <span class="c1">// Use dereferencing to set struct pointer members...
</span>  <span class="p">(</span><span class="o">*</span><span class="n">my_rec_ptr</span><span class="p">).</span><span class="n">width</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>

  <span class="c1">// ... or even better: prefer the -&gt; shorthand for the sake of readability
</span>  <span class="n">my_rec_ptr</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// Same as (*my_rec_ptr).height = 10;
</span><span class="p">}</span>

<span class="c1">// You can apply a typedef to a struct for convenience
</span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">rectangle</span> <span class="n">rect</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">area</span><span class="p">(</span><span class="n">rect</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">r</span><span class="p">.</span><span class="n">width</span> <span class="o">*</span> <span class="n">r</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// if you have large structs, you can pass them "by pointer" to avoid copying
// the whole struct:
</span><span class="kt">int</span> <span class="nf">areaptr</span><span class="p">(</span><span class="k">const</span> <span class="n">rect</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">*</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">///////////////////////////////////////
// Function pointers
///////////////////////////////////////
</span><span class="cm">/*
At run time, functions are located at known memory addresses. Function pointers are
much like any other pointer (they just store a memory address), but can be used
to invoke functions directly, and to pass handlers (or callback functions) around.
However, definition syntax may be initially confusing.

Example: use str_reverse from a pointer
*/</span>
<span class="kt">void</span> <span class="nf">str_reverse_through_pointer</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str_in</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Define a function pointer variable, named f.
</span>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="p">);</span> <span class="c1">// Signature should exactly match the target function.
</span>  <span class="n">f</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">str_reverse</span><span class="p">;</span> <span class="c1">// Assign the address for the actual function (determined at run time)
</span>  <span class="c1">// f = str_reverse; would work as well - functions decay into pointers, similar to arrays
</span>  <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="n">str_in</span><span class="p">);</span> <span class="c1">// Just calling the function through the pointer
</span>  <span class="c1">// f(str_in); // That's an alternative but equally valid syntax for calling it.
</span><span class="p">}</span>

<span class="cm">/*
As long as function signatures match, you can assign any function to the same pointer.
Function pointers are usually typedef'd for simplicity and readability, as follows:
*/</span>

<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">my_fnp_type</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="p">);</span>

<span class="c1">// Then used when declaring the actual pointer variable:
// ...
// my_fnp_type f;
</span>
<span class="c1">//Special characters:
</span><span class="cm">/*
'\a'; // alert (bell) character
'\n'; // newline character
'\t'; // tab character (left justifies text)
'\v'; // vertical tab
'\f'; // new page (form feed)
'\r'; // carriage return
'\b'; // backspace character
'\0'; // NULL character. Usually put at end of strings in C.
//   hello\n\0. \0 used by convention to mark end of string.
'\\'; // backslash
'\?'; // question mark
'\''; // single quote
'\"'; // double quote
'\xhh'; // hexadecimal number. Example: '\xb' = vertical tab character
'\0oo'; // octal number. Example: '\013' = vertical tab character

//print formatting:
"%d";    // integer
"%3d";   // integer with minimum of length 3 digits (right justifies text)
"%s";    // string
"%f";    // float
"%ld";   // long
"%3.2f"; // minimum 3 digits left and 2 digits right decimal float
"%7.4s"; // (can do with strings too)
"%c";    // char
"%p";    // pointer
"%x";    // hexadecimal
"%o";    // octal
"%%";    // prints %
*/</span>

<span class="c1">///////////////////////////////////////
// Order of Evaluation
///////////////////////////////////////
</span>
<span class="c1">//---------------------------------------------------//
//        Operators                  | Associativity //
//---------------------------------------------------//
// () [] -&gt; .                        | left to right //
// ! ~ ++ -- + = *(type)sizeof       | right to left //
// * / %                             | left to right //
// + -                               | left to right //
// &lt;&lt; &gt;&gt;                             | left to right //
// &lt; &lt;= &gt; &gt;=                         | left to right //
// == !=                             | left to right //
// &amp;                                 | left to right //
// ^                                 | left to right //
// |                                 | left to right //
// &amp;&amp;                                | left to right //
// ||                                | left to right //
// ?:                                | right to left //
// = += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;= | right to left //
// ,                                 | left to right //
//---------------------------------------------------//
</span>
<span class="cm">/******************************* Header Files **********************************

Header files are an important part of c as they allow for the connection of c
source files and can simplify code and definitions by separating them into
separate files.

Header files are syntactically similar to c source files but reside in ".h"
files. They can be included in your c source file by using the precompiler
command #include "example.h", given that example.h exists in the same directory
as the c file.
*/</span>

<span class="cm">/* A safe guard to prevent the header from being defined too many times. This */</span>
<span class="cm">/* happens in the case of circle dependency, the contents of the header is    */</span>
<span class="cm">/* already defined.                                                           */</span>
<span class="cp">#ifndef EXAMPLE_H </span><span class="cm">/* if EXAMPLE_H is not yet defined. */</span><span class="cp">
#define EXAMPLE_H </span><span class="cm">/* Define the macro EXAMPLE_H. */</span><span class="cp">
</span>
<span class="cm">/* Other headers can be included in headers and therefore transitively */</span>
<span class="cm">/* included into files that include this header.                       */</span>
<span class="cp">#include &lt;string.h&gt;
</span>
<span class="cm">/* Like c source files macros can be defined in headers and used in files */</span>
<span class="cm">/* that include this header file.                                         */</span>
<span class="cp">#define EXAMPLE_NAME "Dennis Ritchie"
</span><span class="cm">/* Function macros can also be defined. */</span>
<span class="cp">#define ADD(a, b) (a + b)
</span>
<span class="cm">/* Structs and typedefs can be used for consistency between files. */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">node</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Node</span><span class="p">;</span>

<span class="cm">/* So can enumerations. */</span>
<span class="k">enum</span> <span class="n">traffic_light_state</span> <span class="p">{</span><span class="n">GREEN</span><span class="p">,</span> <span class="n">YELLOW</span><span class="p">,</span> <span class="n">RED</span><span class="p">};</span>

<span class="cm">/* Function prototypes can also be defined here for use in multiple files,  */</span>
<span class="cm">/* but it is bad practice to define the function in the header. Definitions */</span>
<span class="cm">/* should instead be put in a c file.                                       */</span>
<span class="n">Node</span> <span class="n">createLinkedList</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">vals</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/* Beyond the above elements, other definitions should be left to a c source */</span>
<span class="cm">/* file. Excessive includes or definitions should, also not be contained in */</span>
<span class="cm">/* a header file but instead put into separate headers or a c file.          */</span>

<span class="cp">#endif </span><span class="cm">/* End of the if precompiler directive. */</span><span class="cp">
</span>
</code></pre>

<h2>Further Reading</h2>

<p>Best to find yourself a copy of <a href="https://en.wikipedia.org/wiki/The_C_Programming_Language">K&amp;R, aka &ldquo;The C Programming Language&rdquo;</a>
It is <em>the</em> book about C, written by Dennis Ritchie, the creator of C, and Brian Kernighan. Be careful, though - it&rsquo;s ancient and it contains some
inaccuracies (well, ideas that are not considered good anymore) or now-changed practices.</p>

<p>Another good resource is <a href="http://c.learncodethehardway.org/book/">Learn C The Hard Way</a>.</p>

<p>If you have a question, read the <a href="http://c-faq.com/">compl.lang.c Frequently Asked Questions</a>.</p>

<p>It&rsquo;s very important to use proper spacing, indentation and to be consistent with your coding style in general.
Readable code is better than clever code and fast code. For a good, sane coding style to adopt, see the
<a href="https://www.kernel.org/doc/Documentation/CodingStyle">Linux kernel coding style</a>.</p>

<p>Other than that, Google is your friend.</p>

<p>[1] http://stackoverflow.com/questions/119123/why-isnt-sizeof-for-a-struct-equal-to-the-sum-of-sizeof-of-each-member</p>

    <hr>
    <p>Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the Github Repo, or make a pull request yourself!
    </p>
    <p class="contributed">
    Originally contributed by Adam Bard, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/c.html.markdown">34 contributor(s)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2016
    
      
        <a href="http://adambard.com/">Adam Bard</a>,
      
    
      
        <a href="http://twitter.com/H2CO3_iOS">rpd Goretity</a>,
      
    
      
        <a href="http://cbs.stgn.pl/">Jakub Trzebiatowski</a>,
      
    
      
        <a href="https://marcoms.github.io/">Marco Scannadinari</a>,
      
    
      
        <a href="https://github.io/zfergus2">Zachary Ferguson</a>,
      
    
      
        <a href="https://github.com/himanshu81494">himanshu</a>
      
    
    </p>

    <p>
    

    </footer>
  </div>

        </div>

        <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="../../js/script.js"></script>

        <script>
            var _gaq=[['_setAccount','UA-3525624-21'],['_trackPageview']];
            (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)}(document,'script'));
        </script>
    </body>

<!-- Mirrored from learnxinyminutes.com/docs/c/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 02 Sep 2016 16:31:19 GMT -->
</html>
