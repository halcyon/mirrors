<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    
<!-- Mirrored from learnxinyminutes.com/docs/chapel/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 02 Sep 2016 16:33:22 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <!-- Use title if it's in the page YAML frontmatter -->
        <title>Learn chapel in Y Minutes</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="../../css/normalize.css">
        <link rel="stylesheet" href="../../css/main.css">
        <link href="../../css/screen.css" media="screen" rel="stylesheet" type="text/css" />
        <link href="../../css/github.css" media="screen" rel="stylesheet" type="text/css" />

        <link rel="canonical" href="index.html">
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <div class="container">
            <div class="share">
    <span class="sharemsg">
      <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Flearnxinyminutes.com%2Fdocs%2Fchapel%2F&amp;text=Learn+X+in+Y+minutes%2C+where+X%3Dchapel">
        Share this page
      </a></span>

      <span class='st_facebook_large' displayText='Facebook'></span>
      <span class='st_twitter_large' displayText='Tweet'></span>
  </div>
  <h1><a href="../../index.html">Learn X in Y minutes</a></h2>
  <h2>Where X=chapel</h2>
  
    <p class="filelink">
    Get the code:
    <a href="../files/learnchapel.chpl">learnchapel.chpl</a>
    </p>
  
  <div id="doc">
    <p>You can read all about Chapel at <a href="http://chapel.cray.com/">Cray&rsquo;s official Chapel website</a>.
In short, Chapel is an open-source, high-productivity, parallel-programming language in development at Cray Inc., and is designed to run on multi-core PCs as well as multi-kilocore supercomputers.</p>

<p>More information and support can be found at the bottom of this document.</p>
<pre class="highlight c"><code><span class="c1">// Comments are C-family style
// one line comment
</span><span class="cm">/*
  multi-line comment
*/</span>

<span class="c1">// Basic printing
</span><span class="n">write</span><span class="p">(</span> <span class="s">"Hello, "</span> <span class="p">);</span>
<span class="n">writeln</span><span class="p">(</span> <span class="s">"World!"</span> <span class="p">);</span>
<span class="c1">// write and writeln can take a list of things to print.
// each thing is printed right next to each other, so include your spacing!
</span><span class="n">writeln</span><span class="p">(</span> <span class="s">"There are "</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">" commas (</span><span class="se">\"</span><span class="s">,</span><span class="se">\"</span><span class="s">) in this line of code"</span> <span class="p">);</span>
<span class="c1">// Different output channels
</span><span class="n">stdout</span><span class="p">.</span><span class="n">writeln</span><span class="p">(</span> <span class="s">"This goes to standard output, just like plain writeln() does"</span><span class="p">);</span>
<span class="n">stderr</span><span class="p">.</span><span class="n">writeln</span><span class="p">(</span> <span class="s">"This goes to standard error"</span> <span class="p">);</span>

<span class="c1">// Variables don't have to be explicitly typed as long as
// the compiler can figure out the type that it will hold.
</span><span class="n">var</span> <span class="n">myVar</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// 10 is an int, so myVar is implicitly an int
</span><span class="n">myVar</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span><span class="p">;</span>
<span class="n">var</span> <span class="n">mySecondVar</span> <span class="o">=</span> <span class="n">myVar</span><span class="p">;</span>
<span class="c1">// var anError; // this would be a compile-time error.
</span>
<span class="c1">// We can (and should) explicitly type things
</span><span class="n">var</span> <span class="n">myThirdVar</span><span class="o">:</span> <span class="n">real</span><span class="p">;</span>
<span class="n">var</span> <span class="n">myFourthVar</span><span class="o">:</span> <span class="n">real</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">.</span><span class="mi">234</span><span class="p">;</span>
<span class="n">myThirdVar</span> <span class="o">=</span> <span class="n">myFourthVar</span><span class="p">;</span>

<span class="c1">// There are a number of basic types.
</span><span class="n">var</span> <span class="n">myInt</span><span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1000</span><span class="p">;</span> <span class="c1">// Signed ints
</span><span class="n">var</span> <span class="n">myUint</span><span class="o">:</span> <span class="n">uint</span> <span class="o">=</span> <span class="mi">1234</span><span class="p">;</span> <span class="c1">// Unsigned ints
</span><span class="n">var</span> <span class="n">myReal</span><span class="o">:</span> <span class="n">real</span> <span class="o">=</span> <span class="mi">9</span><span class="p">.</span><span class="mi">876</span><span class="p">;</span> <span class="c1">// Floating point numbers
</span><span class="n">var</span> <span class="n">myImag</span><span class="o">:</span> <span class="n">imag</span> <span class="o">=</span> <span class="mi">5</span><span class="p">.</span><span class="mi">0</span><span class="n">i</span><span class="p">;</span> <span class="c1">// Imaginary numbers
</span><span class="n">var</span> <span class="n">myCplx</span><span class="o">:</span> <span class="n">complex</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">+</span> <span class="mi">9</span><span class="n">i</span><span class="p">;</span> <span class="c1">// Complex numbers
</span><span class="n">myCplx</span> <span class="o">=</span> <span class="n">myInt</span> <span class="o">+</span> <span class="n">myImag</span> <span class="p">;</span> <span class="c1">// Another way to form complex numbers
</span><span class="n">var</span> <span class="n">myBool</span><span class="o">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Booleans
</span><span class="n">var</span> <span class="n">myStr</span><span class="o">:</span> <span class="n">string</span> <span class="o">=</span> <span class="s">"Some string..."</span><span class="p">;</span> <span class="c1">// Strings
</span>
<span class="c1">// Some types can have sizes
</span><span class="n">var</span> <span class="n">my8Int</span><span class="o">:</span> <span class="kt">int</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// 8 bit (one byte) sized int;
</span><span class="n">var</span> <span class="n">my64Real</span><span class="o">:</span> <span class="n">real</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">516</span><span class="p">;</span> <span class="c1">// 64 bit (8 bytes) sized real
</span>
<span class="c1">// Typecasting
</span><span class="n">var</span> <span class="n">intFromReal</span> <span class="o">=</span> <span class="n">myReal</span> <span class="o">:</span> <span class="kt">int</span><span class="p">;</span>
<span class="n">var</span> <span class="n">intFromReal2</span><span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="n">myReal</span> <span class="o">:</span> <span class="kt">int</span><span class="p">;</span>

<span class="c1">// consts are constants, they cannot be changed after set in runtime.
</span><span class="k">const</span> <span class="n">almostPi</span><span class="o">:</span> <span class="n">real</span> <span class="o">=</span> <span class="mi">22</span><span class="p">.</span><span class="mi">0</span><span class="o">/</span><span class="mi">7</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="c1">// params are constants whose value must be known statically at compile-time
// Their value cannot be changed.
</span><span class="n">param</span> <span class="n">compileTimeConst</span><span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>

<span class="c1">// The config modifier allows values to be set at the command line
// and is much easier than the usual getOpts debacle
// config vars and consts can be changed through the command line at run time
</span><span class="n">config</span> <span class="n">var</span> <span class="n">varCmdLineArg</span><span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">123</span><span class="p">;</span>
<span class="n">config</span> <span class="k">const</span> <span class="n">constCmdLineArg</span><span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">777</span><span class="p">;</span>
<span class="c1">// Set with --VarName=Value or --VarName Value at run time
</span>
<span class="c1">// config params can be set/changed at compile-time
</span><span class="n">config</span> <span class="n">param</span> <span class="n">paramCmdLineArg</span><span class="o">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="c1">// Set config with --set paramCmdLineArg=value at compile-time
</span><span class="n">writeln</span><span class="p">(</span> <span class="n">varCmdLineArg</span><span class="p">,</span> <span class="s">", "</span><span class="p">,</span> <span class="n">constCmdLineArg</span><span class="p">,</span> <span class="s">", "</span><span class="p">,</span> <span class="n">paramCmdLineArg</span> <span class="p">);</span>

<span class="c1">// refs operate much like a reference in C++
</span><span class="n">var</span> <span class="n">actual</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">ref</span> <span class="n">refToActual</span> <span class="o">=</span> <span class="n">actual</span><span class="p">;</span> <span class="c1">// refToActual refers to actual
</span><span class="n">writeln</span><span class="p">(</span> <span class="n">actual</span><span class="p">,</span> <span class="s">" == "</span><span class="p">,</span> <span class="n">refToActual</span> <span class="p">);</span> <span class="c1">// prints the same value
</span><span class="n">actual</span> <span class="o">=</span> <span class="o">-</span><span class="mi">123</span><span class="p">;</span> <span class="c1">// modify actual (which refToActual refers to)
</span><span class="n">writeln</span><span class="p">(</span> <span class="n">actual</span><span class="p">,</span> <span class="s">" == "</span><span class="p">,</span> <span class="n">refToActual</span> <span class="p">);</span> <span class="c1">// prints the same value
</span><span class="n">refToActual</span> <span class="o">=</span> <span class="mi">99999999</span><span class="p">;</span> <span class="c1">// modify what refToActual refers to (which is actual)
</span><span class="n">writeln</span><span class="p">(</span> <span class="n">actual</span><span class="p">,</span> <span class="s">" == "</span><span class="p">,</span> <span class="n">refToActual</span> <span class="p">);</span> <span class="c1">// prints the same value
</span>
<span class="c1">// Math operators
</span><span class="n">var</span> <span class="n">a</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">thisInt</span> <span class="o">=</span> <span class="mi">1234</span><span class="p">,</span> <span class="n">thatInt</span> <span class="o">=</span> <span class="mi">5678</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">thisInt</span> <span class="o">+</span> <span class="n">thatInt</span><span class="p">;</span>  <span class="c1">// Addition
</span><span class="n">a</span> <span class="o">=</span> <span class="n">thisInt</span> <span class="o">*</span> <span class="n">thatInt</span><span class="p">;</span>  <span class="c1">// Multiplication
</span><span class="n">a</span> <span class="o">=</span> <span class="n">thisInt</span> <span class="o">-</span> <span class="n">thatInt</span><span class="p">;</span>  <span class="c1">// Subtraction
</span><span class="n">a</span> <span class="o">=</span> <span class="n">thisInt</span> <span class="o">/</span> <span class="n">thatInt</span><span class="p">;</span>  <span class="c1">// Division
</span><span class="n">a</span> <span class="o">=</span> <span class="n">thisInt</span> <span class="o">**</span> <span class="n">thatInt</span><span class="p">;</span> <span class="c1">// Exponentiation
</span><span class="n">a</span> <span class="o">=</span> <span class="n">thisInt</span> <span class="o">%</span> <span class="n">thatInt</span><span class="p">;</span>  <span class="c1">// Remainder (modulo)
</span>
<span class="c1">// Logical Operators
</span><span class="n">var</span> <span class="n">b</span><span class="o">:</span> <span class="n">bool</span><span class="p">,</span> <span class="n">thisBool</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="n">thatBool</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">thisBool</span> <span class="o">&amp;&amp;</span> <span class="n">thatBool</span><span class="p">;</span> <span class="c1">// Logical and
</span><span class="n">b</span> <span class="o">=</span> <span class="n">thisBool</span> <span class="o">||</span> <span class="n">thatBool</span><span class="p">;</span> <span class="c1">// Logical or
</span><span class="n">b</span> <span class="o">=</span> <span class="o">!</span><span class="n">thisBool</span><span class="p">;</span>            <span class="c1">// Logical negation
</span>
<span class="c1">// Relational Operators
</span><span class="n">b</span> <span class="o">=</span> <span class="n">thisInt</span> <span class="o">&gt;</span> <span class="n">thatInt</span><span class="p">;</span>           <span class="c1">// Greater-than
</span><span class="n">b</span> <span class="o">=</span> <span class="n">thisInt</span> <span class="o">&gt;=</span> <span class="n">thatInt</span><span class="p">;</span>          <span class="c1">// Greater-than-or-equal-to
</span><span class="n">b</span> <span class="o">=</span> <span class="n">thisInt</span> <span class="o">&lt;</span> <span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">thatInt</span><span class="p">;</span> <span class="c1">// Less-than, and, less-than-or-equal-to
</span><span class="n">b</span> <span class="o">=</span> <span class="n">thisInt</span> <span class="o">!=</span> <span class="n">thatInt</span><span class="p">;</span>          <span class="c1">// Not-equal-to
</span><span class="n">b</span> <span class="o">=</span> <span class="n">thisInt</span> <span class="o">==</span> <span class="n">thatInt</span><span class="p">;</span>          <span class="c1">// Equal-to
</span>
<span class="c1">// Bitwise operations
</span><span class="n">a</span> <span class="o">=</span> <span class="n">thisInt</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">;</span>     <span class="c1">// Left-bit-shift by 10 bits;
</span><span class="n">a</span> <span class="o">=</span> <span class="n">thatInt</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">;</span>      <span class="c1">// Right-bit-shift by 5 bits;
</span><span class="n">a</span> <span class="o">=</span> <span class="o">~</span><span class="n">thisInt</span><span class="p">;</span>          <span class="c1">// Bitwise-negation
</span><span class="n">a</span> <span class="o">=</span> <span class="n">thisInt</span> <span class="o">^</span> <span class="n">thatInt</span><span class="p">;</span> <span class="c1">// Bitwise exclusive-or
</span>
<span class="c1">// Compound assignment operations
</span><span class="n">a</span> <span class="o">+=</span> <span class="n">thisInt</span><span class="p">;</span>          <span class="c1">// Addition-equals ( a = a + thisInt;)
</span><span class="n">a</span> <span class="o">*=</span> <span class="n">thatInt</span><span class="p">;</span>          <span class="c1">// Times-equals ( a = a * thatInt; )
</span><span class="n">b</span> <span class="o">&amp;&amp;=</span> <span class="n">thatBool</span><span class="p">;</span>        <span class="c1">// Logical-and-equals ( b = b &amp;&amp; thatBool; )
</span><span class="n">a</span> <span class="o">&lt;&lt;=</span> <span class="mi">3</span><span class="p">;</span>               <span class="c1">// Left-bit-shift-equals ( a = a &lt;&lt; 10; )
// and many, many more.
// Unlike other C family languages there are no
// pre/post-increment/decrement operators like
//  ++j, --j, j++, j--
</span>
<span class="c1">// Swap operator
</span><span class="n">var</span> <span class="n">old_this</span> <span class="o">=</span> <span class="n">thisInt</span><span class="p">;</span>
<span class="n">var</span> <span class="n">old_that</span> <span class="o">=</span> <span class="n">thatInt</span><span class="p">;</span>
<span class="n">thisInt</span> <span class="o">&lt;=&gt;</span> <span class="n">thatInt</span><span class="p">;</span> <span class="c1">// Swap the values of thisInt and thatInt
</span><span class="n">writeln</span><span class="p">(</span> <span class="p">(</span><span class="n">old_this</span> <span class="o">==</span> <span class="n">thatInt</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">old_that</span> <span class="o">==</span> <span class="n">thisInt</span><span class="p">)</span> <span class="p">);</span>

<span class="c1">// Operator overloads can also be defined, as we'll see with procedures
</span>
<span class="c1">// Tuples can be of the same type
</span><span class="n">var</span> <span class="n">sameTup</span><span class="o">:</span> <span class="mi">2</span><span class="o">*</span><span class="kt">int</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="n">var</span> <span class="n">sameTup2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">);</span>
<span class="c1">// or different types
</span><span class="n">var</span> <span class="n">diffTup</span><span class="o">:</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="n">real</span><span class="p">,</span><span class="n">complex</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">928</span><span class="p">,</span> <span class="n">myCplx</span><span class="p">);</span>
<span class="n">var</span> <span class="n">diffTupe2</span> <span class="o">=</span> <span class="p">(</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">.</span><span class="mi">64</span><span class="p">,</span> <span class="mi">6</span><span class="p">.</span><span class="mi">0</span><span class="o">+</span><span class="mi">1</span><span class="p">.</span><span class="mi">5</span><span class="n">i</span> <span class="p">);</span>

<span class="c1">// Accessed using array bracket notation
// However, tuples are all 1-indexed
</span><span class="n">writeln</span><span class="p">(</span> <span class="s">"("</span><span class="p">,</span> <span class="n">sameTup</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">","</span><span class="p">,</span> <span class="n">sameTup</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s">")"</span> <span class="p">);</span>
<span class="n">writeln</span><span class="p">(</span> <span class="n">diffTup</span> <span class="p">);</span>

<span class="c1">// Tuples can also be written into.
</span><span class="n">diffTup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="c1">// Can expand tuple values into their own variables
</span><span class="n">var</span> <span class="p">(</span><span class="n">tupInt</span><span class="p">,</span> <span class="n">tupReal</span><span class="p">,</span> <span class="n">tupCplx</span><span class="p">)</span> <span class="o">=</span> <span class="n">diffTup</span><span class="p">;</span>
<span class="n">writeln</span><span class="p">(</span> <span class="n">diffTup</span> <span class="o">==</span> <span class="p">(</span><span class="n">tupInt</span><span class="p">,</span> <span class="n">tupReal</span><span class="p">,</span> <span class="n">tupCplx</span><span class="p">)</span> <span class="p">);</span>

<span class="c1">// Useful for writing a list of variables ( as is common in debugging)
</span><span class="n">writeln</span><span class="p">(</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">thisInt</span><span class="p">,</span><span class="n">thatInt</span><span class="p">,</span><span class="n">thisBool</span><span class="p">,</span><span class="n">thatBool</span><span class="p">)</span> <span class="p">);</span>

<span class="c1">// Type aliasing
</span><span class="n">type</span> <span class="n">chroma</span> <span class="o">=</span> <span class="kt">int</span><span class="p">;</span>        <span class="c1">// Type of a single hue
</span><span class="n">type</span> <span class="n">RGBColor</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">chroma</span><span class="p">;</span> <span class="c1">// Type representing a full color
</span><span class="n">var</span> <span class="n">black</span><span class="o">:</span> <span class="n">RGBColor</span> <span class="o">=</span> <span class="p">(</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span> <span class="p">);</span>
<span class="n">var</span> <span class="n">white</span><span class="o">:</span> <span class="n">RGBColor</span> <span class="o">=</span> <span class="p">(</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span> <span class="p">);</span>

<span class="c1">// If-then-else works just like any other C-family language
</span><span class="k">if</span> <span class="mi">10</span> <span class="o">&lt;</span> <span class="mi">100</span> <span class="n">then</span>
  <span class="n">writeln</span><span class="p">(</span> <span class="s">"All is well"</span> <span class="p">);</span>

<span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="n">then</span>
  <span class="n">writeln</span><span class="p">(</span> <span class="s">"Continuing to believe reality"</span> <span class="p">);</span>
<span class="k">else</span>
  <span class="n">writeln</span><span class="p">(</span> <span class="s">"Send mathematician, something's wrong"</span> <span class="p">);</span>

<span class="k">if</span> <span class="p">(</span> <span class="mi">10</span> <span class="o">&gt;</span> <span class="mi">100</span> <span class="p">)</span> <span class="p">{</span>
  <span class="n">writeln</span><span class="p">(</span> <span class="s">"Universe broken. Please reboot universe."</span> <span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span> <span class="n">a</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
  <span class="n">writeln</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="s">" is even."</span> <span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="n">writeln</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="s">" is odd."</span> <span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span> <span class="n">a</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
  <span class="n">writeln</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="s">" is even divisible by 3."</span> <span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">a</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">){</span>
  <span class="n">writeln</span><span class="p">(</span> <span class="n">a</span><span class="p">,</span> <span class="s">" is divided by 3 with a remainder of 1."</span> <span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="n">writeln</span><span class="p">(</span> <span class="n">b</span><span class="p">,</span> <span class="s">" is divided by 3 with a remainder of 2."</span> <span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Ternary: if-then-else in a statement
</span><span class="n">var</span> <span class="n">maximum</span> <span class="o">=</span> <span class="k">if</span> <span class="p">(</span> <span class="n">thisInt</span> <span class="o">&lt;</span> <span class="n">thatInt</span> <span class="p">)</span> <span class="n">then</span> <span class="n">thatInt</span> <span class="k">else</span> <span class="n">thisInt</span><span class="p">;</span>

<span class="c1">// Select statements are much like switch statements in other languages
// However, Select statements don't cascade like in C or Java
</span><span class="n">var</span> <span class="n">inputOption</span> <span class="o">=</span> <span class="s">"anOption"</span><span class="p">;</span>
<span class="n">select</span><span class="p">(</span> <span class="n">inputOption</span> <span class="p">){</span>
  <span class="n">when</span> <span class="s">"anOption"</span> <span class="k">do</span> <span class="n">writeln</span><span class="p">(</span> <span class="s">"Chose 'anOption'"</span> <span class="p">);</span>
  <span class="n">when</span> <span class="s">"otherOption"</span> <span class="p">{</span>
    <span class="n">writeln</span><span class="p">(</span> <span class="s">"Chose 'otherOption'"</span> <span class="p">);</span>
    <span class="n">writeln</span><span class="p">(</span> <span class="s">"Which has a body"</span> <span class="p">);</span>
  <span class="p">}</span>
  <span class="n">otherwise</span> <span class="p">{</span>
    <span class="n">writeln</span><span class="p">(</span> <span class="s">"Any other Input"</span> <span class="p">);</span>
    <span class="n">writeln</span><span class="p">(</span> <span class="s">"the otherwise case doesn't need a do if the body is one line"</span> <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// While and Do-While loops are basically the same in every language.
</span><span class="n">var</span> <span class="n">j</span><span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">var</span> <span class="n">jSum</span><span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="mi">1000</span> <span class="p">){</span>
  <span class="n">jSum</span> <span class="o">+=</span> <span class="n">j</span><span class="p">;</span>
  <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">writeln</span><span class="p">(</span> <span class="n">jSum</span> <span class="p">);</span>

<span class="c1">// Do-While loop
</span><span class="k">do</span><span class="p">{</span>
  <span class="n">jSum</span> <span class="o">+=</span> <span class="n">j</span><span class="p">;</span>
  <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span><span class="k">while</span><span class="p">(</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="mi">10000</span> <span class="p">);</span>
<span class="n">writeln</span><span class="p">(</span> <span class="n">jSum</span> <span class="p">);</span>

<span class="c1">// For loops are much like those in python in that they iterate over a range.
// Ranges themselves are types, and can be stuffed into variables
// (more about that later)
</span><span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">1</span><span class="p">..</span><span class="mi">10</span> <span class="k">do</span> <span class="n">write</span><span class="p">(</span> <span class="n">i</span> <span class="p">,</span> <span class="s">", "</span><span class="p">)</span> <span class="p">;</span>
<span class="n">writeln</span><span class="p">(</span> <span class="p">);</span>

<span class="n">var</span> <span class="n">iSum</span><span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">1</span><span class="p">..</span><span class="mi">1000</span> <span class="p">{</span>
  <span class="n">iSum</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">writeln</span><span class="p">(</span> <span class="n">iSum</span> <span class="p">);</span>

<span class="k">for</span> <span class="n">x</span> <span class="n">in</span> <span class="mi">1</span><span class="p">..</span><span class="mi">10</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">y</span> <span class="n">in</span> <span class="mi">1</span><span class="p">..</span><span class="mi">10</span> <span class="p">{</span>
    <span class="n">write</span><span class="p">(</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span> <span class="s">"</span><span class="se">\t</span><span class="s">"</span> <span class="p">);</span>
  <span class="p">}</span>
  <span class="n">writeln</span><span class="p">(</span> <span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Ranges and Domains
// For-loops and arrays both use ranges and domains to
// define an index set that can be iterated over.
// Ranges are single dimensional
// Domains can be multi-dimensional and can
// represent indices of different types as well.
// They are first-class citizen types, and can be assigned into variables
</span><span class="n">var</span> <span class="n">range1to10</span><span class="o">:</span> <span class="n">range</span> <span class="o">=</span> <span class="mi">1</span><span class="p">..</span><span class="mi">10</span><span class="p">;</span>  <span class="c1">// 1, 2, 3, ..., 10
</span><span class="n">var</span> <span class="n">range2to11</span> <span class="o">=</span> <span class="mi">2</span><span class="p">..</span><span class="mi">11</span><span class="p">;</span> <span class="c1">// 2, 3, 4, ..., 11
</span><span class="n">var</span> <span class="n">rangeThistoThat</span><span class="o">:</span> <span class="n">range</span> <span class="o">=</span> <span class="n">thisInt</span><span class="p">..</span><span class="n">thatInt</span><span class="p">;</span> <span class="c1">// using variables
</span><span class="n">var</span> <span class="n">rangeEmpty</span><span class="o">:</span> <span class="n">range</span> <span class="o">=</span> <span class="mi">100</span><span class="p">..</span><span class="o">-</span><span class="mi">100</span> <span class="p">;</span> <span class="c1">// this is valid but contains no indices
</span>
<span class="c1">// Ranges can be unbounded
</span><span class="n">var</span> <span class="n">range1toInf</span><span class="o">:</span> <span class="n">range</span><span class="p">(</span><span class="n">boundedType</span><span class="o">=</span><span class="n">BoundedRangeType</span><span class="p">.</span><span class="n">boundedLow</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">..</span> <span class="p">;</span>
<span class="c1">// 1, 2, 3, 4, 5, ...
// Note: the range(boundedType= ... ) is only
// necessary if we explicitly type the variable
</span>
<span class="n">var</span> <span class="n">rangeNegInfto1</span> <span class="o">=</span> <span class="p">..</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// ..., -4, -3, -2, -1, 0, 1
</span>
<span class="c1">// Ranges can be strided using the 'by' operator.
</span><span class="n">var</span> <span class="n">range2to10by2</span><span class="o">:</span> <span class="n">range</span><span class="p">(</span><span class="n">stridable</span><span class="o">=</span><span class="nb">true</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="p">..</span><span class="mi">10</span> <span class="n">by</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 2, 4, 6, 8, 10
// Note: the range(stridable=true) is only
// necessary if we explicitly type the variable
</span>
<span class="c1">// Use by to create a reverse range
</span><span class="n">var</span> <span class="n">reverse2to10by2</span> <span class="o">=</span> <span class="mi">10</span><span class="p">..</span><span class="mi">2</span> <span class="n">by</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span> <span class="c1">// 10, 8, 6, 4, 2
</span>
<span class="c1">// The end point of a range can be determined using the count (#) operator
</span><span class="n">var</span> <span class="n">rangeCount</span><span class="o">:</span> <span class="n">range</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="p">..</span><span class="err">#</span><span class="mi">12</span><span class="p">;</span> <span class="c1">// range from -5 to 6
</span>
<span class="c1">// Can mix operators
</span><span class="n">var</span> <span class="n">rangeCountBy</span><span class="o">:</span> <span class="n">range</span><span class="p">(</span><span class="n">stridable</span><span class="o">=</span><span class="nb">true</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="p">..</span><span class="err">#</span><span class="mi">12</span> <span class="n">by</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// -5, -3, -1, 1, 3, 5
</span><span class="n">writeln</span><span class="p">(</span> <span class="n">rangeCountBy</span> <span class="p">);</span>

<span class="c1">// Can query properties of the range
// Print the first index, last index, number of indices,
// stride, and ask if 2 is include in the range
</span><span class="n">writeln</span><span class="p">(</span> <span class="p">(</span> <span class="n">rangeCountBy</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">rangeCountBy</span><span class="p">.</span><span class="n">last</span><span class="p">,</span> <span class="n">rangeCountBy</span><span class="p">.</span><span class="n">length</span><span class="p">,</span>
           <span class="n">rangeCountBy</span><span class="p">.</span><span class="n">stride</span><span class="p">,</span> <span class="n">rangeCountBy</span><span class="p">.</span><span class="n">member</span><span class="p">(</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">)</span> <span class="p">);</span>

<span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="n">rangeCountBy</span><span class="p">{</span>
  <span class="n">write</span><span class="p">(</span> <span class="n">i</span><span class="p">,</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">rangeCountBy</span><span class="p">.</span><span class="n">last</span> <span class="n">then</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span> <span class="k">else</span> <span class="s">", "</span> <span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Rectangular domains are defined using the same range syntax
// However they are required to be bounded (unlike ranges)
</span><span class="n">var</span> <span class="n">domain1to10</span><span class="o">:</span> <span class="n">domain</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">..</span><span class="mi">10</span><span class="p">};</span>        <span class="c1">// 1D domain from 1..10;
</span><span class="n">var</span> <span class="n">twoDimensions</span><span class="o">:</span> <span class="n">domain</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">2</span><span class="p">..</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">..</span><span class="mi">2</span><span class="p">};</span> <span class="c1">// 2D domain over product of ranges
</span><span class="n">var</span> <span class="n">thirdDim</span><span class="o">:</span> <span class="n">range</span> <span class="o">=</span> <span class="mi">1</span><span class="p">..</span><span class="mi">16</span><span class="p">;</span>
<span class="n">var</span> <span class="n">threeDims</span><span class="o">:</span> <span class="n">domain</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span><span class="n">thirdDim</span><span class="p">,</span> <span class="mi">1</span><span class="p">..</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">..</span><span class="mi">10</span><span class="p">};</span> <span class="c1">// using a range variable
</span>
<span class="c1">// Can iterate over the indices as tuples
</span><span class="k">for</span> <span class="n">idx</span> <span class="n">in</span> <span class="n">twoDimensions</span> <span class="k">do</span>
  <span class="n">write</span><span class="p">(</span> <span class="n">idx</span> <span class="p">,</span> <span class="s">", "</span><span class="p">);</span>
<span class="n">writeln</span><span class="p">(</span> <span class="p">);</span>

<span class="c1">// or can deconstruct the tuple
</span><span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="n">in</span> <span class="n">twoDimensions</span> <span class="p">{</span>
  <span class="n">write</span><span class="p">(</span> <span class="s">"("</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s">", "</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s">")"</span><span class="p">,</span> <span class="s">", "</span> <span class="p">);</span>
<span class="p">}</span>
<span class="n">writeln</span><span class="p">(</span> <span class="p">);</span>

<span class="c1">// Associative domains act like sets
</span><span class="n">var</span> <span class="n">stringSet</span><span class="o">:</span> <span class="n">domain</span><span class="p">(</span><span class="n">string</span><span class="p">);</span> <span class="c1">// empty set of strings
</span><span class="n">stringSet</span> <span class="o">+=</span> <span class="s">"a"</span><span class="p">;</span>
<span class="n">stringSet</span> <span class="o">+=</span> <span class="s">"b"</span><span class="p">;</span>
<span class="n">stringSet</span> <span class="o">+=</span> <span class="s">"c"</span><span class="p">;</span>
<span class="n">stringSet</span> <span class="o">+=</span> <span class="s">"a"</span><span class="p">;</span> <span class="c1">// Redundant add "a"
</span><span class="n">stringSet</span> <span class="o">-=</span> <span class="s">"c"</span><span class="p">;</span> <span class="c1">// Remove "c"
</span><span class="n">writeln</span><span class="p">(</span> <span class="n">stringSet</span> <span class="p">);</span>

<span class="c1">// Both ranges and domains can be sliced to produce a range or domain with the
// intersection of indices
</span><span class="n">var</span> <span class="n">rangeA</span> <span class="o">=</span> <span class="mi">1</span><span class="p">..</span> <span class="p">;</span> <span class="c1">// range from 1 to infinity
</span><span class="n">var</span> <span class="n">rangeB</span> <span class="o">=</span>  <span class="p">..</span><span class="mi">5</span><span class="p">;</span> <span class="c1">// range from negative infinity to 5
</span><span class="n">var</span> <span class="n">rangeC</span> <span class="o">=</span> <span class="n">rangeA</span><span class="p">[</span><span class="n">rangeB</span><span class="p">];</span> <span class="c1">// resulting range is 1..5
</span><span class="n">writeln</span><span class="p">(</span> <span class="p">(</span><span class="n">rangeA</span><span class="p">,</span> <span class="n">rangeB</span><span class="p">,</span> <span class="n">rangeC</span> <span class="p">)</span> <span class="p">);</span>

<span class="n">var</span> <span class="n">domainA</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">..</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">..</span><span class="mi">20</span><span class="p">};</span>
<span class="n">var</span> <span class="n">domainB</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">5</span><span class="p">..</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">..</span><span class="mi">10</span><span class="p">};</span>
<span class="n">var</span> <span class="n">domainC</span> <span class="o">=</span> <span class="n">domainA</span><span class="p">[</span><span class="n">domainB</span><span class="p">];</span>
<span class="n">writeln</span><span class="p">(</span> <span class="p">(</span><span class="n">domainA</span><span class="p">,</span> <span class="n">domainB</span><span class="p">,</span> <span class="n">domainC</span><span class="p">)</span> <span class="p">);</span>

<span class="c1">// Array are similar to those of other languages.
// Their sizes are defined using domains that represent their indices
</span><span class="n">var</span> <span class="n">intArray</span><span class="o">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">..</span><span class="mi">10</span><span class="p">]</span> <span class="kt">int</span><span class="p">;</span>
<span class="n">var</span> <span class="n">intArray2</span><span class="o">:</span> <span class="p">[{</span><span class="mi">1</span><span class="p">..</span><span class="mi">10</span><span class="p">}]</span> <span class="kt">int</span><span class="p">;</span> <span class="c1">//equivalent
</span>
<span class="c1">// Accessed using bracket notation
</span><span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">1</span><span class="p">..</span><span class="mi">10</span> <span class="k">do</span>
  <span class="n">intArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">i</span><span class="p">;</span>
<span class="n">writeln</span><span class="p">(</span> <span class="n">intArray</span> <span class="p">);</span>
<span class="c1">// We cannot access intArray[0] because it exists outside
// of the index set, {1..10}, we defined it to have.
// intArray[11] is illegal for the same reason.
</span>
<span class="n">var</span> <span class="n">realDomain</span><span class="o">:</span> <span class="n">domain</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">..</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">..</span><span class="mi">7</span><span class="p">};</span>
<span class="n">var</span> <span class="n">realArray</span><span class="o">:</span> <span class="p">[</span><span class="n">realDomain</span><span class="p">]</span> <span class="n">real</span><span class="p">;</span>
<span class="n">var</span> <span class="n">realArray2</span><span class="o">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">..</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">..</span><span class="mi">7</span><span class="p">]</span> <span class="n">real</span><span class="p">;</span>   <span class="c1">// Equivalent
</span><span class="n">var</span> <span class="n">realArray3</span><span class="o">:</span> <span class="p">[{</span><span class="mi">1</span><span class="p">..</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">..</span><span class="mi">7</span><span class="p">}]</span> <span class="n">real</span><span class="p">;</span> <span class="c1">// Equivalent
</span>
<span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">1</span><span class="p">..</span><span class="mi">5</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">j</span> <span class="n">in</span> <span class="n">realDomain</span><span class="p">.</span><span class="n">dim</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>   <span class="c1">// Only use the 2nd dimension of the domain
</span>    <span class="n">realArray</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">.</span><span class="mi">61803</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span> <span class="o">*</span> <span class="n">j</span><span class="p">;</span>  <span class="c1">// Access using index list
</span>    <span class="n">var</span> <span class="n">idx</span><span class="o">:</span> <span class="mi">2</span><span class="o">*</span><span class="kt">int</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>                   <span class="c1">// Note: 'index' is a keyword
</span>    <span class="n">realArray</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">realArray</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)];</span>      <span class="c1">// Index using tuples
</span>  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Arrays have domains as members that we can iterate over
</span><span class="k">for</span> <span class="n">idx</span> <span class="n">in</span> <span class="n">realArray</span><span class="p">.</span><span class="n">domain</span> <span class="p">{</span>  <span class="c1">// Again, idx is a 2*int tuple
</span>  <span class="n">realArray</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">realArray</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">idx</span><span class="p">[</span><span class="mi">2</span><span class="p">]];</span> <span class="c1">// Access by tuple and list
</span><span class="p">}</span>

<span class="n">writeln</span><span class="p">(</span> <span class="n">realArray</span> <span class="p">);</span>

<span class="c1">// Can also iterate over the values of an array
</span><span class="n">var</span> <span class="n">rSum</span><span class="o">:</span> <span class="n">real</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="n">value</span> <span class="n">in</span> <span class="n">realArray</span> <span class="p">{</span>
  <span class="n">rSum</span> <span class="o">+=</span> <span class="n">value</span><span class="p">;</span> <span class="c1">// Read a value
</span>  <span class="n">value</span> <span class="o">=</span> <span class="n">rSum</span><span class="p">;</span>  <span class="c1">// Write a value
</span><span class="p">}</span>
<span class="n">writeln</span><span class="p">(</span> <span class="n">rSum</span><span class="p">,</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">realArray</span> <span class="p">);</span>

<span class="c1">// Using associative domains we can create associative arrays (dictionaries)
</span><span class="n">var</span> <span class="n">dictDomain</span><span class="o">:</span> <span class="n">domain</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span> <span class="s">"one"</span><span class="p">,</span> <span class="s">"two"</span> <span class="p">};</span>
<span class="n">var</span> <span class="n">dict</span><span class="o">:</span> <span class="p">[</span><span class="n">dictDomain</span><span class="p">]</span> <span class="kt">int</span> <span class="o">=</span> <span class="p">[</span> <span class="s">"one"</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s">"two"</span> <span class="o">=&gt;</span> <span class="mi">2</span> <span class="p">];</span>
<span class="n">dict</span><span class="p">[</span><span class="s">"three"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="k">for</span> <span class="n">key</span> <span class="n">in</span> <span class="n">dictDomain</span> <span class="k">do</span> <span class="n">writeln</span><span class="p">(</span> <span class="n">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">);</span>

<span class="c1">// Arrays can be assigned to each other in different ways
</span><span class="n">var</span> <span class="n">thisArray</span> <span class="o">:</span> <span class="p">[{</span><span class="mi">0</span><span class="p">..</span><span class="mi">5</span><span class="p">}]</span> <span class="kt">int</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">];</span>
<span class="n">var</span> <span class="n">thatArray</span> <span class="o">:</span> <span class="p">[{</span><span class="mi">0</span><span class="p">..</span><span class="mi">5</span><span class="p">}]</span> <span class="kt">int</span><span class="p">;</span>

<span class="c1">// Simply assign one to the other.
// This copies thisArray into thatArray, instead of just creating a reference.
// Modifying thisArray does not also modify thatArray.
</span><span class="n">thatArray</span> <span class="o">=</span> <span class="n">thisArray</span><span class="p">;</span>
<span class="n">thatArray</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">writeln</span><span class="p">(</span> <span class="p">(</span><span class="n">thisArray</span><span class="p">,</span> <span class="n">thatArray</span><span class="p">)</span> <span class="p">);</span>

<span class="c1">// Assign a slice one array to a slice (of the same size) of the other.
</span><span class="n">thatArray</span><span class="p">[{</span><span class="mi">4</span><span class="p">..</span><span class="mi">5</span><span class="p">}]</span> <span class="o">=</span> <span class="n">thisArray</span><span class="p">[{</span><span class="mi">1</span><span class="p">..</span><span class="mi">2</span><span class="p">}];</span>
<span class="n">writeln</span><span class="p">(</span> <span class="p">(</span><span class="n">thisArray</span><span class="p">,</span> <span class="n">thatArray</span><span class="p">)</span> <span class="p">);</span>

<span class="c1">// Operation can also be promoted to work on arrays.
</span><span class="n">var</span> <span class="n">thisPlusThat</span> <span class="o">=</span> <span class="n">thisArray</span> <span class="o">+</span> <span class="n">thatArray</span><span class="p">;</span>
<span class="n">writeln</span><span class="p">(</span> <span class="n">thisPlusThat</span> <span class="p">);</span>

<span class="c1">// Arrays and loops can also be expressions, where loop
// body's expression is the result of each iteration.
</span><span class="n">var</span> <span class="n">arrayFromLoop</span> <span class="o">=</span> <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">1</span><span class="p">..</span><span class="mi">10</span> <span class="k">do</span> <span class="n">i</span><span class="p">;</span>
<span class="n">writeln</span><span class="p">(</span> <span class="n">arrayFromLoop</span> <span class="p">);</span>

<span class="c1">// An expression can result in nothing,
// such as when filtering with an if-expression
</span><span class="n">var</span> <span class="n">evensOrFives</span> <span class="o">=</span> <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">1</span><span class="p">..</span><span class="mi">10</span> <span class="k">do</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">then</span> <span class="n">i</span><span class="p">;</span>

<span class="n">writeln</span><span class="p">(</span> <span class="n">arrayFromLoop</span> <span class="p">);</span>

<span class="c1">// Or could be written with a bracket notation
// Note: this syntax uses the 'forall' parallel concept discussed later.
</span><span class="n">var</span> <span class="n">evensOrFivesAgain</span> <span class="o">=</span> <span class="p">[</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">1</span><span class="p">..</span><span class="mi">10</span> <span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">then</span> <span class="n">i</span><span class="p">;</span>

<span class="c1">// Or over the values of the array
</span><span class="n">arrayFromLoop</span> <span class="o">=</span> <span class="p">[</span> <span class="n">value</span> <span class="n">in</span> <span class="n">arrayFromLoop</span> <span class="p">]</span> <span class="n">value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">// Note: this notation can get somewhat tricky. For example:
// evensOrFives = [ i in 1..10 ] if (i % 2 == 0 || i % 5 == 0) then i;
// would break.
// The reasons for this are explained in depth when discussing zipped iterators.
</span>
<span class="c1">// Chapel procedures have similar syntax to other languages functions.
</span><span class="n">proc</span> <span class="n">fibonacci</span><span class="p">(</span> <span class="n">n</span> <span class="o">:</span> <span class="kt">int</span> <span class="p">)</span> <span class="o">:</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">)</span> <span class="n">then</span> <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">fibonacci</span><span class="p">(</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="p">)</span> <span class="o">+</span> <span class="n">fibonacci</span><span class="p">(</span> <span class="n">n</span><span class="o">-</span><span class="mi">2</span> <span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Input parameters can be untyped (a generic procedure)
</span><span class="n">proc</span> <span class="n">doublePrint</span><span class="p">(</span> <span class="n">thing</span> <span class="p">)</span><span class="o">:</span> <span class="kt">void</span> <span class="p">{</span>
  <span class="n">write</span><span class="p">(</span> <span class="n">thing</span><span class="p">,</span> <span class="s">" "</span><span class="p">,</span> <span class="n">thing</span><span class="p">,</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Return type can be inferred (as long as the compiler can figure it out)
</span><span class="n">proc</span> <span class="n">addThree</span><span class="p">(</span> <span class="n">n</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">doublePrint</span><span class="p">(</span> <span class="n">addThree</span><span class="p">(</span> <span class="n">fibonacci</span><span class="p">(</span> <span class="mi">20</span> <span class="p">)</span> <span class="p">)</span> <span class="p">);</span>

<span class="c1">// Can also take 'unlimited' number of parameters
</span><span class="n">proc</span> <span class="nf">maxOf</span><span class="p">(</span> <span class="n">x</span> <span class="p">...</span><span class="o">?</span><span class="n">k</span> <span class="p">)</span> <span class="p">{</span>
  <span class="c1">// x refers to a tuple of one type, with k elements
</span>  <span class="n">var</span> <span class="n">maximum</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">2</span><span class="p">..</span><span class="n">k</span> <span class="k">do</span> <span class="n">maximum</span> <span class="o">=</span> <span class="k">if</span> <span class="p">(</span><span class="n">maximum</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="n">then</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">else</span> <span class="n">maximum</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">maximum</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">writeln</span><span class="p">(</span> <span class="n">maxOf</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">189</span><span class="p">,</span> <span class="o">-</span><span class="mi">9071982</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">20001</span><span class="p">,</span> <span class="mi">42</span> <span class="p">)</span> <span class="p">);</span>

<span class="c1">// The ? operator is called the query operator, and is used to take
// undetermined values (like tuple or array sizes, and generic types).
</span>
<span class="c1">// Taking arrays as parameters.
// The query operator is used to determine the domain of A.
// This is important to define the return type (if you wanted to)
</span><span class="n">proc</span> <span class="n">invertArray</span><span class="p">(</span> <span class="n">A</span><span class="o">:</span> <span class="p">[</span><span class="o">?</span><span class="n">D</span><span class="p">]</span> <span class="kt">int</span> <span class="p">)</span><span class="o">:</span> <span class="p">[</span><span class="n">D</span><span class="p">]</span> <span class="kt">int</span><span class="p">{</span>
  <span class="k">for</span> <span class="n">a</span> <span class="n">in</span> <span class="n">A</span> <span class="k">do</span> <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="n">a</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">A</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">writeln</span><span class="p">(</span> <span class="n">invertArray</span><span class="p">(</span> <span class="n">intArray</span> <span class="p">)</span> <span class="p">);</span>

<span class="c1">// Procedures can have default parameter values, and
// the parameters can be named in the call, even out of order
</span><span class="n">proc</span> <span class="n">defaultsProc</span><span class="p">(</span> <span class="n">x</span><span class="o">:</span> <span class="kt">int</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span> <span class="n">real</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">2634</span> <span class="p">)</span><span class="o">:</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="n">real</span><span class="p">){</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">writeln</span><span class="p">(</span> <span class="n">defaultsProc</span><span class="p">(</span> <span class="mi">10</span> <span class="p">)</span> <span class="p">);</span>
<span class="n">writeln</span><span class="p">(</span> <span class="n">defaultsProc</span><span class="p">(</span> <span class="n">x</span><span class="o">=</span><span class="mi">11</span> <span class="p">)</span> <span class="p">);</span>
<span class="n">writeln</span><span class="p">(</span> <span class="n">defaultsProc</span><span class="p">(</span> <span class="n">x</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">5</span><span class="p">.</span><span class="mi">432</span> <span class="p">)</span> <span class="p">);</span>
<span class="n">writeln</span><span class="p">(</span> <span class="n">defaultsProc</span><span class="p">(</span> <span class="n">y</span><span class="o">=</span><span class="mi">9</span><span class="p">.</span><span class="mi">876</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">13</span> <span class="p">)</span> <span class="p">);</span>

<span class="c1">// Intent modifiers on the arguments convey how
// those arguments are passed to the procedure
// in: copy arg in, but not out
// out: copy arg out, but not in
// inout: copy arg in, copy arg out
// ref: pass arg by reference
</span><span class="n">proc</span> <span class="n">intentsProc</span><span class="p">(</span> <span class="n">in</span> <span class="n">inarg</span><span class="p">,</span> <span class="n">out</span> <span class="n">outarg</span><span class="p">,</span> <span class="n">inout</span> <span class="n">inoutarg</span><span class="p">,</span> <span class="n">ref</span> <span class="n">refarg</span> <span class="p">){</span>
  <span class="n">writeln</span><span class="p">(</span> <span class="s">"Inside Before: "</span><span class="p">,</span> <span class="p">(</span><span class="n">inarg</span><span class="p">,</span> <span class="n">outarg</span><span class="p">,</span> <span class="n">inoutarg</span><span class="p">,</span> <span class="n">refarg</span><span class="p">)</span> <span class="p">);</span>
  <span class="n">inarg</span> <span class="o">=</span> <span class="n">inarg</span> <span class="o">+</span> <span class="mi">100</span><span class="p">;</span>
  <span class="n">outarg</span> <span class="o">=</span> <span class="n">outarg</span> <span class="o">+</span> <span class="mi">100</span><span class="p">;</span>
  <span class="n">inoutarg</span> <span class="o">=</span> <span class="n">inoutarg</span> <span class="o">+</span> <span class="mi">100</span><span class="p">;</span>
  <span class="n">refarg</span> <span class="o">=</span> <span class="n">refarg</span> <span class="o">+</span> <span class="mi">100</span><span class="p">;</span>
  <span class="n">writeln</span><span class="p">(</span> <span class="s">"Inside After: "</span><span class="p">,</span> <span class="p">(</span><span class="n">inarg</span><span class="p">,</span> <span class="n">outarg</span><span class="p">,</span> <span class="n">inoutarg</span><span class="p">,</span> <span class="n">refarg</span><span class="p">)</span> <span class="p">);</span>
<span class="p">}</span>

<span class="n">var</span> <span class="n">inVar</span><span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">var</span> <span class="n">outVar</span><span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">var</span> <span class="n">inoutVar</span><span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">var</span> <span class="n">refVar</span><span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="n">writeln</span><span class="p">(</span> <span class="s">"Outside Before: "</span><span class="p">,</span> <span class="p">(</span><span class="n">inVar</span><span class="p">,</span> <span class="n">outVar</span><span class="p">,</span> <span class="n">inoutVar</span><span class="p">,</span> <span class="n">refVar</span><span class="p">)</span> <span class="p">);</span>
<span class="n">intentsProc</span><span class="p">(</span> <span class="n">inVar</span><span class="p">,</span> <span class="n">outVar</span><span class="p">,</span> <span class="n">inoutVar</span><span class="p">,</span> <span class="n">refVar</span> <span class="p">);</span>
<span class="n">writeln</span><span class="p">(</span> <span class="s">"Outside After: "</span><span class="p">,</span> <span class="p">(</span><span class="n">inVar</span><span class="p">,</span> <span class="n">outVar</span><span class="p">,</span> <span class="n">inoutVar</span><span class="p">,</span> <span class="n">refVar</span><span class="p">)</span> <span class="p">);</span>

<span class="c1">// Similarly we can define intents on the return type
// refElement returns a reference to an element of array
</span><span class="n">proc</span> <span class="n">refElement</span><span class="p">(</span> <span class="n">array</span> <span class="o">:</span> <span class="p">[</span><span class="o">?</span><span class="n">D</span><span class="p">]</span> <span class="o">?</span><span class="n">T</span><span class="p">,</span> <span class="n">idx</span> <span class="p">)</span> <span class="n">ref</span> <span class="o">:</span> <span class="n">T</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">array</span><span class="p">[</span> <span class="n">idx</span> <span class="p">];</span> <span class="c1">// returns a reference to
</span><span class="p">}</span>

<span class="n">var</span> <span class="n">myChangingArray</span> <span class="o">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">..</span><span class="mi">5</span><span class="p">]</span> <span class="kt">int</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">];</span>
<span class="n">writeln</span><span class="p">(</span> <span class="n">myChangingArray</span> <span class="p">);</span>
<span class="c1">// Store reference to element in ref variable
</span><span class="n">ref</span> <span class="n">refToElem</span> <span class="o">=</span> <span class="n">refElement</span><span class="p">(</span> <span class="n">myChangingArray</span><span class="p">,</span> <span class="mi">5</span> <span class="p">);</span>
<span class="n">writeln</span><span class="p">(</span> <span class="n">refToElem</span> <span class="p">);</span>
<span class="n">refToElem</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span> <span class="c1">// modify reference which modifies actual value in array
</span><span class="n">writeln</span><span class="p">(</span> <span class="n">refToElem</span> <span class="p">);</span>
<span class="n">writeln</span><span class="p">(</span> <span class="n">myChangingArray</span> <span class="p">);</span>
<span class="c1">// This makes more practical sense for class methods where references to
// elements in a data-structure are returned via a method or iterator
</span>
<span class="c1">// We can query the type of arguments to generic procedures
// Here we define a procedure that takes two arguments of
// the same type, yet we don't define what that type is.
</span><span class="n">proc</span> <span class="n">genericProc</span><span class="p">(</span> <span class="n">arg1</span> <span class="o">:</span> <span class="o">?</span><span class="n">valueType</span><span class="p">,</span> <span class="n">arg2</span> <span class="o">:</span> <span class="n">valueType</span> <span class="p">)</span><span class="o">:</span> <span class="kt">void</span> <span class="p">{</span>
  <span class="n">select</span><span class="p">(</span> <span class="n">valueType</span> <span class="p">){</span>
    <span class="n">when</span> <span class="kt">int</span> <span class="k">do</span> <span class="n">writeln</span><span class="p">(</span> <span class="n">arg1</span><span class="p">,</span> <span class="s">" and "</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="s">" are ints"</span> <span class="p">);</span>
    <span class="n">when</span> <span class="n">real</span> <span class="k">do</span> <span class="n">writeln</span><span class="p">(</span> <span class="n">arg1</span><span class="p">,</span> <span class="s">" and "</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="s">" are reals"</span> <span class="p">);</span>
    <span class="n">otherwise</span> <span class="n">writeln</span><span class="p">(</span> <span class="n">arg1</span><span class="p">,</span> <span class="s">" and "</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="s">" are somethings!"</span> <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">genericProc</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>
<span class="n">genericProc</span><span class="p">(</span> <span class="mi">1</span><span class="p">.</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">.</span><span class="mi">3</span> <span class="p">);</span>
<span class="n">genericProc</span><span class="p">(</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="o">+</span><span class="mi">2</span><span class="p">.</span><span class="mi">0</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">.</span><span class="mi">0</span><span class="o">+</span><span class="mi">4</span><span class="p">.</span><span class="mi">0</span><span class="n">i</span> <span class="p">);</span>

<span class="c1">// We can also enforce a form of polymorphism with the 'where' clause
// This allows the compiler to decide which function to use.
// Note: that means that all information needs to be known at compile-time.
// The param modifier on the arg is used to enforce this constraint.
</span><span class="n">proc</span> <span class="nf">whereProc</span><span class="p">(</span> <span class="n">param</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">int</span> <span class="p">)</span><span class="o">:</span> <span class="kt">void</span>
 <span class="n">where</span> <span class="p">(</span> <span class="n">N</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
  <span class="n">writeln</span><span class="p">(</span> <span class="s">"N is greater than 0"</span> <span class="p">);</span>
<span class="p">}</span>

<span class="n">proc</span> <span class="nf">whereProc</span><span class="p">(</span> <span class="n">param</span> <span class="n">N</span> <span class="o">:</span> <span class="kt">int</span> <span class="p">)</span><span class="o">:</span> <span class="kt">void</span>
 <span class="n">where</span> <span class="p">(</span> <span class="n">N</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
  <span class="n">writeln</span><span class="p">(</span> <span class="s">"N is less than 0"</span> <span class="p">);</span>
<span class="p">}</span>

<span class="n">whereProc</span><span class="p">(</span> <span class="mi">10</span> <span class="p">);</span>
<span class="n">whereProc</span><span class="p">(</span> <span class="o">-</span><span class="mi">1</span> <span class="p">);</span>
<span class="c1">// whereProc( 0 ) would result in a compiler error because there
// are no functions that satisfy the where clause's condition.
// We could have defined a whereProc without a where clause that would then have
// served as a catch all for all the other cases (of which there is only one).
</span>
<span class="c1">// Operator definitions are through procedures as well.
// We can define the unary operators:
// + - ! ~
// and the binary operators:
// + - * / % ** == &lt;= &gt;= &lt; &gt; &lt;&lt; &gt;&gt; &amp; | ˆ by
// += -= *= /= %= **= &amp;= |= ˆ= &lt;&lt;= &gt;&gt;= &lt;=&gt;
</span>
<span class="c1">// Boolean exclusive or operator
</span><span class="n">proc</span> <span class="o">^</span><span class="p">(</span> <span class="n">left</span> <span class="o">:</span> <span class="n">bool</span><span class="p">,</span> <span class="n">right</span> <span class="o">:</span> <span class="n">bool</span> <span class="p">)</span><span class="o">:</span> <span class="n">bool</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">left</span> <span class="o">||</span> <span class="n">right</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span> <span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="p">);</span>
<span class="p">}</span>

<span class="n">writeln</span><span class="p">(</span> <span class="nb">true</span>  <span class="o">^</span> <span class="nb">true</span>  <span class="p">);</span>
<span class="n">writeln</span><span class="p">(</span> <span class="nb">false</span> <span class="o">^</span> <span class="nb">true</span>  <span class="p">);</span>
<span class="n">writeln</span><span class="p">(</span> <span class="nb">true</span>  <span class="o">^</span> <span class="nb">false</span> <span class="p">);</span>
<span class="n">writeln</span><span class="p">(</span> <span class="nb">false</span> <span class="o">^</span> <span class="nb">false</span> <span class="p">);</span>

<span class="c1">// Define a * operator on any two types that returns a tuple of those types
</span><span class="n">proc</span> <span class="o">*</span><span class="p">(</span> <span class="n">left</span> <span class="o">:</span> <span class="o">?</span><span class="n">ltype</span><span class="p">,</span> <span class="n">right</span> <span class="o">:</span> <span class="o">?</span><span class="n">rtype</span><span class="p">)</span><span class="o">:</span> <span class="p">(</span> <span class="n">ltype</span><span class="p">,</span> <span class="n">rtype</span> <span class="p">){</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="p">);</span>
<span class="p">}</span>

<span class="n">writeln</span><span class="p">(</span> <span class="mi">1</span> <span class="o">*</span> <span class="s">"a"</span> <span class="p">);</span> <span class="c1">// Uses our * operator
</span><span class="n">writeln</span><span class="p">(</span> <span class="mi">1</span> <span class="o">*</span> <span class="mi">2</span> <span class="p">);</span>   <span class="c1">// Uses the default * operator
</span>
<span class="cm">/*
Note: You could break everything if you get careless with your overloads.
This here will break everything. Don't do it.
proc +( left: int, right: int ): int{
  return left - right;
}
*/</span>

<span class="c1">// Iterators are a sisters to the procedure, and almost
// everything about procedures also applies to iterators
// However, instead of returning a single value,
// iterators yield many values to a loop.
// This is useful when a complicated set or order of iterations is needed but
// allows the code defining the iterations to be separate from the loop body.
</span><span class="n">iter</span> <span class="n">oddsThenEvens</span><span class="p">(</span> <span class="n">N</span><span class="o">:</span> <span class="kt">int</span> <span class="p">)</span><span class="o">:</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">1</span><span class="p">..</span><span class="n">N</span> <span class="n">by</span> <span class="mi">2</span> <span class="k">do</span>
    <span class="n">yield</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// yield values instead of returning.
</span>  <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">2</span><span class="p">..</span><span class="n">N</span> <span class="n">by</span> <span class="mi">2</span> <span class="k">do</span>
    <span class="n">yield</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="n">oddsThenEvens</span><span class="p">(</span> <span class="mi">10</span> <span class="p">)</span> <span class="k">do</span> <span class="n">write</span><span class="p">(</span> <span class="n">i</span><span class="p">,</span> <span class="s">", "</span> <span class="p">);</span>
<span class="n">writeln</span><span class="p">(</span> <span class="p">);</span>

<span class="c1">// Iterators can also yield conditionally, the result of which can be nothing
</span><span class="n">iter</span> <span class="nf">absolutelyNothing</span><span class="p">(</span> <span class="n">N</span> <span class="p">)</span><span class="o">:</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">1</span><span class="p">..</span><span class="n">N</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">N</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="p">)</span> <span class="p">{</span> <span class="c1">// Always false
</span>      <span class="n">yield</span> <span class="n">i</span><span class="p">;</span>     <span class="c1">// Yield statement never happens
</span>    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="n">absolutelyNothing</span><span class="p">(</span> <span class="mi">10</span> <span class="p">){</span>
  <span class="n">writeln</span><span class="p">(</span> <span class="s">"Woa there! absolutelyNothing yielded "</span><span class="p">,</span> <span class="n">i</span> <span class="p">);</span>
<span class="p">}</span>

<span class="c1">// We can zipper together two or more iterators (who have the same number
// of iterations)  using zip() to create a single zipped iterator, where each
// iteration of the zipped iterator yields a tuple of one value yielded
// from each iterator.
</span>                                 <span class="c1">// Ranges have implicit iterators
</span><span class="k">for</span> <span class="p">(</span><span class="n">positive</span><span class="p">,</span> <span class="n">negative</span><span class="p">)</span> <span class="n">in</span> <span class="n">zip</span><span class="p">(</span> <span class="mi">1</span><span class="p">..</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">..</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">writeln</span><span class="p">(</span> <span class="p">(</span><span class="n">positive</span><span class="p">,</span> <span class="n">negative</span><span class="p">)</span> <span class="p">);</span>

<span class="c1">// Zipper iteration is quite important in the assignment of arrays,
// slices of arrays, and array/loop expressions.
</span><span class="n">var</span> <span class="n">fromThatArray</span> <span class="o">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">..</span><span class="err">#</span><span class="mi">5</span><span class="p">]</span> <span class="kt">int</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">];</span>
<span class="n">var</span> <span class="n">toThisArray</span> <span class="o">:</span> <span class="p">[</span><span class="mi">100</span><span class="p">..</span><span class="err">#</span><span class="mi">5</span><span class="p">]</span> <span class="kt">int</span><span class="p">;</span>

<span class="c1">// The operation
</span><span class="n">toThisArray</span> <span class="o">=</span> <span class="n">fromThatArray</span><span class="p">;</span>
<span class="c1">// is produced through
</span><span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="n">in</span> <span class="n">zip</span><span class="p">(</span> <span class="n">toThisArray</span><span class="p">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">fromThatArray</span><span class="p">.</span><span class="n">domain</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">toThisArray</span><span class="p">[</span> <span class="n">i</span> <span class="p">]</span> <span class="o">=</span> <span class="n">fromThatArray</span><span class="p">[</span> <span class="n">j</span> <span class="p">];</span>
<span class="p">}</span>

<span class="n">toThisArray</span> <span class="o">=</span> <span class="p">[</span> <span class="n">j</span> <span class="n">in</span> <span class="o">-</span><span class="mi">100</span><span class="p">..</span><span class="err">#</span><span class="mi">5</span> <span class="p">]</span> <span class="n">j</span><span class="p">;</span>
<span class="n">writeln</span><span class="p">(</span> <span class="n">toThisArray</span> <span class="p">);</span>
<span class="c1">// is produced through
</span><span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="n">in</span> <span class="n">zip</span><span class="p">(</span> <span class="n">toThisArray</span><span class="p">.</span><span class="n">domain</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">..</span><span class="err">#</span><span class="mi">5</span> <span class="p">){</span>
  <span class="n">toThisArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">writeln</span><span class="p">(</span> <span class="n">toThisArray</span> <span class="p">);</span>

<span class="c1">// This is all very important in understanding why the statement
// var iterArray : [1..10] int = [ i in 1..10 ] if ( i % 2 == 1 ) then j;
// exhibits a runtime error.
// Even though the domain of the array and the loop-expression are
// the same size, the body of the expression can be thought of as an iterator.
// Because iterators can yield nothing, that iterator yields a different number
// of things than the domain of the array or loop, which is not allowed.
</span>
<span class="c1">// Classes are similar to those in C++ and Java.
// They currently lack privatization
</span><span class="n">class</span> <span class="n">MyClass</span> <span class="p">{</span>
  <span class="c1">// Member variables
</span>  <span class="n">var</span> <span class="n">memberInt</span> <span class="o">:</span> <span class="kt">int</span><span class="p">;</span>
  <span class="n">var</span> <span class="n">memberBool</span> <span class="o">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

  <span class="c1">// Classes have default constructors that don't need to be coded (see below)
</span>  <span class="c1">// Our explicitly defined constructor
</span>  <span class="n">proc</span> <span class="n">MyClass</span><span class="p">(</span> <span class="n">val</span> <span class="o">:</span> <span class="n">real</span> <span class="p">){</span>
    <span class="n">this</span><span class="p">.</span><span class="n">memberInt</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span> <span class="n">val</span> <span class="p">)</span><span class="o">:</span> <span class="kt">int</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Our explicitly defined destructor
</span>  <span class="n">proc</span> <span class="o">~</span><span class="n">MyClass</span><span class="p">(</span> <span class="p">){</span>
    <span class="n">writeln</span><span class="p">(</span> <span class="s">"MyClass Destructor called "</span><span class="p">,</span> <span class="p">(</span><span class="n">this</span><span class="p">.</span><span class="n">memberInt</span><span class="p">,</span> <span class="n">this</span><span class="p">.</span><span class="n">memberBool</span><span class="p">)</span> <span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Class methods
</span>  <span class="n">proc</span> <span class="n">setMemberInt</span><span class="p">(</span> <span class="n">val</span><span class="o">:</span> <span class="kt">int</span> <span class="p">){</span>
    <span class="n">this</span><span class="p">.</span><span class="n">memberInt</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">proc</span> <span class="n">setMemberBool</span><span class="p">(</span> <span class="n">val</span><span class="o">:</span> <span class="n">bool</span> <span class="p">){</span>
    <span class="n">this</span><span class="p">.</span><span class="n">memberBool</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">proc</span> <span class="n">getMemberInt</span><span class="p">(</span> <span class="p">)</span><span class="o">:</span> <span class="kt">int</span><span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="p">.</span><span class="n">memberInt</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">proc</span> <span class="n">getMemberBool</span><span class="p">(</span> <span class="p">)</span><span class="o">:</span> <span class="n">bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="p">.</span><span class="n">memberBool</span><span class="p">;</span>
  <span class="p">}</span>

<span class="p">}</span>

<span class="c1">// Construct using default constructor, using default values
</span><span class="n">var</span> <span class="n">myObject</span> <span class="o">=</span> <span class="n">new</span> <span class="n">MyClass</span><span class="p">(</span> <span class="mi">10</span> <span class="p">);</span>
    <span class="n">myObject</span> <span class="o">=</span> <span class="n">new</span> <span class="n">MyClass</span><span class="p">(</span> <span class="n">memberInt</span> <span class="o">=</span> <span class="mi">10</span> <span class="p">);</span> <span class="c1">// Equivalent
</span><span class="n">writeln</span><span class="p">(</span> <span class="n">myObject</span><span class="p">.</span><span class="n">getMemberInt</span><span class="p">(</span> <span class="p">)</span> <span class="p">);</span>
<span class="c1">// ... using our values
</span><span class="n">var</span> <span class="n">myDiffObject</span> <span class="o">=</span> <span class="n">new</span> <span class="n">MyClass</span><span class="p">(</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">true</span> <span class="p">);</span>
    <span class="n">myDiffObject</span> <span class="o">=</span> <span class="n">new</span> <span class="n">MyClass</span><span class="p">(</span> <span class="n">memberInt</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                                <span class="n">memberBool</span> <span class="o">=</span> <span class="nb">true</span> <span class="p">);</span> <span class="c1">// Equivalent
</span><span class="n">writeln</span><span class="p">(</span> <span class="n">myDiffObject</span> <span class="p">);</span>

<span class="c1">// Construct using written constructor
</span><span class="n">var</span> <span class="n">myOtherObject</span> <span class="o">=</span> <span class="n">new</span> <span class="n">MyClass</span><span class="p">(</span> <span class="mi">1</span><span class="p">.</span><span class="mi">95</span> <span class="p">);</span>
    <span class="n">myOtherObject</span> <span class="o">=</span> <span class="n">new</span> <span class="n">MyClass</span><span class="p">(</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">95</span> <span class="p">);</span> <span class="c1">// Equivalent
</span><span class="n">writeln</span><span class="p">(</span> <span class="n">myOtherObject</span><span class="p">.</span><span class="n">getMemberInt</span><span class="p">(</span> <span class="p">)</span> <span class="p">);</span>

<span class="c1">// We can define an operator on our class as well but
// the definition has to be outside the class definition
</span><span class="n">proc</span> <span class="o">+</span><span class="p">(</span> <span class="n">A</span> <span class="o">:</span> <span class="n">MyClass</span><span class="p">,</span> <span class="n">B</span> <span class="o">:</span> <span class="n">MyClass</span><span class="p">)</span> <span class="o">:</span> <span class="n">MyClass</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">new</span> <span class="n">MyClass</span><span class="p">(</span> <span class="n">memberInt</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">getMemberInt</span><span class="p">(</span> <span class="p">)</span> <span class="o">+</span> <span class="n">B</span><span class="p">.</span><span class="n">getMemberInt</span><span class="p">(</span> <span class="p">),</span>
                      <span class="n">memberBool</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">getMemberBool</span><span class="p">(</span> <span class="p">)</span> <span class="o">||</span> <span class="n">B</span><span class="p">.</span><span class="n">getMemberBool</span><span class="p">(</span> <span class="p">)</span> <span class="p">);</span>
<span class="p">}</span>

<span class="n">var</span> <span class="n">plusObject</span> <span class="o">=</span> <span class="n">myObject</span> <span class="o">+</span> <span class="n">myDiffObject</span><span class="p">;</span>
<span class="n">writeln</span><span class="p">(</span> <span class="n">plusObject</span> <span class="p">);</span>

<span class="c1">// Destruction
</span><span class="n">delete</span> <span class="n">myObject</span><span class="p">;</span>
<span class="n">delete</span> <span class="n">myDiffObject</span><span class="p">;</span>
<span class="n">delete</span> <span class="n">myOtherObject</span><span class="p">;</span>
<span class="n">delete</span> <span class="n">plusObject</span><span class="p">;</span>

<span class="c1">// Classes can inherit from one or more parent classes
</span><span class="n">class</span> <span class="n">MyChildClass</span> <span class="o">:</span> <span class="n">MyClass</span> <span class="p">{</span>
  <span class="n">var</span> <span class="n">memberComplex</span><span class="o">:</span> <span class="n">complex</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Generic Classes
</span><span class="n">class</span> <span class="n">GenericClass</span> <span class="p">{</span>
  <span class="n">type</span> <span class="n">classType</span><span class="p">;</span>
  <span class="n">var</span> <span class="n">classDomain</span><span class="o">:</span> <span class="n">domain</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">var</span> <span class="n">classArray</span><span class="o">:</span> <span class="p">[</span><span class="n">classDomain</span><span class="p">]</span> <span class="n">classType</span><span class="p">;</span>

  <span class="c1">// Explicit constructor
</span>  <span class="n">proc</span> <span class="n">GenericClass</span><span class="p">(</span> <span class="n">type</span> <span class="n">classType</span><span class="p">,</span> <span class="n">elements</span> <span class="o">:</span> <span class="kt">int</span> <span class="p">){</span>
    <span class="n">this</span><span class="p">.</span><span class="n">classDomain</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">..</span><span class="err">#</span><span class="n">elements</span><span class="p">};</span>
  <span class="p">}</span>

  <span class="c1">// Copy constructor
</span>  <span class="c1">// Note: We still have to put the type as an argument, but we can
</span>  <span class="c1">// default to the type of the other object using the query (?) operator
</span>  <span class="c1">// Further, we can take advantage of this to allow our copy constructor
</span>  <span class="c1">// to copy classes of different types and cast on the fly
</span>  <span class="n">proc</span> <span class="n">GenericClass</span><span class="p">(</span> <span class="n">other</span> <span class="o">:</span> <span class="n">GenericClass</span><span class="p">(</span><span class="o">?</span><span class="n">otherType</span><span class="p">),</span>
                     <span class="n">type</span> <span class="n">classType</span> <span class="o">=</span> <span class="n">otherType</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">this</span><span class="p">.</span><span class="n">classDomain</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">classDomain</span><span class="p">;</span>
    <span class="c1">// Copy and cast
</span>    <span class="k">for</span> <span class="n">idx</span> <span class="n">in</span> <span class="n">this</span><span class="p">.</span><span class="n">classDomain</span> <span class="k">do</span> <span class="n">this</span><span class="p">[</span> <span class="n">idx</span> <span class="p">]</span> <span class="o">=</span> <span class="n">other</span><span class="p">[</span> <span class="n">idx</span> <span class="p">]</span> <span class="o">:</span> <span class="n">classType</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Define bracket notation on a GenericClass
</span>  <span class="c1">// object so it can behave like a normal array
</span>  <span class="c1">// i.e. objVar[ i ] or objVar( i )
</span>  <span class="n">proc</span> <span class="n">this</span><span class="p">(</span> <span class="n">i</span> <span class="o">:</span> <span class="kt">int</span> <span class="p">)</span> <span class="n">ref</span> <span class="o">:</span> <span class="n">classType</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="p">.</span><span class="n">classArray</span><span class="p">[</span> <span class="n">i</span> <span class="p">];</span>
  <span class="p">}</span>

  <span class="c1">// Define an implicit iterator for the class
</span>  <span class="c1">// to yield values from the array to a loop
</span>  <span class="c1">// i.e. for i in objVar do ....
</span>  <span class="n">iter</span> <span class="n">these</span><span class="p">(</span> <span class="p">)</span> <span class="n">ref</span> <span class="o">:</span> <span class="n">classType</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="n">this</span><span class="p">.</span><span class="n">classDomain</span> <span class="k">do</span>
      <span class="n">yield</span> <span class="n">this</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">}</span>

<span class="p">}</span>

<span class="n">var</span> <span class="n">realList</span> <span class="o">=</span> <span class="n">new</span> <span class="n">GenericClass</span><span class="p">(</span> <span class="n">real</span><span class="p">,</span> <span class="mi">10</span> <span class="p">);</span>
<span class="c1">// We can assign to the member array of the object using the bracket
// notation that we defined ( proc this( i: int ){ ... }  )
</span><span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="n">realList</span><span class="p">.</span><span class="n">classDomain</span> <span class="k">do</span> <span class="n">realList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
<span class="c1">// We can iterate over the values in our list with the iterator
// we defined ( iter these( ){ ... } )
</span><span class="k">for</span> <span class="n">value</span> <span class="n">in</span> <span class="n">realList</span> <span class="k">do</span> <span class="n">write</span><span class="p">(</span> <span class="n">value</span><span class="p">,</span> <span class="s">", "</span> <span class="p">);</span>
<span class="n">writeln</span><span class="p">(</span> <span class="p">);</span>

<span class="c1">// Make a copy of realList using the copy constructor
</span><span class="n">var</span> <span class="n">copyList</span> <span class="o">=</span> <span class="n">new</span> <span class="n">GenericClass</span><span class="p">(</span> <span class="n">realList</span> <span class="p">);</span>
<span class="k">for</span> <span class="n">value</span> <span class="n">in</span> <span class="n">copyList</span> <span class="k">do</span> <span class="n">write</span><span class="p">(</span> <span class="n">value</span><span class="p">,</span> <span class="s">", "</span> <span class="p">);</span>
<span class="n">writeln</span><span class="p">(</span> <span class="p">);</span>

<span class="c1">// Make a copy of realList and change the type, also using the copy constructor
</span><span class="n">var</span> <span class="n">copyNewTypeList</span> <span class="o">=</span> <span class="n">new</span> <span class="n">GenericClass</span><span class="p">(</span> <span class="n">realList</span><span class="p">,</span> <span class="kt">int</span> <span class="p">);</span>
<span class="k">for</span> <span class="n">value</span> <span class="n">in</span> <span class="n">copyNewTypeList</span> <span class="k">do</span> <span class="n">write</span><span class="p">(</span> <span class="n">value</span><span class="p">,</span> <span class="s">", "</span> <span class="p">);</span>
<span class="n">writeln</span><span class="p">(</span> <span class="p">);</span>

<span class="c1">// Modules are Chapel's way of managing name spaces.
// The files containing these modules do not need to be named after the modules
// (as in Java), but files implicitly name modules.
// In this case, this file implicitly names the 'learnchapel' module
</span>
<span class="n">module</span> <span class="n">OurModule</span> <span class="p">{</span>
  <span class="c1">// We can use modules inside of other modules.
</span>  <span class="n">use</span> <span class="n">Time</span><span class="p">;</span> <span class="c1">// Time is one of the standard modules.
</span>
  <span class="c1">// We'll use this procedure in the parallelism section.
</span>  <span class="n">proc</span> <span class="n">countdown</span><span class="p">(</span> <span class="n">seconds</span><span class="o">:</span> <span class="kt">int</span> <span class="p">){</span>
    <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">1</span><span class="p">..</span><span class="n">seconds</span> <span class="n">by</span> <span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
      <span class="n">writeln</span><span class="p">(</span> <span class="n">i</span> <span class="p">);</span>
      <span class="n">sleep</span><span class="p">(</span> <span class="mi">1</span> <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Submodules of OurModule
</span>  <span class="c1">// It is possible to create arbitrarily deep module nests.
</span>  <span class="n">module</span> <span class="n">ChildModule</span> <span class="p">{</span>
    <span class="n">proc</span> <span class="n">foo</span><span class="p">(){</span>
      <span class="n">writeln</span><span class="p">(</span> <span class="s">"ChildModule.foo()"</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">module</span> <span class="n">SiblingModule</span> <span class="p">{</span>
    <span class="n">proc</span> <span class="n">foo</span><span class="p">(){</span>
      <span class="n">writeln</span><span class="p">(</span> <span class="s">"SiblingModule.foo()"</span> <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span> <span class="c1">// end OurModule
</span>
<span class="c1">// Using OurModule also uses all the modules it uses.
// Since OurModule uses Time, we also use time.
</span><span class="n">use</span> <span class="n">OurModule</span><span class="p">;</span>

<span class="c1">// At this point we have not used ChildModule or SiblingModule so their symbols
// (i.e. foo ) are not available to us.
// However, the module names are, and we can explicitly call foo() through them.
</span><span class="n">SiblingModule</span><span class="p">.</span><span class="n">foo</span><span class="p">();</span>         <span class="c1">// Calls SiblingModule.foo()
</span>
<span class="c1">// Super explicit naming.
</span><span class="n">OurModule</span><span class="p">.</span><span class="n">ChildModule</span><span class="p">.</span><span class="n">foo</span><span class="p">();</span> <span class="c1">// Calls ChildModule.foo()
</span>
<span class="n">use</span> <span class="n">ChildModule</span><span class="p">;</span>
<span class="n">foo</span><span class="p">();</span>   <span class="c1">// Less explicit call on ChildModule.foo()
</span>
<span class="c1">// We can declare a main procedure
// Note: all the code above main still gets executed.
</span><span class="n">proc</span> <span class="n">main</span><span class="p">(){</span>

  <span class="c1">// Parallelism
</span>  <span class="c1">// In other languages, parallelism is typically done with
</span>  <span class="c1">// complicated libraries and strange class structure hierarchies.
</span>  <span class="c1">// Chapel has it baked right into the language.
</span>
  <span class="c1">// A begin statement will spin the body of that statement off
</span>  <span class="c1">// into one new task.
</span>  <span class="c1">// A sync statement will ensure that the progress of the main
</span>  <span class="c1">// task will not progress until the children have synced back up.
</span>  <span class="n">sync</span> <span class="p">{</span>
    <span class="n">begin</span> <span class="p">{</span> <span class="c1">// Start of new task's body
</span>      <span class="n">var</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">1</span><span class="p">..</span><span class="mi">1000</span> <span class="k">do</span> <span class="n">a</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">writeln</span><span class="p">(</span> <span class="s">"Done: "</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="p">}</span> <span class="c1">// End of new tasks body
</span>    <span class="n">writeln</span><span class="p">(</span> <span class="s">"spun off a task!"</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">writeln</span><span class="p">(</span> <span class="s">"Back together"</span> <span class="p">);</span>

  <span class="n">proc</span> <span class="n">printFibb</span><span class="p">(</span> <span class="n">n</span><span class="o">:</span> <span class="kt">int</span> <span class="p">){</span>
    <span class="n">writeln</span><span class="p">(</span> <span class="s">"fibonacci("</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="s">") = "</span><span class="p">,</span> <span class="n">fibonacci</span><span class="p">(</span> <span class="n">n</span> <span class="p">)</span> <span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// A cobegin statement will spin each statement of the body into one new task
</span>  <span class="n">cobegin</span> <span class="p">{</span>
    <span class="n">printFibb</span><span class="p">(</span> <span class="mi">20</span> <span class="p">);</span> <span class="c1">// new task
</span>    <span class="n">printFibb</span><span class="p">(</span> <span class="mi">10</span> <span class="p">);</span> <span class="c1">// new task
</span>    <span class="n">printFibb</span><span class="p">(</span> <span class="mi">5</span> <span class="p">);</span>  <span class="c1">// new task
</span>    <span class="p">{</span>
      <span class="c1">// This is a nested statement body and thus is a single statement
</span>      <span class="c1">// to the parent statement and is executed by a single task
</span>      <span class="n">writeln</span><span class="p">(</span> <span class="s">"this gets"</span> <span class="p">);</span>
      <span class="n">writeln</span><span class="p">(</span> <span class="s">"executed as"</span> <span class="p">);</span>
      <span class="n">writeln</span><span class="p">(</span> <span class="s">"a whole"</span> <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">// Notice here that the prints from each statement may happen in any order.
</span>
  <span class="c1">// Coforall loop will create a new task for EACH iteration
</span>  <span class="n">var</span> <span class="n">num_tasks</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// Number of tasks we want
</span>  <span class="n">coforall</span> <span class="n">taskID</span> <span class="n">in</span> <span class="mi">1</span><span class="p">..</span><span class="err">#</span><span class="n">num_tasks</span> <span class="p">{</span>
    <span class="n">writeln</span><span class="p">(</span> <span class="s">"Hello from task# "</span><span class="p">,</span> <span class="n">taskID</span> <span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// Again we see that prints happen in any order.
</span>  <span class="c1">// NOTE! coforall should be used only for creating tasks!
</span>  <span class="c1">// Using it to iterating over a structure is very a bad idea!
</span>
  <span class="c1">// forall loops are another parallel loop, but only create a smaller number
</span>  <span class="c1">// of tasks, specifically --dataParTasksPerLocale=number of task
</span>  <span class="n">forall</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">1</span><span class="p">..</span><span class="mi">100</span> <span class="p">{</span>
    <span class="n">write</span><span class="p">(</span> <span class="n">i</span><span class="p">,</span> <span class="s">", "</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">writeln</span><span class="p">(</span> <span class="p">);</span>
  <span class="c1">// Here we see that there are sections that are in order, followed by
</span>  <span class="c1">// a section that would not follow ( e.g. 1, 2, 3, 7, 8, 9, 4, 5, 6, ).
</span>  <span class="c1">// This is because each task is taking on a chunk of the range 1..10
</span>  <span class="c1">// (1..3, 4..6, or 7..9) doing that chunk serially, but each task happens
</span>  <span class="c1">// in parallel.
</span>  <span class="c1">// Your results may depend on your machine and configuration
</span>
  <span class="c1">// For both the forall and coforall loops, the execution of the
</span>  <span class="c1">// parent task will not continue until all the children sync up.
</span>
  <span class="c1">// forall loops are particularly useful for parallel iteration over arrays.
</span>  <span class="c1">// Lets run an experiment to see how much faster a parallel loop is
</span>  <span class="n">use</span> <span class="n">Time</span><span class="p">;</span> <span class="c1">// Import the Time module to use Timer objects
</span>  <span class="n">var</span> <span class="n">timer</span><span class="o">:</span> <span class="n">Timer</span><span class="p">;</span>
  <span class="n">var</span> <span class="n">myBigArray</span><span class="o">:</span> <span class="p">[{</span><span class="mi">1</span><span class="p">..</span><span class="mi">4000</span><span class="p">,</span><span class="mi">1</span><span class="p">..</span><span class="mi">4000</span><span class="p">}]</span> <span class="n">real</span><span class="p">;</span> <span class="c1">// Large array we will write into
</span>
  <span class="c1">// Serial Experiment
</span>  <span class="n">timer</span><span class="p">.</span><span class="n">start</span><span class="p">(</span> <span class="p">);</span> <span class="c1">// Start timer
</span>  <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="n">in</span> <span class="n">myBigArray</span><span class="p">.</span><span class="n">domain</span> <span class="p">{</span> <span class="c1">// Serial iteration
</span>    <span class="n">myBigArray</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">real</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">y</span><span class="o">:</span><span class="n">real</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">timer</span><span class="p">.</span><span class="n">stop</span><span class="p">(</span> <span class="p">);</span> <span class="c1">// Stop timer
</span>  <span class="n">writeln</span><span class="p">(</span> <span class="s">"Serial: "</span><span class="p">,</span> <span class="n">timer</span><span class="p">.</span><span class="n">elapsed</span><span class="p">(</span> <span class="p">)</span> <span class="p">);</span> <span class="c1">// Print elapsed time
</span>  <span class="n">timer</span><span class="p">.</span><span class="n">clear</span><span class="p">(</span> <span class="p">);</span> <span class="c1">// Clear timer for parallel loop
</span>
  <span class="c1">// Parallel Experiment
</span>  <span class="n">timer</span><span class="p">.</span><span class="n">start</span><span class="p">(</span> <span class="p">);</span> <span class="c1">// start timer
</span>  <span class="n">forall</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="n">in</span> <span class="n">myBigArray</span><span class="p">.</span><span class="n">domain</span> <span class="p">{</span> <span class="c1">// Parallel iteration
</span>    <span class="n">myBigArray</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">real</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">y</span><span class="o">:</span><span class="n">real</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">timer</span><span class="p">.</span><span class="n">stop</span><span class="p">(</span> <span class="p">);</span> <span class="c1">// Stop timer
</span>  <span class="n">writeln</span><span class="p">(</span> <span class="s">"Parallel: "</span><span class="p">,</span> <span class="n">timer</span><span class="p">.</span><span class="n">elapsed</span><span class="p">(</span> <span class="p">)</span> <span class="p">);</span> <span class="c1">// Print elapsed time
</span>  <span class="n">timer</span><span class="p">.</span><span class="n">clear</span><span class="p">(</span> <span class="p">);</span>
  <span class="c1">// You may have noticed that (depending on how many cores you have)
</span>  <span class="c1">// that the parallel loop went faster than the serial loop
</span>
  <span class="c1">// The bracket style loop-expression described
</span>  <span class="c1">// much earlier implicitly uses a forall loop.
</span>  <span class="p">[</span> <span class="n">val</span> <span class="n">in</span> <span class="n">myBigArray</span> <span class="p">]</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">val</span><span class="p">;</span> <span class="c1">// Parallel operation
</span>
  <span class="c1">// Atomic variables, common to many languages, are ones whose operations
</span>  <span class="c1">// occur uninterrupted. Multiple threads can both modify atomic variables
</span>  <span class="c1">// and can know that their values are safe.
</span>  <span class="c1">// Chapel atomic variables can be of type bool, int, uint, and real.
</span>  <span class="n">var</span> <span class="n">uranium</span><span class="o">:</span> <span class="n">atomic</span> <span class="kt">int</span><span class="p">;</span>
  <span class="n">uranium</span><span class="p">.</span><span class="n">write</span><span class="p">(</span> <span class="mi">238</span> <span class="p">);</span>      <span class="c1">// atomically write a variable
</span>  <span class="n">writeln</span><span class="p">(</span> <span class="n">uranium</span><span class="p">.</span><span class="n">read</span><span class="p">()</span> <span class="p">);</span> <span class="c1">// atomically read a variable
</span>
  <span class="c1">// operations are described as functions, you could define your own operators.
</span>  <span class="n">uranium</span><span class="p">.</span><span class="n">sub</span><span class="p">(</span> <span class="mi">3</span> <span class="p">);</span> <span class="c1">// atomically subtract a variable
</span>  <span class="n">writeln</span><span class="p">(</span> <span class="n">uranium</span><span class="p">.</span><span class="n">read</span><span class="p">()</span> <span class="p">);</span>

  <span class="n">var</span> <span class="n">replaceWith</span> <span class="o">=</span> <span class="mi">239</span><span class="p">;</span>
  <span class="n">var</span> <span class="n">was</span> <span class="o">=</span> <span class="n">uranium</span><span class="p">.</span><span class="n">exchange</span><span class="p">(</span> <span class="n">replaceWith</span> <span class="p">);</span>
  <span class="n">writeln</span><span class="p">(</span> <span class="s">"uranium was "</span><span class="p">,</span> <span class="n">was</span><span class="p">,</span> <span class="s">" but is now "</span><span class="p">,</span> <span class="n">replaceWith</span> <span class="p">);</span>

  <span class="n">var</span> <span class="n">isEqualTo</span> <span class="o">=</span> <span class="mi">235</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">uranium</span><span class="p">.</span><span class="n">compareExchange</span><span class="p">(</span> <span class="n">isEqualTo</span><span class="p">,</span> <span class="n">replaceWith</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">writeln</span><span class="p">(</span> <span class="s">"uranium was equal to "</span><span class="p">,</span> <span class="n">isEqualTo</span><span class="p">,</span>
             <span class="s">" so replaced value with "</span><span class="p">,</span> <span class="n">replaceWith</span> <span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">writeln</span><span class="p">(</span> <span class="s">"uranium was not equal to "</span><span class="p">,</span> <span class="n">isEqualTo</span><span class="p">,</span>
             <span class="s">" so value stays the same...  whatever it was"</span> <span class="p">);</span>
  <span class="p">}</span>

  <span class="n">sync</span> <span class="p">{</span>
    <span class="n">begin</span> <span class="p">{</span> <span class="c1">// Reader task
</span>      <span class="n">writeln</span><span class="p">(</span> <span class="s">"Reader: waiting for uranium to be "</span><span class="p">,</span> <span class="n">isEqualTo</span> <span class="p">);</span>
      <span class="n">uranium</span><span class="p">.</span><span class="n">waitFor</span><span class="p">(</span> <span class="n">isEqualTo</span> <span class="p">);</span>
      <span class="n">writeln</span><span class="p">(</span> <span class="s">"Reader: uranium was set (by someone) to "</span><span class="p">,</span> <span class="n">isEqualTo</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">begin</span> <span class="p">{</span> <span class="c1">// Writer task
</span>      <span class="n">writeln</span><span class="p">(</span> <span class="s">"Writer: will set uranium to the value "</span><span class="p">,</span> <span class="n">isEqualTo</span><span class="p">,</span> <span class="s">" in..."</span> <span class="p">);</span>
      <span class="n">countdown</span><span class="p">(</span> <span class="mi">3</span> <span class="p">);</span>
      <span class="n">uranium</span><span class="p">.</span><span class="n">write</span><span class="p">(</span> <span class="n">isEqualTo</span> <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// sync vars have two states: empty and full.
</span>  <span class="c1">// If you read an empty variable or write a full variable, you are waited
</span>  <span class="c1">// until the variable is full or empty again
</span>  <span class="n">var</span> <span class="n">someSyncVar</span><span class="err">$</span><span class="o">:</span> <span class="n">sync</span> <span class="kt">int</span><span class="p">;</span> <span class="c1">// varName$ is a convention not a law.
</span>  <span class="n">sync</span> <span class="p">{</span>
    <span class="n">begin</span> <span class="p">{</span> <span class="c1">// Reader task
</span>      <span class="n">writeln</span><span class="p">(</span> <span class="s">"Reader: waiting to read."</span> <span class="p">);</span>
      <span class="n">var</span> <span class="n">read_sync</span> <span class="o">=</span> <span class="n">someSyncVar</span><span class="err">$</span><span class="p">;</span>
      <span class="n">writeln</span><span class="p">(</span> <span class="s">"Reader: value is "</span><span class="p">,</span> <span class="n">read_sync</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">begin</span> <span class="p">{</span> <span class="c1">// Writer task
</span>      <span class="n">writeln</span><span class="p">(</span> <span class="s">"Writer: will write in..."</span> <span class="p">);</span>
      <span class="n">countdown</span><span class="p">(</span> <span class="mi">3</span> <span class="p">);</span>
      <span class="n">someSyncVar</span><span class="err">$</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// single vars can only be written once. A read on an unwritten single results
</span>  <span class="c1">// in a wait, but when the variable has a value it can be read indefinitely
</span>  <span class="n">var</span> <span class="n">someSingleVar</span><span class="err">$</span><span class="o">:</span> <span class="n">single</span> <span class="kt">int</span><span class="p">;</span> <span class="c1">// varName$ is a convention not a law.
</span>  <span class="n">sync</span> <span class="p">{</span>
    <span class="n">begin</span> <span class="p">{</span> <span class="c1">// Reader task
</span>      <span class="n">writeln</span><span class="p">(</span> <span class="s">"Reader: waiting to read."</span> <span class="p">);</span>
      <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">1</span><span class="p">..</span><span class="mi">5</span> <span class="p">{</span>
        <span class="n">var</span> <span class="n">read_single</span> <span class="o">=</span> <span class="n">someSingleVar</span><span class="err">$</span><span class="p">;</span>
        <span class="n">writeln</span><span class="p">(</span> <span class="s">"Reader: iteration "</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span><span class="s">", and the value is "</span><span class="p">,</span> <span class="n">read_single</span> <span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">begin</span> <span class="p">{</span> <span class="c1">// Writer task
</span>      <span class="n">writeln</span><span class="p">(</span> <span class="s">"Writer: will write in..."</span> <span class="p">);</span>
      <span class="n">countdown</span><span class="p">(</span> <span class="mi">3</span> <span class="p">);</span>
      <span class="n">someSingleVar</span><span class="err">$</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// first and only write ever.
</span>    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Heres an example of using atomics and a synch variable to create a
</span>  <span class="c1">// count-down mutex (also known as a multiplexer)
</span>  <span class="n">var</span> <span class="n">count</span><span class="o">:</span> <span class="n">atomic</span> <span class="kt">int</span><span class="p">;</span> <span class="c1">// our counter
</span>  <span class="n">var</span> <span class="n">lock</span><span class="err">$</span><span class="o">:</span> <span class="n">sync</span> <span class="n">bool</span><span class="p">;</span>   <span class="c1">// the mutex lock
</span>
  <span class="n">count</span><span class="p">.</span><span class="n">write</span><span class="p">(</span> <span class="mi">2</span> <span class="p">);</span>       <span class="c1">// Only let two tasks in at a time.
</span>  <span class="n">lock</span><span class="err">$</span><span class="p">.</span><span class="n">writeXF</span><span class="p">(</span> <span class="nb">true</span> <span class="p">);</span>  <span class="c1">// Set lock$ to full (unlocked)
</span>  <span class="c1">// Note: The value doesnt actually matter, just the state
</span>  <span class="c1">// (full:unlocked / empty:locked)
</span>  <span class="c1">// Also, writeXF() fills (F) the sync var regardless of its state (X)
</span>
  <span class="n">coforall</span> <span class="n">task</span> <span class="n">in</span> <span class="mi">1</span><span class="p">..</span><span class="err">#</span><span class="mi">5</span> <span class="p">{</span> <span class="c1">// Generate tasks
</span>    <span class="c1">// Create a barrier
</span>    <span class="k">do</span><span class="p">{</span>
      <span class="n">lock</span><span class="err">$</span><span class="p">;</span>                 <span class="c1">// Read lock$ (wait)
</span>    <span class="p">}</span><span class="k">while</span> <span class="p">(</span> <span class="n">count</span><span class="p">.</span><span class="n">read</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="p">);</span> <span class="c1">// Keep waiting until a spot opens up
</span>
    <span class="n">count</span><span class="p">.</span><span class="n">sub</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>          <span class="c1">// decrement the counter
</span>    <span class="n">lock</span><span class="err">$</span><span class="p">.</span><span class="n">writeXF</span><span class="p">(</span> <span class="nb">true</span> <span class="p">);</span> <span class="c1">// Set lock$ to full (signal)
</span>
    <span class="c1">// Actual 'work'
</span>    <span class="n">writeln</span><span class="p">(</span> <span class="s">"Task #"</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="s">" doing work."</span> <span class="p">);</span>
    <span class="n">sleep</span><span class="p">(</span> <span class="mi">2</span> <span class="p">);</span>

    <span class="n">count</span><span class="p">.</span><span class="n">add</span><span class="p">(</span> <span class="mi">1</span> <span class="p">);</span>        <span class="c1">// Increment the counter
</span>    <span class="n">lock</span><span class="err">$</span><span class="p">.</span><span class="n">writeXF</span><span class="p">(</span> <span class="nb">true</span> <span class="p">);</span> <span class="c1">// Set lock$ to full (signal)
</span>  <span class="p">}</span>

  <span class="c1">// we can define the operations + * &amp; | ^ &amp;&amp; || min max minloc maxloc
</span>  <span class="c1">// over an entire array using scans and reductions
</span>  <span class="c1">// Reductions apply the operation over the entire array and
</span>  <span class="c1">// result in a single value
</span>  <span class="n">var</span> <span class="n">listOfValues</span><span class="o">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">..</span><span class="mi">10</span><span class="p">]</span> <span class="kt">int</span> <span class="o">=</span> <span class="p">[</span><span class="mi">15</span><span class="p">,</span><span class="mi">57</span><span class="p">,</span><span class="mi">354</span><span class="p">,</span><span class="mi">36</span><span class="p">,</span><span class="mi">45</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">456</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">678</span><span class="p">,</span><span class="mi">2</span><span class="p">];</span>
  <span class="n">var</span> <span class="n">sumOfValues</span> <span class="o">=</span> <span class="o">+</span> <span class="n">reduce</span> <span class="n">listOfValues</span><span class="p">;</span>
  <span class="n">var</span> <span class="n">maxValue</span> <span class="o">=</span> <span class="n">max</span> <span class="n">reduce</span> <span class="n">listOfValues</span><span class="p">;</span> <span class="c1">// 'max' give just max value
</span>
  <span class="c1">// 'maxloc' gives max value and index of the max value
</span>  <span class="c1">// Note: We have to zip the array and domain together with the zip iterator
</span>  <span class="n">var</span> <span class="p">(</span><span class="n">theMaxValue</span><span class="p">,</span> <span class="n">idxOfMax</span><span class="p">)</span> <span class="o">=</span> <span class="n">maxloc</span> <span class="n">reduce</span> <span class="n">zip</span><span class="p">(</span><span class="n">listOfValues</span><span class="p">,</span>
                                                  <span class="n">listOfValues</span><span class="p">.</span><span class="n">domain</span><span class="p">);</span>

  <span class="n">writeln</span><span class="p">(</span> <span class="p">(</span><span class="n">sumOfValues</span><span class="p">,</span> <span class="n">maxValue</span><span class="p">,</span> <span class="n">idxOfMax</span><span class="p">,</span> <span class="n">listOfValues</span><span class="p">[</span> <span class="n">idxOfMax</span> <span class="p">]</span> <span class="p">)</span> <span class="p">);</span>

  <span class="c1">// Scans apply the operation incrementally and return an array of the
</span>  <span class="c1">// value of the operation at that index as it progressed through the
</span>  <span class="c1">// array from array.domain.low to array.domain.high
</span>  <span class="n">var</span> <span class="n">runningSumOfValues</span> <span class="o">=</span> <span class="o">+</span> <span class="n">scan</span> <span class="n">listOfValues</span><span class="p">;</span>
  <span class="n">var</span> <span class="n">maxScan</span> <span class="o">=</span> <span class="n">max</span> <span class="n">scan</span> <span class="n">listOfValues</span><span class="p">;</span>
  <span class="n">writeln</span><span class="p">(</span> <span class="n">runningSumOfValues</span> <span class="p">);</span>
  <span class="n">writeln</span><span class="p">(</span> <span class="n">maxScan</span> <span class="p">);</span>
<span class="p">}</span> <span class="c1">// end main()
</span></code></pre>

<h2>Who is this tutorial for?</h2>

<p>This tutorial is for people who want to learn the ropes of chapel without having to hear about what fiber mixture the ropes are, or how they were braided, or how the braid configurations differ between one another.
It won&rsquo;t teach you how to develop amazingly performant code, and it&rsquo;s not exhaustive.
Refer to the <a href="http://chapel.cray.com/language.html">language specification</a> and the <a href="http://chapel.cray.com/docs/latest/">module documentation</a> for more details.</p>

<p>Occasionally check back here and on the <a href="http://chapel.cray.com/">Chapel site</a> to see if more topics have been added or more tutorials created.</p>

<h3>What this tutorial is lacking:</h3>

<ul>
<li>Exposition of the <a href="http://chapel.cray.com/docs/latest/modules/modules.html">standard modules</a></li>
<li>Multiple Locales (distributed memory system)</li>
<li>Records</li>
<li>Parallel iterators</li>
</ul>

<h2>Your input, questions, and discoveries are important to the developers!</h2>

<p>The Chapel language is still in-development (version 1.12.0), so there are occasional hiccups with performance and language features.
The more information you give the Chapel development team about issues you encounter or features you would like to see, the better the language becomes.
Feel free to email the team and other developers through the <a href="https://sourceforge.net/p/chapel/mailman">sourceforge email lists</a>.</p>

<p>If you&rsquo;re really interested in the development of the compiler or contributing to the project,
<a href="https://github.com/chapel-lang/chapel">check out the master GitHub repository</a>.
It is under the <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache 2.0 License</a>.</p>

<h2>Installing the Compiler</h2>

<p>Chapel can be built and installed on your average &lsquo;nix machine (and cygwin).
<a href="https://github.com/chapel-lang/chapel/releases/">Download the latest release version</a>
and it&rsquo;s as easy as</p>

<ol>
<li><code>tar -xvf chapel-1.12.0.tar.gz</code></li>
<li><code>cd chapel-1.12.0</code></li>
<li><code>make</code></li>
<li><code>source util/setchplenv.bash # or .sh or .csh or .fish</code></li>
</ol>

<p>You will need to <code>source util/setchplenv.EXT</code> from within the Chapel directory (<code>$CHPL_HOME</code>) every time your terminal starts so it&rsquo;s suggested that you drop that command in a script that will get executed on startup (like .bashrc).</p>

<p>Chapel is easily installed with Brew for OS X</p>

<ol>
<li><code>brew update</code></li>
<li><code>brew install chapel</code></li>
</ol>

<h2>Compiling Code</h2>

<p>Builds like other compilers:</p>

<p><code>chpl myFile.chpl -o myExe</code></p>

<p>Notable arguments:</p>

<ul>
<li><code>--fast</code>: enables a number of optimizations and disables array bounds checks. Should only enable when application is stable.</li>
<li><code>--set &lt;Symbol Name&gt;=&lt;Value&gt;</code>: set config param <code>&lt;Symbol Name&gt;</code> to <code>&lt;Value&gt;</code> at compile-time.</li>
<li><code>--main-module &lt;Module Name&gt;</code>: use the main() procedure found in the module <code>&lt;Module Name&gt;</code> as the executable&rsquo;s main.</li>
<li><code>--module-dir &lt;Directory&gt;</code>: includes <code>&lt;Directory&gt;</code> in the module search path.</li>
</ul>

    <hr>
    <p>Got a suggestion? A correction, perhaps? <a href="https://github.com/adambard/learnxinyminutes-docs/issues/new">Open an Issue</a> on the Github Repo, or make a pull request yourself!
    </p>
    <p class="contributed">
    Originally contributed by Ian J. Bertolacci, and updated by <a href="https://github.com/adambard/learnxinyminutes-docs/blame/master/chapel.html.markdown">8 contributor(s)</a>.
    </p>

    <footer>
    <a style="float: left" rel="license" href="https://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a>
    <p>
    &copy; 2016
    
      
        <a href="http://www.cs.colostate.edu/~ibertola/">Ian J. Bertolacci</a>
      
    
    </p>

    <p>
    

    </footer>
  </div>

        </div>

        <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
        <script src="../../js/script.js"></script>

        <script>
            var _gaq=[['_setAccount','UA-3525624-21'],['_trackPageview']];
            (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
            g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
            s.parentNode.insertBefore(g,s)}(document,'script'));
        </script>
    </body>

<!-- Mirrored from learnxinyminutes.com/docs/chapel/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 02 Sep 2016 16:33:22 GMT -->
</html>
