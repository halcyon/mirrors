<!DOCTYPE html>
<html>
  
<!-- Mirrored from beautifulracket.com/stacker/why-make-languages.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 16 Mar 2017 05:47:14 GMT -->
<head>
    <meta charset="UTF-8">
    <title>Beautiful Racket: Make a language in one hour: stacker</title>
    <link rel="stylesheet" type="text/css" media="all" href="../styles.css"/>
    <script type="text/javascript" src="../functions.js"></script>
    <script type="text/javascript" src="../clipboard.min.js"></script>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-74684045-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>
<body>
<div id="alert">Thank you for your comment</div>
    <div id="doc"><h3 class="dept" anchorize="false"><a href="../index.html">Beau­ti­ful Racket</a> / <a href="../index.html#tutorials">tuto­ri­als</a></h3><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;make-a-language-in-one-hour-stacker&quot;)"></div><h1 anchor="make-a-language-in-one-hour-stacker" id="make-a-language-in-one-hour-stacker" hyphens="none">Make a language in one hour: <span class="my-code" decode="exclude">stacker</span></h1></div><ul class="siblinks"><li><a href="intro.html">1&emsp;intro</a></li><li><a class="here" href="why-make-languages.html">2&emsp;why make lan­guages</a></li><li><a href="setup.html">3&emsp;setup</a></li><li><a href="the-reader.html">4&emsp;the reader</a></li><li><a href="the-expander.html">5&emsp;the expander</a></li><li><a href="recap.html">6&emsp;recap</a></li><li><a href="source-listing.html">7&emsp;source list­ing</a></li></ul><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;what-is-a-programming-language&quot;)"></div><h3 anchor="what-is-a-programming-language" class="subhead" id="what-is-a-programming-language"><a href="#what-is-a-programming-language">What is a pro­gram­ming lan­guage?</a></h3></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_oxEt5&quot;)"></div><p id="a_oxEt5">Maybe it seems obvi­ous. But let’s be pre­cise.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_vRM2c&quot;)"></div><p id="a_vRM2c">As pro­gram­mers, our only indis­pens­able tool is a pro­gram­ming lan­guage. A pro­gram­ming lan­guage puts a com­puter—a term we’ll use to refer to any com­put­ing device—under our con­trol by let­ting us trans­late our ideas into terms the com­puter will under­stand. This is what it means to write a pro­gram.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_qTIXN&quot;)"></div><p id="a_qTIXN">Com­put­ers can be pro­grammed with­out a lan­guage. For instance, they <a class=" ext" href="https://www.theguardian.com/technology/2016/jun/28/google-says-machine-learning-is-the-future-so-i-tried-it-myself">can be trained</a>. There may come a time when com­put­ers don’t need humans to explain every­thing to them. Or any­thing. But until then, pro­gram­ming lan­guages will remain the essen­tial inter­face.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_s7bv2&quot;)"></div><p id="a_s7bv2">Still, despite our depen­dence on pro­gram­ming lan­guages, a lan­guage is usu­ally pre­sented to us in a black box. We’re encour­aged to use the lan­guage as we wish. But we’re dis­suaded from scru­ti­niz­ing how it works. And that’s fine, as far as it goes. The lux­ury of ignor­ing details is one of the great plea­sures of pro­gram­ming.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_1vomg&quot;)"></div><p id="a_1vomg">But the other great plea­sure of pro­gram­ming is learn­ing how things work, so we can change them to suit our needs. A pro­gram­ming lan­guage may start out in a black box. But we shouldn’t be intim­i­dated about tak­ing it out of that box. Once we do, we’ll see that there’s noth­ing eso­teric or spe­cial about a lan­guage. After that, we can start think­ing about pro­gram­ming lan­guages in a new way: as open-ended and mal­leable.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_Cw68S&quot;)"></div><p id="a_Cw68S">So let’s open the box.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;technology&quot;)"></div><h3 anchor="technology" class="subhead" id="technology"><a href="#technology">Tech­nol­ogy</a></h3></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_oaPQP&quot;)"></div><p id="a_oaPQP">On a tech­ni­cal level, a pro­gram­ming lan­guage is just another pro­gram. It accepts cer­tain input. It eval­u­ates that input. It pro­duces a result. The twist is that the input to a pro­gram­ming lan­guage is a string of text that describes another pro­gram—also known as <a class="glossary" href="../appendix/glossary.html#source-code"><span class="glossary-link-text">source code</span></a>. The result of the pro­gram­ming lan­guage is the pro­gram described by that source code. By con­ven­tion, the soft­ware that imple­ments the pro­gram­ming lan­guage and con­verts the source code is often known as a <em><a class="glossary" href="../appendix/glossary.html#compiler"><span class="glossary-link-text">com­piler</span></a></em> or <em><a class="glossary" href="../appendix/glossary.html#interpreter"><span class="glossary-link-text">inter­preter</span></a></em>. These terms exist mostly so we can avoid tan­gled phrases like “the pro­gram that makes the other pro­gram.“ <span class="tooltip" onclick="this.classList.toggle('tooltip_visible')"> + <span class="tooltip-inner">Yes, there is a dis­tinc­tion between these terms, but we can leave it aside for now.</span></span></p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_UZI05&quot;)"></div><p id="a_UZI05">Because a com­piler or inter­preter for a pro­gram­ming lan­guage is a pro­gram, the process of writ­ing one isn’t much dif­fer­ent than any other pro­gram: we pick a lan­guage suited for the task and start work­ing.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_cm9VL&quot;)"></div><p id="a_cm9VL">Note, how­ever, that the pro­gram­ming lan­guage we use to write a com­piler or inter­preter may have noth­ing to do with the imple­mented lan­guage. For instance, much of <span class="my-code" decode="exclude">racket</span>—the new pro­gram now on your com­puter that runs Racket source code—is imple­mented in C. Noth­ing shock­ing. <a class=" ext" href="https://en.wikipedia.org/wiki/JavaScript#Use_as_an_intermediate_language">Many lan­guages</a> can be com­piled to JavaScript. Busi­ness as usual. Like­wise, we’re going to use Racket to imple­ment new lan­guages—like <span class="my-code" decode="exclude">stacker</span>—that may not look or behave like Racket.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_C7oqQ&quot;)"></div><p id="a_C7oqQ">Broad-minded read­ers might observe that this idea of <em>take some input</em> &rarr; <em>put it into a pro­cess­ing device</em> &rarr; <em>get a result</em> is a pat­tern seen at all lev­els of pro­gram­ming. Depend­ing on the con­text, we might call the “pro­cess­ing device” in the mid­dle a func­tion, or a pro­gram, or a pro­gram­ming lan­guage. But these dis­tinc­tions are largely arbi­trary. For instance, it’s fair to think of a pro­gram­ming lan­guage as a spe­cial kind of func­tion. It prob­a­bly seems weird now, but it’s also fair to think of any func­tion as a <a class="glossary" href="../appendix/glossary.html#domain-specific-language"><span class="glossary-link-text">domain-spe­cific lan­guage</span></a> with a very tiny domain.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;design&quot;)"></div><h3 anchor="design" class="subhead" id="design"><a href="#design">Design</a></h3></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_TRfvA&quot;)"></div><p id="a_TRfvA">On a design level, a pro­gram­ming lan­guage sets the ground rules for what can hap­pen in a pro­gram. It spec­i­fies what kind of source code is accept­able, what that source code should mean, and what kind of results should be gen­er­ated.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_lFoZq&quot;)"></div><p id="a_lFoZq">Since a pro­gram­ming lan­guage can set these ground rules, it offers a wider hori­zon of pos­si­bil­i­ties than an ordi­nary pro­gram. Why? Because an ordi­nary pro­gram is nec­es­sar­ily restricted by the rules of the pro­gram­ming lan­guage it’s writ­ten in. But when we make a pro­gram­ming lan­guage instead of a pro­gram, we free our­selves from many of these con­straints.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;culture&quot;)"></div><h3 anchor="culture" class="subhead" id="culture"><a href="#culture">Cul­ture</a></h3></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_9RUXo&quot;)"></div><p id="a_9RUXo">On a cul­tural level, a pro­gram­ming lan­guage is a way to explore our evolv­ing ideas about pro­gram­ming—algo­rithms, per­for­mance, ergonom­ics, expres­sive­ness, and so on. Though a pro­gram­ming lan­guage is obvi­ously a tool for writ­ing a pro­gram, it’s also a tool for dis­cov­er­ing <em>new ways to pro­gram</em>.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_jiTQD&quot;)"></div><p id="a_jiTQD">It’s no coin­ci­dence that Racket itself emerged from the work of a team of pro­gram­ming-lan­guage researchers. They’ve used it as a plat­form for test­ing out new pro­gram­ming ideas. <span class="tooltip" onclick="this.classList.toggle('tooltip_visible')"> + <span class="tooltip-inner"><em>A lan­guage that doesn’t affect the way you think about pro­gram­ming is not worth know­ing.</em><br/>—Alan Perlis</span></span></p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_7JgLD&quot;)"></div><p id="a_7JgLD">But why should researchers have all the fun? If lan­guages were just about writ­ing pro­grams, we could’ve stopped with C. (And some have.) But com­put­ers and lan­guages are inter­est­ing specif­i­cally because they’re mal­leable. (<a class=" ext" href="https://en.wikipedia.org/wiki/AlphaGo">That is chang­ing</a>.) The more we expect out of pro­grams, the more vital it is to explore new ways of mak­ing pro­grams.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_3ECZR&quot;)"></div><p id="a_3ECZR">Which includes mak­ing new pro­gram­ming lan­guages.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;speciation&quot;)"></div><h3 anchor="speciation" class="subhead" id="speciation"><a href="#speciation">Spe­ci­a­tion</a></h3></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_mbJWc&quot;)"></div><p id="a_mbJWc">When we think about pro­gram­ming lan­guages, we shouldn’t only think of large, gen­eral-pur­pose lan­guages like Racket and Rust and Python and C. Lan­guages are more diverse than that: they can be big or small, gen­eral or spe­cial­ized, or any­where in between.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_cI5ri&quot;)"></div><p id="a_cI5ri">This brings us back to the idea of <a class="glossary" href="../appendix/glossary.html#domain-specific-language"><span class="glossary-link-text">domain-spe­cific lan­guages</span></a>, or <a class="glossary" href="../appendix/glossary.html#dsl"><span class="glossary-link-text">DSLs</span></a>. Among lan­guages, DSLs arguably have the most undis­cov­ered poten­tial, because they’ve been over­looked for so long. Why over­looked? Because until now, we haven’t had tools for mak­ing them effi­ciently.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_LKGNp&quot;)"></div><p id="a_LKGNp">But even if we haven’t been mak­ing DSLs, we’ve used them all the time, prob­a­bly with­out even notic­ing: DSLs that are designed to be used inside larger lan­guages, like reg­u­lar expres­sions, SQL and <span class="my-code" decode="exclude">printf</span>-style for­mat strings. DSLs that stand alone, like CSS/HTML, Post­Script, Coq, TeX, R, Julia, and MAT­LAB. Tools descended from Unix that are essen­tially DSLs, like <span class="my-code" decode="exclude">awk</span>, <span class="my-code" decode="exclude">bash</span>, <span class="my-code" decode="exclude">lex/yacc</span>, and <span class="my-code" decode="exclude">make</span>. <span class="tooltip" onclick="this.classList.toggle('tooltip_visible')"> + <span class="tooltip-inner">Also see <a href="../appendix/domain-specific-languages.html">domain-spe­cific lan­guages</a> in the appen­dix.</span></span></p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_K4FNk&quot;)"></div><p id="a_K4FNk">“Hold on—HTML is a data-markup for­mat, not a <a class="glossary" href="../appendix/glossary.html#turing-complete"><span class="glossary-link-text">Tur­ing-com­plete</span></a> pro­gram­ming lan­guage.” Point taken. But in this book, when we talk about DSLs and other pro­gram­ming lan­guages, we’re going to take a broad view of a lan­guage as any struc­tured nota­tion for describ­ing data or oper­a­tions on data. This view includes Tur­ing-com­plete lan­guages, but also lan­guages that do less.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_H1jou&quot;)"></div><p id="a_H1jou">Let’s not fear sim­plic­ity. Reg­u­lar expres­sions, for instance, aren’t Tur­ing com­plete, but they’re still use­ful. Con­versely, plenty of Tur­ing-com­plete lan­guages are <a href="../bf/index.html">still use­less</a>.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;why-should-i-make-a-programming-language&quot;)"></div><h3 anchor="why-should-i-make-a-programming-language" class="subhead" id="why-should-i-make-a-programming-language"><a href="#why-should-i-make-a-programming-language">Why should I make a pro­gram­ming lan­guage?</a></h3></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_9jRrG&quot;)"></div><p id="a_9jRrG">If you think pro­gram­ming should fill your brain and soul with feel­ings of power, cre­ativ­ity, curios­ity, and fun—then you’ll prob­a­bly like mak­ing pro­gram­ming lan­guages. <span class="tooltip" onclick="this.classList.toggle('tooltip_visible')"> + <span class="tooltip-inner"><em>Writ­ing a com­piler from scratch is so sat­is­fy­ing, even if it is for the most lame lan­guage ever ... you feel like the mas­ter of the uni­verse!</em><br/>—Racket big­wig <a class=" ext" href="https://twitter.com/jeapostrophe/status/822020078283714560">Jay McCarthy</a></span></span></p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_qN9T9&quot;)"></div><p id="a_qN9T9">If not, then you can move along. (No hard feel­ings.)</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_WMDY1&quot;)"></div><p id="a_WMDY1">Past that, we have the prac­ti­cal ben­e­fits:</p></div><ul><li><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_1awHr&quot;)"></div><p id="a_1awHr"><strong>Enlarge the solu­tion space</strong>. It doesn’t mat­ter which lan­guage you like best or use most—some­times you encounter a prob­lem that doesn’t mesh with the lan­guage idiom. When you make a lan­guage, you expand your pos­si­bil­i­ties, which also allows the solu­tion to be care­fully tai­lored to the prob­lem.</p></div></li><li><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_mAwZS&quot;)"></div><p id="a_mAwZS"><strong>Cer­tain pro­grams nat­u­rally describe lan­guages</strong>. Lan­guages are good for what we might call wide-fun­nel prob­lems, where there’s a large uni­verse of pos­si­ble inputs, but a rel­a­tively small scope of out­puts. (How to tell: does your pro­gram take input from arbi­trar­ily com­plex files, and turn them into a sim­pler rep­re­sen­ta­tion?)</p></div></li><li><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_UkpkV&quot;)"></div><p id="a_UkpkV"><strong>Bet­ter glue</strong>. A lit­tle lan­guage can fill holes in a larger tool­chain. For instance, Python doesn’t have a pre­pro­ces­sor like C does, but you could make one as a DSL. (Python fans, please don’t write me to explain why this is a bad idea. I’m not here to say what you <em>should</em> do, just what you <em>can</em> do.)</p></div></li><li><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_jVafp&quot;)"></div><p id="a_jVafp"><strong>Bet­ter inter­face</strong>. Whether you work alone or in a team, a lan­guage can wrap a stream­lined, easy-to-under­stand inter­face around other code. </p></div></li><li><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_a6ZYD&quot;)"></div><p id="a_a6ZYD"><strong>You’ll know some­thing oth­ers don’t</strong>. Know­ing how to make a pro­gram­ming lan­guage will teach you ideas that you can fold into your usual pro­gram­ming work.</p></div></li></ul><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_1RhBF&quot;)"></div><p id="a_1RhBF">Of course, a pro­gram­ming lan­guage isn’t the right solu­tion for every prob­lem. But when cre­at­ing a lan­guage is easy and inex­pen­sive—an in Racket, it often is—then it becomes a real­is­tic option for many more prob­lems.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;how-are-languages-implemented&quot;)"></div><h3 anchor="how-are-languages-implemented" class="subhead" id="how-are-languages-implemented"><a href="#how-are-languages-implemented-in-racket">How are lan­guages imple­mented in Racket?</a></h3></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_USmjz&quot;)"></div><p id="a_USmjz">Racket is a gen­eral-pur­pose pro­gram­ming lan­guage that pro­vides a high-level inter­face for mak­ing new lan­guages. For any Racket-imple­mented lan­guage, we’ll pro­ceed in three steps:</p></div><ol><li><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_WR1yB&quot;)"></div><p id="a_WR1yB">Design the nota­tion and behav­ior of our new lan­guage.</p></div></li><li><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_ErkZA&quot;)"></div><p id="a_ErkZA">Write a Racket pro­gram that takes source code writ­ten in the new lan­guage and con­verts its nota­tion and behav­ior to an equiv­a­lent Racket pro­gram.</p></div></li><li><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_Ap8wT&quot;)"></div><p id="a_Ap8wT">Run this new Racket pro­gram nor­mally.</p></div></li></ol><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_5Jgn0&quot;)"></div><p id="a_5Jgn0">Thus, every lan­guage imple­mented in Racket is really just an indi­rect way of writ­ing other Racket pro­grams. What we’re mak­ing in step #2 is some­times known as a <em><a class="glossary" href="../appendix/glossary.html#source-to-source-compiler"><span class="glossary-link-text">source-to-source com­piler</span></a></em> or <em><a class="glossary" href="../appendix/glossary.html#transcompiler"><span class="glossary-link-text">transcom­piler</span></a></em>.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_Ni3eP&quot;)"></div><p id="a_Ni3eP">Why is this a nice approach? Once we’re able to com­pile our new lan­guage into Racket, the new lan­guage can rely on every­thing in Racket’s tool­chain: the libraries, the cross-plat­form deploy­ment, the pack­ag­ing and test­ing tools, the DrRacket IDE, and so on. We don’t have to recre­ate it all for each lan­guage. That’s great news.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_BAtnc&quot;)"></div><p id="a_BAtnc">The cost, how­ever, is that we have to learn how to make a source-to-source com­piler in Racket. But that’s why this book exists. And we only have to learn it once. Then we can make pretty much any lan­guage we want.</p></div><div class="sidebar-container"><div class="sidebar has_form" onclick="toggle_form(&quot;a_PrtKl&quot;)"></div><p id="a_PrtKl">More­over, since the Racket imple­men­ta­tion of a lan­guage is itself just a Racket pro­gram, these lan­guages can do any­thing that Racket can. So we can make lan­guages that behave like tra­di­tional pro­gram­ming lan­guages, print­ing their results to the ter­mi­nal. But we can also make lan­guages that behave in uncon­ven­tional ways—for instance, they might pro­duce pic­tures or sounds, since Racket can do all of that too.</p></div><div anchorize="false" style="height:2em"></div><ul class="siblinks"><li><a href="intro.html">1&emsp;intro</a></li><li><a class="here" href="why-make-languages.html">2&emsp;why make lan­guages</a></li><li><a href="setup.html">3&emsp;setup</a></li><li><a href="the-reader.html">4&emsp;the reader</a></li><li><a href="the-expander.html">5&emsp;the expander</a></li><li><a href="recap.html">6&emsp;recap</a></li><li><a href="source-listing.html">7&emsp;source list­ing</a></li></ul></div>
    <a class="nav-left" href="intro.html">← prev</a>
    <a class="nav-right" href="setup.html">next →</a>




</body>

<script type="text/javascript">



function show_all_forms() {
 var elems = document.getElementsByClassName('has_form');
 for (var i = 0 ; i < elems.length ; i++) {
  toggle_form(elems[i].id);
 }
}

// for debugging forms only: uncomment next line
// show_all_forms();

// sets up copy-to-clipboard buttons in code boxes
var clipboard = new Clipboard('.copy-button');
clipboard.on('success', function(e) {console.log(e);});
clipboard.on('error', function(e) {console.log(e);});
</script>