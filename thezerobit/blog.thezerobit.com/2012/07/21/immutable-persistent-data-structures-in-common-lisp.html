
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->

<!-- Mirrored from blog.thezerobit.com/2012/07/21/immutable-persistent-data-structures-in-common-lisp.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 02 Sep 2016 16:24:57 GMT -->
<head>
  <meta charset="utf-8">
  <title>Immutable Persistent Data Structures in Common Lisp - the zero bit stream</title>
  <meta name="author" content="Stephen A. Goss">

  
  <meta name="description" content="0. The Rationale Clojure, Scala, and Haskell (and other languages) have recently brought the
idea of immutable (and persistent) data structures into &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="immutable-persistent-data-structures-in-common-lisp.html">
  <link href="../../../favicon.png" rel="icon">
  <link href="../../../stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="../../../atom.xml" rel="alternate" title="the zero bit stream" type="application/atom+xml">
  <script src="../../../javascripts/modernizr-2.0.js"></script>
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="../../../javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="../../../index.html">the zero bit stream</a></h1>
  
    <h2>programmer things</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="../../../atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://duckduckgo.com/" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:blog.thezerobit.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="../../../index.html">Blog</a></li>
  <li><a href="../../../blog/archives/index.html">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Immutable Persistent Data Structures in Common Lisp</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2012-07-21T00:00:00-07:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>21</span><span class='date-suffix'>st</span>, <span class='date-year'>2012</span></span> <span class='time'>12:00 am</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><h3>0. The Rationale</h3>

<p>Clojure, Scala, and Haskell (and other languages) have recently brought the
idea of immutable (and persistent) data structures into some amount of
popularity. This is not a new idea, by any means, as Lisp has always
supported this with its list structure, which is essentially a linked
list. In Common Lisp and Scheme, lists are actually mutable but in
practice, this is rarely a problem because it is generally considered
bad form to go around mutating lists except under certain circumstances.
Most Lisp books, tutorials and references encourage using lists in a
functional style (that is, assuming and treating them as immutable
structures).</p>

<!--more-->


<p>In Clojure, the big three data structures are the hashmap, vector, and set,
which each come with their own literal syntax. Clojure also has normal lispy
lists, too with language enforced immutability. These immutable data structures
can be approximated with normal lists in Common Lisp with the caveat that they
don&rsquo;t retain the more efficient performance characteristics of Clojure&rsquo;s data
structures. There are a few libraries for Common Lisp which provide these
structures with similar time and space complexity as Clojure&rsquo;s implementations.
The one that I recommend is <a href="http://common-lisp.net/project/fset/">FSet</a> which,
according to the Wayback Machine, has been around since at latest 2007.</p>

<p>What&rsquo;s the point of learning to use these data structures in Common Lisp? Isn&rsquo;t
Clojure better? Well, in a lot of ways, Clojure <em>is</em> a better language and
environment, but in a lot of ways, Common Lisp is better, too. I enjoy using
both languages. I&rsquo;m not quite lucky enough to have a day-job that allows me
write much code in a Lisp, so I use it for fun. Therefore, my criteria for
languages that are fun tend to push me toward Common Lisp. I generally use SBCL
or ClozureCL as implementations which are native (not bound the the JVM) and
have a much faster startup time and interact easier with native libraries. I
don&rsquo;t care much for the JVM, and I prefer native libraries to JVM libraries,
which are themselves, often just JNI wrappers on native code.
Tracebacks in SBCL and CCL are much easier to read than what you get with
Clojure. I also prefer non-lazy to lazy.</p>

<p>An aside on laziness: I like the idea of lazy collections, or iterators, or
generators, or streams (from SICP). They can be useful for certain
constructions, but they don&rsquo;t really enable anything amazing that you can&rsquo;t do
otherwise, just with a slightly different algorithm. It&rsquo;s slower. Every
implementation of Standard ML (not lazy) I&rsquo;ve tried has varied from just being
somewhat to several times faster than Haskell where all computation is lazy. I
think setting up all that delayed computation is expensive, and the only way I
found to make Haskell perform within the same ball park as Standard ML, was to
add hints here and there to get computations to go ahead and happen instead of
building a stack of thunks. I don&rsquo;t have to encourage Standard ML to do a
computation, it just does it. Same with Common Lisp. Life is much simpler and
faster when computations just happen and nothing is lazy by default.</p>

<p>So, Clojure has its advantages. One of those is a slight reduction in the
number of parens with certain standard Lisp constructions like LET and COND.
Also, the collection literals are nice. Clojure is a Lisp-1, so the shared
namespace is generally better than Lisp-2&rsquo;s like Common Lisp. Even so, there
are nice things about split function namespace, that is that you don&rsquo;t have to
worry about shadowing built in functions. This is a problem in languages with a
single namespece. I don&rsquo;t know how many programs in Python I&rsquo;ve seen that
shadow the built in &ldquo;id&rdquo; function. It turns out that&rsquo;s a really popular name
for a database column, and hence a variable name. In Common Lisp, you can name
your variable &ldquo;list&rdquo; even through there is a standard function called &ldquo;list&rdquo;,
none of this &ldquo;lst&rdquo; crap.</p>

<p>TLDR; It&rsquo;s all a matter of taste, but for me Common Lisp is just a little more
fun to hack in than Clojure.</p>

<h3>1. The List</h3>

<p>I&rsquo;ll try to keep this short. A Common Lisp list is a linked list constructed of
CONS cells. Each CONS has two parts the CAR and the CDR. The CAR generally
contains a list element and the CDR contains the next CONS cell, or NIL,
signifying the end of the list. An empty list is the same as NIL.</p>

<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="c1">;; contruct a list with a single element, the keyword symbol :x</span>
<span class="p">(</span><span class="nb">cons</span> <span class="ss">:x</span> <span class="no">nil</span><span class="p">)</span>
<span class="c1">;;--&gt; (:x)</span>

<span class="c1">;; alternately:</span>
<span class="p">(</span><span class="nb">list</span> <span class="ss">:x</span><span class="p">)</span>
<span class="c1">;;--&gt; (:x)</span>

<span class="c1">;; or with quoting (bypass evaluation):</span>
<span class="p">(</span><span class="k">quote</span> <span class="p">(</span><span class="ss">:x</span><span class="p">))</span>
<span class="c1">;;--&gt; (:x)</span>

<span class="c1">;; shorthand for quoting is a single quote mark</span>
<span class="o">&#39;</span><span class="p">(</span><span class="ss">:x</span><span class="p">)</span>
<span class="c1">;;--&gt; (:x)</span>

<span class="c1">;; CAR and CDR extract the cells of the CONS</span>
<span class="p">(</span><span class="nb">car</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">:x</span><span class="p">))</span>
<span class="c1">;;--&gt; :x</span>
<span class="p">(</span><span class="nb">cdr</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">:x</span><span class="p">))</span>
<span class="c1">;;--&gt; NIL</span>

<span class="c1">;; A list of three elements:</span>
<span class="p">(</span><span class="nb">cons</span> <span class="ss">:x</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">:y</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">:z</span> <span class="no">nil</span><span class="p">)))</span>
<span class="c1">;;--&gt; (:x :y :z)</span>
<span class="c1">;; Also: (list :x :y :z) or &#39;(:x :y :z)</span></code></pre></div>


<p>So the way to use lists as an immutable, persistent data structure is that you
can construct a new list with an element added to the front of the list without
affecting the original, and the &ldquo;tail&rdquo; of the list is shared. Also, you can get
the list minus the front element, just by taking the CDR of the list.</p>

<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">our-list</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">list</span>
    <span class="p">(</span><span class="nb">cons</span> <span class="mi">0</span> <span class="nv">our-list</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">cons</span> <span class="mi">1</span> <span class="nv">our-list</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">cdr</span> <span class="nv">our-list</span><span class="p">)</span>
    <span class="nv">our-list</span><span class="p">))</span>
<span class="c1">;;--&gt; ((0 1 2 3) (1 1 2 3) (2 3) (1 2 3))</span></code></pre></div>


<p>In that example I took a list and first constructed a new list by adding a 0 to
the front, then another new list by adding a 1 to the front, then I got a list
without the first element, and then the original list, unscathed. No list was
mutated and no space was wasted, as all these lists share the same last 2 or 3
CONS cells.</p>

<h3>2. Vector / SEQ</h3>

<p>Of course, you might want to do something other than have an ordered sequence
with the ability to add or remove elements to the front. In Clojure, you&rsquo;ve got
the vector, which is an ordered sequence that allows you to add or remove
elements anywhere in the list, and lookup arbitrary elements in O(log n) time
and with shared structure. You can do the same thing in Common Lisp with normal
lists but some of the operations will take O(n) time complexity and some
operations will return a brand new list with no shared structure. Let&rsquo;s start
with that and then show how to get Clojure-style complexity characteristics
with the SEQ collection provided by the FSet library. For small enough
sequences you might just want to use normal lists, and avoid the FSet
dependency.</p>

<p>In none of the following examples is any collection mutated, instead the value
of the expression must be captured and used instead of the original, so when I
say &ldquo;drop an element&rdquo;, I really mean &ldquo;return a new collection without an
element&rdquo;, etc.</p>

<p>You can remove an element from the end of a list with BUTLAST, a funny sounding
function which basically creates a whole new list minus the last element. You
can also specify a number of elements to remove from the end of the list.</p>

<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">butlast</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="c1">;;--&gt; (1 2)</span>

<span class="p">(</span><span class="nb">butlast</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">;;--&gt; (1 2 3)</span></code></pre></div>


<p>You can get the NTH element of a list:</p>

<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">nth</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">))</span>
<span class="c1">;;--&gt; 1</span></code></pre></div>


<p>You can take a slice of a list with SUBSEQ:</p>

<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">subseq</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span> <span class="ss">:d</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1">;;--&gt; (:B :C)</span></code></pre></div>


<p>Or drop the first n elements with NTHCDR:</p>

<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">nthcdr</span> <span class="mi">4</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span> <span class="ss">:d</span> <span class="ss">:e</span> <span class="ss">:f</span><span class="p">))</span>
<span class="c1">;;--&gt; (:E :F)</span></code></pre></div>


<p>If you want to drop or add or change an element from the middle of the list you
might have to write or use one these simple functions to do that:</p>

<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">defun</span> <span class="nv">drop-nth</span> <span class="p">(</span><span class="nv">n</span> <span class="nb">list</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">append</span> <span class="p">(</span><span class="nb">subseq</span> <span class="nb">list</span> <span class="mi">0</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nb">nthcdr</span> <span class="p">(</span><span class="nb">1+</span> <span class="nv">n</span><span class="p">)</span> <span class="nb">list</span><span class="p">)))</span>

<span class="p">(</span><span class="nv">drop-nth</span> <span class="mi">3</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span> <span class="ss">:d</span> <span class="ss">:e</span> <span class="ss">:f</span><span class="p">))</span>
<span class="c1">;;--&gt; (:A :B :C :E :F)</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">add-nth</span> <span class="p">(</span><span class="nv">n</span> <span class="nv">elem</span> <span class="nb">list</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">append</span> <span class="p">(</span><span class="nb">subseq</span> <span class="nb">list</span> <span class="mi">0</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">elem</span> <span class="p">(</span><span class="nb">nthcdr</span> <span class="nv">n</span> <span class="nb">list</span><span class="p">))))</span>

<span class="p">(</span><span class="nv">add-nth</span> <span class="mi">3</span> <span class="ss">:bar</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span> <span class="ss">:d</span> <span class="ss">:e</span> <span class="ss">:f</span><span class="p">))</span>
<span class="c1">;;--&gt; (:A :B :C :BAR :D :E :F)</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">set-nth</span> <span class="p">(</span><span class="nv">n</span> <span class="nv">elem</span> <span class="nb">list</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">append</span> <span class="p">(</span><span class="nb">subseq</span> <span class="nb">list</span> <span class="mi">0</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">elem</span> <span class="p">(</span><span class="nb">nthcdr</span> <span class="p">(</span><span class="nb">1+</span> <span class="nv">n</span><span class="p">)</span> <span class="nb">list</span><span class="p">))))</span>

<span class="p">(</span><span class="nv">set-nth</span> <span class="mi">3</span> <span class="ss">:foo</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span> <span class="ss">:d</span> <span class="ss">:e</span><span class="p">))</span>
<span class="c1">;;--&gt; (:A :B :C :FOO :E)</span></code></pre></div>


<p>Now if you want the tree-structured, persistent version of that, use FSet&rsquo;s
SEQ. If you are using Quicklisp (which I hope you are), you can load up FSet
in the REPL like this:</p>

<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nv">ql:quickload</span> <span class="ss">:fset</span><span class="p">)</span>
<span class="p">(</span><span class="nb">in-package</span> <span class="ss">:fset-user</span><span class="p">)</span></code></pre></div>


<p>There is a function, EMPTY-SEQ that creates an empty SEQ, and there&rsquo;s a macro
SEQ which can be used to construct a SEQ with multiple elements:</p>

<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nv">empty-seq</span><span class="p">)</span>
<span class="c1">;;--&gt; #[ ]</span>

<span class="p">(</span><span class="nv">seq</span> <span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">)</span>
<span class="c1">;;--&gt; #[ :A :B :C ] ;; this is how FSet pretty-prints sequences in the REPL</span></code></pre></div>


<p>You can get the first or last or nth element with FIRST, LAST and @:</p>

<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">first</span> <span class="p">(</span><span class="nv">seq</span> <span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">))</span>
<span class="c1">;;--&gt; :A</span>

<span class="p">(</span><span class="nb">last</span> <span class="p">(</span><span class="nv">seq</span> <span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">))</span>
<span class="c1">;;--&gt; :C</span>

<span class="p">(</span><span class="nv">@</span> <span class="p">(</span><span class="nv">seq</span> <span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1">;;--&gt; :B</span></code></pre></div>


<p>You can add or remove elements at the beginning or end of sequence with
WITH-FIRST, WITH-LAST, LESS-FIRST, and LESS-LAST:</p>

<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nv">with-first</span> <span class="p">(</span><span class="nv">seq</span> <span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">)</span> <span class="ss">:foo</span><span class="p">)</span>
<span class="c1">;;--&gt; #[ :FOO :A :B :C ]</span>

<span class="p">(</span><span class="nv">with-last</span> <span class="p">(</span><span class="nv">seq</span> <span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">)</span> <span class="ss">:foo</span><span class="p">)</span>
<span class="c1">;;--&gt; #[ :A :B :C :FOO ]</span>

<span class="p">(</span><span class="nv">less-first</span> <span class="p">(</span><span class="nv">seq</span> <span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">))</span>
<span class="c1">;;--&gt; #[ :B :C ]</span>

<span class="p">(</span><span class="nv">less-last</span> <span class="p">(</span><span class="nv">seq</span> <span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">))</span>
<span class="c1">;;--&gt; #[ :A :B ]</span></code></pre></div>


<p>You can replace an element, drop an element, or insert an element at a
particular index with WITH, INSERT and LESS:</p>

<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nv">with</span> <span class="p">(</span><span class="nv">seq</span> <span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">)</span> <span class="mi">1</span> <span class="ss">:foo</span><span class="p">)</span>
<span class="c1">;;--&gt; #[ :A :FOO :C ]</span>

<span class="p">(</span><span class="nv">insert</span> <span class="p">(</span><span class="nv">seq</span> <span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">)</span> <span class="mi">1</span> <span class="ss">:foo</span><span class="p">)</span>
<span class="c1">;;--&gt; #[ :A :FOO :B :C ]</span>

<span class="p">(</span><span class="nv">less</span> <span class="p">(</span><span class="nv">seq</span> <span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1">;;--&gt; #[ :A :C ]</span></code></pre></div>


<h3>2. Set</h3>

<p>In Common Lisp lists are also used to emulate sets. Not all operations
will have the optimum time complexity, but it&rsquo;s generally adequate for
most purposes.</p>

<p>Common Lisp has various equality functions: EQ, EQL, EQUAL, and EQUALP. I will
not summarize them here, but for the sake of consistency with Clojure, we&rsquo;ll
probably want to consider two elements to be equal with EQUALP. Many Common
Lisp functions take an optional :TEST parameter to specify which equality test
function to use. All of the set theory related functions do.</p>

<p>To test if a value is present in a set (really, just a list that we&rsquo;re treating
as a set), there is the MEMBER function. It will return NIL if the value is not
present (which is the only &ldquo;false&rdquo; value in Common Lisp) or the subset of the
list starting with that value (which will be treated as &ldquo;true&rdquo; in conditional
statements, etc) if it is present.</p>

<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">member</span> <span class="ss">:a</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">)</span> <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">equalp</span><span class="p">)</span>
<span class="c1">;;--&gt; (:A :B :C)</span>
<span class="p">(</span><span class="nb">member</span> <span class="ss">:d</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">)</span> <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">equalp</span><span class="p">)</span>
<span class="c1">;;--&gt; NIL</span>
<span class="p">(</span><span class="nb">member</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;asdf&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;asdf&quot;</span><span class="p">)</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">)</span> <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">equalp</span><span class="p">)</span>
<span class="c1">;;--&gt; ((&quot;asdf&quot;) :B :C)</span></code></pre></div>


<p>You can get the union or intersection of two sets with UNION and INTERSECTION:</p>

<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">union</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">:d</span> <span class="ss">:e</span> <span class="ss">:a</span><span class="p">)</span> <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">equalp</span><span class="p">)</span>
<span class="c1">;;--&gt; (:C :B :D :E :A)</span>
<span class="p">(</span><span class="nb">intersection</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">:d</span> <span class="ss">:e</span> <span class="ss">:a</span> <span class="ss">:b</span><span class="p">)</span> <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">equalp</span><span class="p">)</span>
<span class="c1">;;--&gt; (:B :A)</span></code></pre></div>


<p>You can get all the elements from one list that do not exist in another list
with SET-DIFFERENCE.</p>

<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">set-difference</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">:d</span> <span class="ss">:e</span> <span class="ss">:a</span> <span class="ss">:b</span><span class="p">)</span> <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">equalp</span><span class="p">)</span>
<span class="c1">;;--&gt; (:C)</span></code></pre></div>


<p>You can even check if a set is a subset of another set with SUBSETP.</p>

<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">subsetp</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">:d</span> <span class="ss">:e</span> <span class="ss">:a</span> <span class="ss">:b</span><span class="p">)</span> <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">equalp</span><span class="p">)</span>
<span class="c1">;;--&gt; NIL</span>

<span class="p">(</span><span class="nb">subsetp</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">:d</span> <span class="ss">:e</span> <span class="ss">:c</span> <span class="ss">:a</span> <span class="ss">:b</span><span class="p">)</span> <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">equalp</span><span class="p">)</span>
<span class="c1">;;--&gt; T</span></code></pre></div>


<p>The set of elements that exist in only one of two sets is constructed with
SET-EXCLUSIVE-OR.</p>

<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">set-exclusive-or</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">:d</span> <span class="ss">:e</span> <span class="ss">:a</span> <span class="ss">:b</span><span class="p">)</span> <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">equalp</span><span class="p">)</span>
<span class="c1">;;--&gt; (:E :D :C)</span></code></pre></div>


<p>Adding and removing elements from a list is accomplished with CONS and REMOVE:</p>

<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">cons</span> <span class="ss">:foo</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">:a</span> <span class="ss">:b</span><span class="p">))</span>
<span class="c1">;;--&gt; (:foo :a :b)</span>

<span class="p">(</span><span class="nb">remove</span> <span class="s">&quot;elem&quot;</span> <span class="p">(</span><span class="nb">list</span> <span class="s">&quot;foo&quot;</span> <span class="s">&quot;bar&quot;</span> <span class="s">&quot;elem&quot;</span><span class="p">)</span> <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">equalp</span><span class="p">)</span>
<span class="c1">;;--&gt; (&quot;foo&quot; &quot;bar&quot;)</span></code></pre></div>


<p>It&rsquo;s clear that Common Lisp was designed to use lists as sets when necessary,
but under certain conditions you might want to use a more efficient
implementation (say if you wanted to do a lot of membership tests in a larger
set, and would benefit from O(log n) membership test instead of O(n)) you can
use FSet&rsquo;s SET. You can construct an empty set with EMPTY-SET or pre-populate
with the SET macro (which shadows the archaic and generally unused SET function
built into Common Lisp).</p>

<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nv">empty-set</span><span class="p">)</span>
<span class="c1">;;--&gt; #{ }</span>

<span class="p">(</span><span class="nb">set</span> <span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">)</span>
<span class="c1">;;--&gt; #{ :A :B :C }</span></code></pre></div>


<p>The FSet library comes with an equality function that is used automatically:
EQUAL?. It is slightly better than EQUALP in that it will find two sets equal
that are equivalent sets (same for other FSet collections).:</p>

<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">equalp</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">:b</span> <span class="ss">:c</span> <span class="ss">:a</span><span class="p">))</span>
<span class="no">NIL</span>

<span class="p">(</span><span class="nv">equal?</span> <span class="p">(</span><span class="nb">set</span> <span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">)</span> <span class="p">(</span><span class="nb">set</span> <span class="ss">:b</span> <span class="ss">:c</span> <span class="ss">:a</span><span class="p">))</span>
<span class="no">T</span></code></pre></div>


<p>Membership is tested with CONTAINS?:</p>

<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nv">contains?</span> <span class="p">(</span><span class="nb">set</span> <span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">)</span> <span class="ss">:a</span><span class="p">)</span>
<span class="c1">;;--&gt; T</span>

<span class="p">(</span><span class="nv">contains?</span> <span class="p">(</span><span class="nb">set</span> <span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">)</span> <span class="ss">:d</span><span class="p">)</span>
<span class="c1">;;--&gt; NIL</span></code></pre></div>


<p>UNION, INTERSECTION, and SET-DIFFERENCE work as expected:</p>

<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">union</span> <span class="p">(</span><span class="nb">set</span> <span class="ss">:a</span> <span class="ss">:b</span><span class="p">)</span> <span class="p">(</span><span class="nb">set</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">))</span>
<span class="c1">;;--&gt; #{ :A :B :C }</span>

<span class="p">(</span><span class="nb">intersection</span> <span class="p">(</span><span class="nb">set</span> <span class="ss">:a</span> <span class="ss">:b</span><span class="p">)</span> <span class="p">(</span><span class="nb">set</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">))</span>
<span class="c1">;;--&gt; #{ :B }</span>

<span class="p">(</span><span class="nb">set-difference</span> <span class="p">(</span><span class="nb">set</span> <span class="ss">:a</span> <span class="ss">:b</span><span class="p">)</span> <span class="p">(</span><span class="nb">set</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">))</span>
<span class="c1">;;--&gt; #{ :A }</span></code></pre></div>


<p>Two tests exist: SUBSET? and DISJOINT?.</p>

<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nv">subset?</span> <span class="p">(</span><span class="nb">set</span> <span class="ss">:a</span> <span class="ss">:b</span><span class="p">)</span> <span class="p">(</span><span class="nb">set</span> <span class="ss">:b</span> <span class="ss">:c</span> <span class="ss">:a</span><span class="p">))</span>
<span class="c1">;;--&gt; T</span>

<span class="p">(</span><span class="nv">subset?</span> <span class="p">(</span><span class="nb">set</span> <span class="ss">:d</span> <span class="ss">:b</span><span class="p">)</span> <span class="p">(</span><span class="nb">set</span> <span class="ss">:b</span> <span class="ss">:c</span> <span class="ss">:a</span><span class="p">))</span>
<span class="c1">;;--&gt; NIL</span>

<span class="p">(</span><span class="nv">disjoint?</span> <span class="p">(</span><span class="nb">set</span> <span class="ss">:a</span> <span class="ss">:b</span><span class="p">)</span> <span class="p">(</span><span class="nb">set</span> <span class="ss">:c</span> <span class="ss">:d</span><span class="p">))</span>
<span class="c1">;;--&gt; T</span>

<span class="p">(</span><span class="nv">disjoint?</span> <span class="p">(</span><span class="nb">set</span> <span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">)</span> <span class="p">(</span><span class="nb">set</span> <span class="ss">:c</span> <span class="ss">:d</span><span class="p">))</span>
<span class="c1">;;--&gt; NIL</span></code></pre></div>


<p>Adding and removing elements from a SET is accomplished with WITH and LESS:</p>

<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nv">with</span> <span class="p">(</span><span class="nb">set</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">)</span> <span class="ss">:a</span><span class="p">)</span>
<span class="c1">;;--&gt; #{ :A :B :C }</span>

<span class="p">(</span><span class="nv">less</span> <span class="p">(</span><span class="nb">set</span> <span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">)</span> <span class="ss">:a</span><span class="p">)</span>
<span class="c1">;;--&gt; #{ :B :C }</span></code></pre></div>


<h3>3. Map</h3>

<p>There are two ways lists are used in Common Lisp to create mapping collections.</p>

<p>The plist is just a list with every two elements representing a key and a
value. It has one useful function, GETF which uses EQ for key equality and no
way to use any other comparison, making it only useful for using symbols for
keys:</p>

<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">getf</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">:name</span> <span class="s">&quot;Steve&quot;</span> <span class="ss">:age</span> <span class="mi">33</span><span class="p">)</span> <span class="ss">:name</span><span class="p">)</span>
<span class="c1">;;--&gt; &quot;Steve&quot;</span>

<span class="p">(</span><span class="nb">getf</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">:name</span> <span class="s">&quot;Steve&quot;</span> <span class="ss">:age</span> <span class="mi">33</span><span class="p">)</span> <span class="ss">:weight</span><span class="p">)</span>
<span class="c1">;;--&gt; NIL</span>

<span class="p">(</span><span class="nb">getf</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">:name</span> <span class="s">&quot;Steve&quot;</span> <span class="ss">:age</span> <span class="mi">33</span><span class="p">)</span> <span class="ss">:weight</span> <span class="s">&quot;some default&quot;</span><span class="p">)</span>
<span class="c1">;;--&gt; &quot;some default&quot;</span></code></pre></div>


<p>Mappings can be changed or added by appending a key/value pair to the front of
the list since GETF searches from the front:</p>

<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">getf</span> <span class="p">(</span><span class="nb">append</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">:name</span> <span class="s">&quot;Stephen&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">:name</span> <span class="s">&quot;Steve&quot;</span> <span class="ss">:age</span> <span class="mi">33</span><span class="p">))</span> <span class="ss">:name</span><span class="p">)</span>
<span class="c1">;;--&gt; &quot;Stephen&quot;</span></code></pre></div>


<p>You could easily build a repertoire of functions to do all the common
operations you might want with plists, but there is another form called the
alist which comes with a better set of operations built in. An alist is a list
of cons cells with the key in the CAR and value in the CDR. When you have a
CONS cell with a non-list in the CDR, it is called a dotted list and looks like
this: <code>(car . cdr)</code>. Alists can be constructed in a variety of ways:</p>

<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">:key</span> <span class="s">&quot;val&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">:other-key</span> <span class="s">&quot;other-val&quot;</span><span class="p">))</span>
<span class="c1">;;--&gt; ((:KEY . &quot;val&quot;) (:OTHER-KEY . &quot;other-val&quot;))</span>

<span class="o">&#39;</span><span class="p">((</span><span class="ss">:key</span> <span class="o">.</span> <span class="s">&quot;val&quot;</span><span class="p">)</span> <span class="p">(</span><span class="ss">:other-key</span> <span class="o">.</span> <span class="s">&quot;other-val&quot;</span><span class="p">))</span>
<span class="c1">;;--&gt; ((:KEY . &quot;val&quot;) (:OTHER-KEY . &quot;other-val&quot;))</span>

<span class="p">(</span><span class="nb">pairlis</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">:key1</span> <span class="ss">:key2</span> <span class="ss">:key3</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="s">&quot;val1&quot;</span> <span class="s">&quot;val2&quot;</span> <span class="s">&quot;val3&quot;</span><span class="p">))</span>
<span class="c1">;;--&gt; ((:KEY3 . &quot;val3&quot;) (:KEY2 . &quot;val2&quot;) (:KEY1 . &quot;val1&quot;))</span></code></pre></div>


<p>The lookup function for alists is ASSOC which takes the :TEST parameter for key
equality though it returns the entire matching CONS cell, not just the value.
You can use CDR to extract the value.</p>

<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">assoc</span> <span class="ss">:key</span> <span class="o">&#39;</span><span class="p">((</span><span class="ss">:key</span> <span class="o">.</span> <span class="s">&quot;val&quot;</span><span class="p">)</span> <span class="p">(</span><span class="ss">:other-key</span> <span class="o">.</span> <span class="s">&quot;other-val&quot;</span><span class="p">))</span> <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">equalp</span><span class="p">)</span>
<span class="c1">;;--&gt; (:KEY . &quot;val&quot;)</span>

<span class="p">(</span><span class="nb">cdr</span> <span class="p">(</span><span class="nb">assoc</span> <span class="ss">:other-key</span> <span class="o">&#39;</span><span class="p">((</span><span class="ss">:key</span> <span class="o">.</span> <span class="s">&quot;val&quot;</span><span class="p">)</span> <span class="p">(</span><span class="ss">:other-key</span> <span class="o">.</span> <span class="s">&quot;other-val&quot;</span><span class="p">))</span> <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">equalp</span><span class="p">))</span>
<span class="c1">;;--&gt; &quot;other-val&quot;</span>

<span class="p">(</span><span class="nb">assoc</span> <span class="ss">:missing-key</span> <span class="o">&#39;</span><span class="p">((</span><span class="ss">:key</span> <span class="o">.</span> <span class="s">&quot;val&quot;</span><span class="p">)</span> <span class="p">(</span><span class="ss">:other-key</span> <span class="o">.</span> <span class="s">&quot;other-val&quot;</span><span class="p">))</span> <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">equalp</span><span class="p">)</span>
<span class="c1">;;--&gt; NIL</span></code></pre></div>


<p>Like plists, key/val pairs can be added to alists by adding them to the front
of the list. There is a helper function for this called ACONS:</p>

<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">acons</span> <span class="s">&quot;foo&quot;</span> <span class="s">&quot;bar&quot;</span> <span class="o">&#39;</span><span class="p">((</span><span class="s">&quot;baz&quot;</span> <span class="o">.</span> <span class="s">&quot;val&quot;</span><span class="p">)))</span>
<span class="c1">;;--&gt; ((&quot;foo&quot; . &quot;bar&quot;) (&quot;baz&quot; . &quot;val&quot;))</span></code></pre></div>


<p>There&rsquo;s no builtin function to remove keys from an alist, but we can write one
easily enough:</p>

<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">defun</span> <span class="nv">alist-remove</span> <span class="p">(</span><span class="nv">alist</span> <span class="nv">key</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">remove-if</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">cell</span><span class="p">)</span> <span class="p">(</span><span class="nb">equalp</span> <span class="nv">key</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">cell</span><span class="p">)))</span> <span class="nv">alist</span><span class="p">))</span>

<span class="p">(</span><span class="nv">alist-remove</span> <span class="o">&#39;</span><span class="p">((</span><span class="ss">:a</span> <span class="o">.</span> <span class="mi">100</span><span class="p">)</span> <span class="p">(</span><span class="ss">:b</span> <span class="o">.</span> <span class="mi">200</span><span class="p">))</span> <span class="ss">:a</span><span class="p">)</span>
<span class="c1">;;--&gt; ((:B . 200))</span></code></pre></div>


<p>Alists are probably an 80% solution, which is plenty for most situations, but
FSet&rsquo;s maps are quite nice and give you that O(log n) lookup and update time
complexity with the structural sharing that we&rsquo;ve grown to love. I&rsquo;ve found
them as useful as Clojure&rsquo;s hashmaps. Like the other collections, there&rsquo;s a
function EMPTY-MAP that&rsquo;s self explanatory and a macro MAP for constructing
larger maps:</p>

<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nv">empty-map</span><span class="p">)</span>
<span class="c1">;;--&gt; #{| |}</span>

<span class="p">(</span><span class="nb">map</span> <span class="p">(</span><span class="ss">:a</span> <span class="mi">100</span><span class="p">)</span> <span class="p">(</span><span class="ss">:b</span> <span class="mi">200</span><span class="p">))</span>
<span class="c1">;;--&gt; #{| (:A 100) (:B 200) |}</span></code></pre></div>


<p>Like SETs, elements can be added or removed or accessed from FSet MAP
collections with WITH, LESS and @.</p>

<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nv">with</span> <span class="p">(</span><span class="nb">map</span> <span class="p">(</span><span class="ss">:a</span> <span class="mi">100</span><span class="p">))</span> <span class="ss">:b</span> <span class="mi">200</span><span class="p">)</span>
<span class="c1">;;--&gt; #{| (:A 100) (:B 200) |}</span>

<span class="p">(</span><span class="nv">less</span> <span class="p">(</span><span class="nb">map</span> <span class="p">(</span><span class="ss">:a</span> <span class="mi">100</span><span class="p">)</span> <span class="p">(</span><span class="ss">:c</span> <span class="mi">200</span><span class="p">))</span> <span class="ss">:c</span><span class="p">)</span>
<span class="c1">;;--&gt; #{| (:A 100) |}</span>

<span class="p">(</span><span class="nv">@</span> <span class="p">(</span><span class="nb">map</span> <span class="p">(</span><span class="ss">:a</span> <span class="mi">100</span><span class="p">)</span> <span class="p">(</span><span class="ss">:c</span> <span class="mi">200</span><span class="p">))</span> <span class="ss">:c</span><span class="p">)</span>
<span class="c1">;;--&gt; 200</span></code></pre></div>


<h3>4. Conclusion w/bonus Feature</h3>

<p>I only scratched the surface with the FSet library. There are more functions
than the ones I listed and some of the ones I describe actually return multiple
values, for example to signify if a key is present in case you are storing NIL
as values, etc. I recommend the <a href="http://common-lisp.net/project/fset/Site/FSet-Tutorial.html">FSet
Tutorial</a> for more
details.</p>

<p>Lists in Common Lisp are really quite versatile and can approximate most other
structures for limited sizes. The nice thing about the FSet library is that it
always puts the collection as the first argument, so it is amenable to
Clojure&rsquo;s threading macro: -> which I will translate here for your benefit into
Common Lisp:</p>

<div class="highlight"><pre><code class="language-cl" data-lang="cl"><span class="p">(</span><span class="nb">defmacro</span> <span class="nv">-&gt;</span> <span class="p">(</span><span class="nv">x</span> <span class="k">&amp;optional</span> <span class="p">(</span><span class="nv">form</span> <span class="no">nil</span> <span class="nv">form-supplied-p</span><span class="p">)</span> <span class="k">&amp;rest</span> <span class="nv">more</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="nv">form-supplied-p</span>
    <span class="p">(</span><span class="k">if</span> <span class="nv">more</span>
      <span class="o">`</span><span class="p">(</span><span class="nv">-&gt;</span> <span class="p">(</span><span class="nv">-&gt;</span> <span class="o">,</span><span class="nv">x</span> <span class="o">,</span><span class="nv">form</span><span class="p">)</span> <span class="o">,@</span><span class="nv">more</span><span class="p">)</span>
      <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">listp</span> <span class="nv">form</span><span class="p">)</span>
        <span class="o">`</span><span class="p">(</span><span class="o">,</span><span class="p">(</span><span class="nb">car</span> <span class="nv">form</span><span class="p">)</span> <span class="o">,</span><span class="nv">x</span> <span class="o">,@</span><span class="p">(</span><span class="nb">cdr</span> <span class="nv">form</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">list</span> <span class="nv">form</span> <span class="nv">x</span><span class="p">)))</span>
    <span class="nv">x</span><span class="p">))</span>

<span class="p">(</span><span class="nv">-&gt;</span> <span class="p">(</span><span class="nv">empty-map</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">with</span> <span class="ss">:a</span> <span class="mi">100</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">with</span> <span class="ss">:b</span> <span class="mi">200</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">less</span> <span class="ss">:a</span><span class="p">))</span>
<span class="c1">;;--&gt; #{| (:B 200) |}</span></code></pre></div>



</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Stephen A. Goss</span></span>

      




<time class='entry-date' datetime='2012-07-21T00:00:00-07:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>21</span><span class='date-suffix'>st</span>, <span class='date-year'>2012</span></span> <span class='time'>12:00 am</span></time>
      


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://blog.thezerobit.com/2012/07/21/immutable-persistent-data-structures-in-common-lisp.html" data-via="thezerobit" data-counturl="http://blog.thezerobit.com/2012/07/21/immutable-persistent-data-structures-in-common-lisp.html" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
      
        <a class="basic-alignment right" href="../28/lazy-sequences-in-common-lisp.html" title="Next Post: Lazy Sequences in Common Lisp">Lazy Sequences in Common Lisp &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="../../../2014/06/05/the-flow-of-code.html">The Flow of Code</a>
      </li>
    
      <li class="post">
        <a href="../../../2014/05/25/python-3-is-killing-python.html">Python 3 Is Killing Python</a>
      </li>
    
      <li class="post">
        <a href="../../09/01/beautiful-quicksort-in-common-lisp.html">Beautiful Quicksort in Common Lisp</a>
      </li>
    
      <li class="post">
        <a href="../../08/26/concurrency-in-common-lisp-with-chanl.html">Concurrency in Common Lisp With ChanL</a>
      </li>
    
      <li class="post">
        <a href="../28/lazy-sequences-in-common-lisp.html">Lazy Sequences in Common Lisp</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>About Me</h1>
  <p><a href="http://twitter.com/thezerobit">@thezerobit</a> on Twitter.</p>
  <p>Email is <strong>steveth45</strong> at <strong>gmail</strong>.</p>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/thezerobit">@thezerobit</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '../../../javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'thezerobit',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="../../../javascripts/github.js" type="text/javascript"> </script>
</section>


  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Stephen A. Goss -
  <span class="credit">Powered by <a href="http://octopress.org/">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>

<!-- Mirrored from blog.thezerobit.com/2012/07/21/immutable-persistent-data-structures-in-common-lisp.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 02 Sep 2016 16:24:57 GMT -->
</html>
