<!DOCTYPE html>
<html lang="en-US" prefix="og: http://ogp.me/ns#">

<!-- Mirrored from malisper.me/category/advanced-macros/ by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 01 Sep 2016 17:46:31 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Advanced Macros Archives - Macrology</title>
<link rel="profile" href="http://gmpg.org/xfn/11">
<link rel="pingback" href="../../xmlrpc.php">


<!-- This site is optimized with the Yoast SEO plugin v3.4.2 - https://yoast.com/wordpress/plugins/seo/ -->
<link rel="canonical" href="index.html" />
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="object" />
<meta property="og:title" content="Advanced Macros Archives - Macrology" />
<meta property="og:url" content="index.html" />
<meta property="og:site_name" content="Macrology" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Advanced Macros Archives - Macrology" />
<!-- / Yoast SEO plugin. -->

<link rel='dns-prefetch' href='http://fonts.googleapis.com/'>
<link rel="alternate" type="application/rss+xml" title="Macrology &raquo; Feed" href="../../feed/index.html" />
<link rel="alternate" type="application/rss+xml" title="Macrology &raquo; Comments Feed" href="../../comments/feed/index.html" />
<link rel="alternate" type="application/rss+xml" title="Macrology &raquo; Advanced Macros Category Feed" href="feed/index.html" />
<link rel='stylesheet' id='scrawl-style-css'  href='../../wp-content/themes/scrawl-wpcom/style167b.css?ver=4.6' type='text/css' media='all' />
<link rel='stylesheet' id='scrawl-fonts-css'  href='https://fonts.googleapis.com/css?family=Lora:400,700|Merriweather:400italic,400,700,700italic&amp;subset=latin%2Clatin-ext' type='text/css' media='all' />
<link rel='stylesheet' id='genericons-css'  href='../../wp-content/themes/scrawl-wpcom/fonts/genericons6de8.css?ver=3.3' type='text/css' media='all' />
<script type='text/javascript' src='../../wp-includes/js/jquery/jqueryb8ff.js?ver=1.12.4'></script>
<script type='text/javascript' src='../../wp-includes/js/jquery/jquery-migrate.min330a.js?ver=1.4.1'></script>
<link rel='https://api.w.org/' href='../../wp-json/index.html' />
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="../../xmlrpc0db0.php?rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="../../wp-includes/wlwmanifest.xml" /> 
<meta name="generator" content="WordPress 4.6" />
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-63547056-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
<style type="text/css" id="syntaxhighlighteranchor"></style>

<script type="text/javascript">
  window.heap=window.heap||[],heap.load=function(e,t){window.heap.appid=e,window.heap.config=t=t||{};var n=t.forceSSL||"https:"===document.location.protocol,a=document.createElement("script");a.type="text/javascript",a.async=!0,a.src=(n?"https:":"http:")+"//cdn.heapanalytics.com/js/heap-"+e+".js";var o=document.getElementsByTagName("script")[0];o.parentNode.insertBefore(a,o);for(var r=function(e){return function(){heap.push([e].concat(Array.prototype.slice.call(arguments,0)))}},p=["clearEventProperties","identify","setEventProperties","track","unsetEventProperty"],c=0;c<p.length;c++)heap[p[c]]=r(p[c])};
    heap.load("931515525");
</script>
</head>

<body class="archive category category-advanced-macros category-6">
	<button class="menu-toggle x">
		<span class="lines"></span>
		<span class="screen-reader-text">Primary Menu</span>
	</button>
	<div class="slide-menu">
				
		<h1 class="site-title"><a href="../../index.html" rel="home">Macrology</a></h1>
		<h2 class="site-description">Case Studies in Lisp Macros</h2>
		
				
				
			<div id="secondary" class="widget-area" role="complementary">
		<aside id="search-2" class="widget widget_search"><form role="search" method="get" class="search-form" action="http://malisper.me/">
				<label>
					<span class="screen-reader-text">Search for:</span>
					<input type="search" class="search-field" placeholder="Search &hellip;" value="" name="s" />
				</label>
				<input type="submit" class="search-submit" value="Search" />
			</form></aside><aside id="pages-3" class="widget widget_pages"><h1 class="widget-title">Pages</h1>		<ul>
			<li class="page_item page-item-55"><a href="../../about-me/index.html">About Michael Malis</a></li>
<li class="page_item page-item-44"><a href="../../about-this-site-2/index.html">About This Site</a></li>
		</ul>
		</aside><aside id="nav_menu-3" class="widget widget_nav_menu"><h1 class="widget-title">Contact Me</h1><div class="menu-contact-me-container"><ul id="menu-contact-me" class="menu"><li id="menu-item-60" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-60"><a href="mailto:michaelmalis2@gmail.com">Email</a></li>
<li id="menu-item-58" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-58"><a href="https://github.com/malisper">Github</a></li>
<li id="menu-item-59" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-59"><a href="https://news.ycombinator.com/user?id=malisper">Hacker News</a></li>
</ul></div></aside><aside id="archives-2" class="widget widget_archive"><h1 class="widget-title">Archives</h1>		<ul>
			<li><a href='../../2016/06/index.html'>June 2016</a></li>
	<li><a href='../../2016/04/index.html'>April 2016</a></li>
	<li><a href='../../2016/01/index.html'>January 2016</a></li>
	<li><a href='../../2015/12/index.html'>December 2015</a></li>
	<li><a href='../../2015/11/index.html'>November 2015</a></li>
	<li><a href='../../2015/10/index.html'>October 2015</a></li>
	<li><a href='../../2015/09/index.html'>September 2015</a></li>
	<li><a href='../../2015/08/index.html'>August 2015</a></li>
	<li><a href='../../2015/07/index.html'>July 2015</a></li>
	<li><a href='../../2015/06/index.html'>June 2015</a></li>
	<li><a href='../../2015/05/index.html'>May 2015</a></li>
		</ul>
		</aside><aside id="categories-2" class="widget widget_categories"><h1 class="widget-title">Categories</h1>		<ul>
	<li class="cat-item cat-item-2"><a href="../basics/index.html" title="These are basic Lisp macros that should be trivial to understand.">Basic Macros</a>
</li>
	<li class="cat-item cat-item-5"><a href="../intermediate-macros/index.html" >Intermediate Macros</a>
</li>
	<li class="cat-item cat-item-6 current-cat"><a href="index.html" >Advanced Macros</a>
</li>
	<li class="cat-item cat-item-7"><a href="../debugging-common-lisp/index.html" >Debugging Lisp</a>
</li>
	<li class="cat-item cat-item-8"><a href="../loops-in-lisp/index.html" >Loops in Lisp</a>
</li>
		</ul>
</aside>	</div><!-- #secondary -->
	</div><!-- .slide-menu -->
<div id="page" class="hfeed site">
	<a class="skip-link screen-reader-text" href="#content">Skip to content</a>

	<header id="masthead" class="site-header" role="banner">

		<div class="site-branding">
						<h1 class="site-title"><a href="../../index.html" rel="home">Macrology</a></h1>
		</div>

	</header><!-- #masthead -->

	
	
	<div id="content" class="site-content">


	<section id="primary" class="content-area">
		<main id="main" class="site-main" role="main">

		
			<header class="page-header">
				<h1 class="page-title">Category: Advanced Macros</h1>			</header><!-- .page-header -->

			
				
					
<article id="post-1366" class="post-1366 post type-post status-publish format-standard hentry category-advanced-macros category-loops-in-lisp">
	<header class="entry-header">
					<h1 class="entry-title"><a href="../../2016/04/13/loops-in-lisp-part-4-series/index.html" rel="bookmark">Loops in Lisp Part 4: Series</a></h1>			</header><!-- .entry-header -->
			<div class="entry-content">
			<p><em>This is part four of Loops in Lisp. Follow one of the following links for part <a href="../../2015/11/24/loops-lisp-part-1-goto/index.html">one</a>, <a href="../../2015/12/15/loops-in-lisp-part-2-loop/index.html">two</a>, or <a href="../../2016/01/12/loops-in-lisp-part-3-iterate/index.html">three</a>).</em></p>
<p>One of the many advantages of programming in a functional style (by this, I mean manipulating your data through the operations, map, fold, and filter) is that your program winds up being made up a bunch of tiny and composable pieces. Since each piece is so small, usually only a few lines each, it becomes trivial to unit test the entire program. Additionally, it is easy to express new features as just the composition of several existing functions. One disadvantage of programming through map and friends, is that there is fairly large time penalty for allocating the intermediate results. For example, every time filter is called on a list, a new list needs to be allocated. These costs add up pretty quickly and can make a functional program much slower than its imperative equivalent.</p>
<p>One solution to this problem is laziness. Instead of allocating a new list every time an operation is performed on a list, you instead keep track of all of the transformations made on the list. Then when you fold over the list, you perform all of the transformations as you are folding over it. By doing this, you don&#8217;t need to allocate intermediate lists. Although laziness doesn&#8217;t allocate any intermediate lists, there is still a small cost for keeping track of the laziness. An alternative solution that makes functional programming just as fast as imperative programming is provided by the Series library.<span id='easy-footnote-1' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../2016/04/13/loops-in-lisp-part-4-series/index.html#easy-footnote-bottom-1' title='The technique used by Series is sometimes referred to as &#8220;stream fusion&#8221;.'><sup>1</sup></a></span> Series lets you write your program in a functional style without <em>any</em> runtime penalty at all!</p>
<p>Personally, the Series library is my favorite example of the magic that can be pulled off with macros. In short, Series works by taking your functional code and compiling it down into a single loop. In this loop, there is one step per transformation performed on the original list. The loop iterates over the values of the original sequence on at a time. On each iteration, the loop takes a single element, performs all of the transformations performed on the list on that single element, and then accumulates that value into the result according to the folding operation. This loop requires no additional memory allocation at runtime, and their is no time penalty either! As an example, here is a program that sums the first N squares, written using Series:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defun integers ()
  &quot;Returns a 'series' of all of the natural numbers.&quot;
  (declare (optimizable-series-function))
  (scan-range :from 1))

(defun squares ()
  &quot;Returns a 'series' of all of the square numbers.&quot;
  (declare (optimizable-series-function))
  (map-fn t 
          (lambda (x) (* x x)) 
          (integers)))

(defun sum-squares (n)
  &quot;Returns the sum of the first N square numbers.&quot;
  (collect-sum (subseries (squares) 0 n)))

(sum-squares 10)
=&gt; 385
</pre>
<p>The above code certainly looks functional, there are no side effects in sight. Now let&#8217;s look at the code generated by Series. Here is what the macroexpansion of <strong>collect-sum</strong> looks like:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(common-lisp:let* ((#:out-969 n))
  (common-lisp:let ((#:numbers-966
                     (coerce-maybe-fold (- 1 1) 'number))
                    #:items-967
                    (#:index-965 -1)
                    (#:sum-959 0))
    (declare (type number #:numbers-966)
             (type (integer -1) #:index-965)
             (type number #:sum-959))
    (tagbody
       #:ll-970
       (setq #:numbers-966
             (+ #:numbers-966
                (coerce-maybe-fold 1 'number)))
       (setq #:items-967
             ((lambda (x) (* x x)) #:numbers-966))
       (incf #:index-965)
       (locally
          (declare (type nonnegative-integer #:index-965))
         (if (&gt;= #:index-965 #:out-969)
             (go end))
         (if (&lt; #:index-965 0)
             (go #:ll-970)))
       (setq #:sum-959 (+ #:sum-959 #:items-967))
       (go #:ll-970)
     end)
    #:sum-959))
</pre>
<p>What series does it looks at the entire lifetime of the sequence from its creation until it is folded. It uses this information to build the above loop which simultaneously generates the original sequence, maps over it, filters elements out of it, and folds it into the final result. Here is the breakdown of the expansion. Lines 1-9 are just initialization. They define all of the variables the loop will be using and set them to their starting values. The important variables to keep track of are #:NUMBERS-966, #:ITEMS-967, and #:SUM-959. As the code &#8220;iterates&#8221; over the original sequence, #:NUMBERS-966 is the value of the original sequence, #:ITEMS-967 is the square of that value, and #:SUM-959 is the sum of the squares so far. The rest of the code is the actual loop.</p>
<p>The loop first takes #:NUMBERS-966, the previous value of the sequence, and increments it in order to set it to current value of the sequence (since the sequence is the range from 1 to infinity). Next the loop takes the square of #:NUMBERS-966 to get the ith square number and stores that in #:ITEMS-967. Then the loop checks if it ha taken more than N elements out of the sequence, and if so, terminates. Finally the loop takes the value in #:ITEMS-967 and accumulates that into #:SUM-959.</p>
<p>Although the imperative version is equivalent to the original functional code, it is much faster than the functional code if the functional code were to allocate intermediate results or use laziness. This idea of turning transformations on a list into a loop doesn&#8217;t just work for this simple example, it also works for much more complicated programs. I just find it incredible that Series is able to take such pretty code and compile it into code that is extremely fast.</p>
					</div><!-- .entry-content -->
				<div class="entry-meta clear">
			<span class="posted-on">Posted on <a href="../../2016/04/13/loops-in-lisp-part-4-series/index.html" rel="bookmark"><time class="entry-date published" datetime="2016-04-13T03:06:36+00:00">April 13, 2016</time><time class="updated" datetime="2016-04-14T03:44:39+00:00">April 14, 2016</time></a></span><span class="byline"> by <span class="author vcard"><a class="url fn n" href="../../author/malisper/index.html">malisper</a></span></span>			<span class="secondary-entry-meta">
																	<span class="comments-link"><a href="../../2016/04/13/loops-in-lisp-part-4-series/index.html#comments">4</a></span>							</span>
		</div><!-- .entry-meta -->
	</article><!-- #post-## -->

				
					
<article id="post-1292" class="post-1292 post type-post status-publish format-standard hentry category-advanced-macros category-loops-in-lisp">
	<header class="entry-header">
					<h1 class="entry-title"><a href="../../2016/01/12/loops-in-lisp-part-3-iterate/index.html" rel="bookmark">Loops in Lisp Part 3: Iterate</a></h1>			</header><!-- .entry-header -->
			<div class="entry-content">
			<p><em>This is part 3 of Loops in Lisp. For part 1 on how you can build any kind of looping construct you want out of just goto and macros, click <a href="../../2015/11/24/loops-lisp-part-1-goto/index.html">here</a>. For part 2 on Loop, click <a href="../../2015/12/15/loops-in-lisp-part-2-loop/index.html">here</a>.</em></p>
<p>The <a href="https://common-lisp.net/project/iterate/">Iterate</a> library is pretty awesome. It provides a macro <strong>iterate</strong> (and an alias for it, <strong>iter</strong>) that is basically a Lispy version of <strong>loop</strong>. The most obvious consequence of this is that <strong>iterate</strong> uses a lot more parens than <strong>loop</strong> does:</p>
<pre class="brush: plain; title: ; notranslate" title="">
;; Loop code
(loop for i from 1 to 10
      collect i)

;; Iterate code
(iter (for i from 1 to 10)
      (collect i))
</pre>
<p>Even though all of the extra parens make <strong>iterate</strong> much uglier than <strong>loop</strong>, they give <strong>iterate</strong> all of the advantages of Lisp syntax. One such advantage is the ability to embed <strong>iterate</strong> clauses within Lisp code and vice versa. While you can&#8217;t do this with <strong>loop</strong>, you can do it with <strong>iterate</strong> because the syntax of <strong>iterate</strong> is so similar to the syntax of ordinary Lisp code. Here is what happens when you try to embed a <strong>collect</strong> clause within Lisp code with <strong>loop</strong> and with <strong>iterate</strong>:<span id='easy-footnote-1' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../2016/01/12/loops-in-lisp-part-3-iterate/index.html#easy-footnote-bottom-1' title='It is possible to write a valid version of the loop code below by using the version of &#8216;when&#8217; provided by loop. Although that trick works for this specific case, it doesn&#8217;t allow for the use of arbitrary Lisp expressions like iterate does.'><sup>1</sup></a></span></p>
<pre class="brush: plain; title: ; notranslate" title="">
;; Not valid loop code.
(loop for i from 1 to 10
      do (when (evenp i)
           (collect i)))

;; Valid iterate code
(iter (for i from 1 to 10)
      (when (evenp i)
        (collect i)))
</pre>
<p>Although the ability to seamlessly go between Lisp code and <strong>iterate</strong> is pretty awesome, the greatest feature provided by <strong>iterate</strong> is also the entire reason why Lisp syntax has so many parens in the first place. Lisp syntax (and by extension <strong>iterate</strong>) makes it easy to write macros! Because of this, you can add pretty much any feature you want to <strong>iterate</strong>. As a simple example, here&#8217;s how you could define an <strong>iterate</strong> clause specifically for looping over the digits of a number:<span id='easy-footnote-2' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../2016/01/12/loops-in-lisp-part-3-iterate/index.html#easy-footnote-bottom-2' title='Defmacro-clause is a macro provided by Iterate that can be used to define new iterate clauses.'><sup>2</sup></a></span></p>
<pre class="brush: plain; title: ; notranslate" title="">
(defun digits (n)
  &quot;Returns a list of the digits of N.&quot;
  (map 'list #'digit-char-p (princ-to-string n)))

(defmacro-clause (for var in-digits-of n)
  `(for ,var in (digits ,n)))
</pre>
<p>And here is how you would use it:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(iter (for i in-digits-of 123)
      (sum i))
=&gt; 6
</pre>
<p>I cannot express how awesome this is. If you want an <strong>iterate</strong> clause for iterating over SQL queries, you can add <a href="https://common-lisp.net/project/iterate-clsql/">it</a>. If you want an <strong>iterate</strong> clause for looping over your own custom data structure, you can add it. You can add any feature you want all because <strong>iterate</strong> allows for the use of macros!</p>
<p>Personally, I prefer to use <strong>iterate</strong> over <strong>loop</strong>. Even though it is uglier, it is much more extensible than <strong>loop</strong> because it decides to use a Lisp like syntax.</p>
					</div><!-- .entry-content -->
				<div class="entry-meta clear">
			<span class="posted-on">Posted on <a href="../../2016/01/12/loops-in-lisp-part-3-iterate/index.html" rel="bookmark"><time class="entry-date published" datetime="2016-01-12T12:00:11+00:00">January 12, 2016</time><time class="updated" datetime="2016-01-12T02:00:56+00:00">January 12, 2016</time></a></span><span class="byline"> by <span class="author vcard"><a class="url fn n" href="../../author/malisper/index.html">malisper</a></span></span>			<span class="secondary-entry-meta">
																	<span class="comments-link"><a href="../../2016/01/12/loops-in-lisp-part-3-iterate/index.html#comments">3</a></span>							</span>
		</div><!-- .entry-meta -->
	</article><!-- #post-## -->

				
					
<article id="post-270" class="post-270 post type-post status-publish format-standard hentry category-advanced-macros">
	<header class="entry-header">
					<h1 class="entry-title"><a href="../../2015/09/22/getting-places/index.html" rel="bookmark">Getting Places</a></h1>			</header><!-- .entry-header -->
			<div class="entry-content">
			<p><em>This post will serve as an introduction to writing macros that work with places. I will refer back to it whenever I examine a macro which deals with places.</em></p>
<p>Places are an incredible part of Common Lisp. In short, a &#8220;place&#8221; is any location that can hold a value. The obvious example of a place is a variable. Less obvious examples include the elements of an array, or the slots of an object. What makes the concept of places special is that Common Lisp provides a standard interface for reading and writing to them. You can write macros on top of this interface that work for every kind of place. As an example, look at the macro <strong>incf</strong>. It takes a place as an argument, adds one to its value, and stores the new value back into the place. If you want to increment a variable <em>x,</em> you would use:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(incf x)
</pre>
<p>And if you wanted to increment the element at index <em>x</em> of a sequence, you would use:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(incf (elt seq x))
</pre>
<p>They use the exact same syntax even though a variable is very different from an element of a sequence. Because it takes advantage of the interface for places, <strong>incf</strong> will work on any place, be it a variable, the slot of an object, or a user defined place.</p>
<p>So at this point you are probably wondering how does <strong>incf</strong> work and more generally, how do you write macros that use places? To write such a macro, you need to use the function <strong>get-setf-expansion</strong>.<span id='easy-footnote-1' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../2015/09/22/getting-places/index.html#easy-footnote-bottom-1' title='There is an easier way through the macro define-modify-macro, but that only works in a few basic cases.'><sup>1</sup></a></span> <strong>Get-setf-expansion</strong> takes an expression representing a place and returns a total of five values (if you are unfamiliar with multiple values, see my post on <a href="../../2015/06/30/multiple-value-bind/index.html">multiple-value-bind</a>). Altogether, these five values tell you everything you need to know about the place in order to read and write to it.</p>
<p>To show you how you are supposed to use <strong>get-setf-expansion</strong>, I&#8217;m first going to demonstrate how you could use it to write the expansion of <strong>incf</strong> by hand. After that, I will show code that will automate this, which winds up being an implementation of <strong>incf</strong>. Let&#8217;s start by writing the expansion of the example above. The one where the element of a sequence is being incremented. To write the expansion of that by hand, you would first call <strong>get-setf-expansion</strong> to obtain all of the information:<span id='easy-footnote-2' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../2015/09/22/getting-places/index.html#easy-footnote-bottom-2' title='You are actually supposed to call get-setf-expansion with an environment object so that locally defined macros can be expanded properly. An environment object can be obtained through the &amp;environment keyword in a macro argument list. For the sake of simplicity, I will be ignoring the environment object.'><sup>2</sup></a></span></p>
<pre class="brush: plain; title: ; notranslate" title="">
(get-setf-expansion '(elt seq x))
</pre>
<p>In SBCL this call will return the following values:</p>
<pre class="brush: plain; title: ; notranslate" title="">
;; (1) temps
(#:seq1017 #:x1016)

;; (2) exprs
(seq x) 

;; (3) stores
(#:new1015) 

;; (4) store-expr
(sb-kernel:%setelt #:seq1017 #:x1016 #:new1015) 

;; (5) access-expr
(elt #:seq1017 #:x1016))
</pre>
<p>From now on, I will refer to each value returned by <strong>get-setf-expansion</strong> by the name in the comment before it (e.g. <em>temps</em> refers to the first value).</p>
<p>In order to uniquely identify the element of a sequence (the place we are working with in this example), you need two things. You need the sequence itself and the index into the sequence. That is exactly what the two expressions in <em>exprs</em> evaluate to! Since <strong>incf</strong> needs to use these values multiple times, the two values have to be bound to gensyms in order to prevent multiple evaluation (see my post on <a href="../../2015/06/06/once-only/index.html">once-only</a> for why multiple evaluation is a problem). You are supposed to bind the values of the expressions to the gensyms in <em>temps</em> so that the other expressions returned by <strong>get-setf-expansion</strong> can use those gensyms to easily determine the place being worked with. The bindings need to be made with <strong>let*</strong> because it is possible for an expression in <em>exprs</em> to refer to the value of a previous expression in <em>exprs</em>. So the first part of the expansion will bind all of the symbols in <em>temps</em> to values of the expressions in <em>exprs</em> with <strong>let*</strong>:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(let* ((#:seq1017 seq) (#:x1016 x))
  ...)
</pre>
<p>Now the gensyms in <em>temps</em> can be used to uniquely identify the place. As I mentioned previously, the other expressions can now easily determine the place through the gensyms. For example, <em>access-expr</em> can be used to retrieve the value currently in the place. Since the place we are dealing with is the element of a sequence,  <em>access-expr</em> is just a call to <strong>elt</strong> using the gensyms in <em>temps</em> as the arguments. We are going to use <em>access-expr</em> in a moment, but first I have to talk about how to write to the place.</p>
<p>In order to write to the place, you need to use <em>stores</em> and <em>store-expr</em>. <em>Stores</em> is a list of gensyms that need to be bound to the values that are to be stored in the place (it is possible for a single place to hold multiple values).  In this case we want to bind the gensym in <em>stores</em> to one plus the value already in the place. We can easily obtain the value in the place through <i>access-expr</i>. Once the gensyms have been bound, you can use <em>store-expr</em> to actually write the values in <em>stores</em> to the place. Notice how <em>store-expr</em> is a call to an internal SBCL function <strong>sb-kernel:setelt%</strong> that uses the gensyms in <em>temps</em> and <em>stores</em> as arguments. Presumably <strong>sb-kernel:setelt%</strong> sets the element of a sequence. After adding the binding for the gensym in <em>stores</em> and <em>store-expr</em>, we wind up with the final expansion which looks like:<span id='easy-footnote-3' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../2015/09/22/getting-places/index.html#easy-footnote-bottom-3' title='If you try to evaluate the code, there are two things you have to. First you have to make sure you are using SBCL because sb-kernel:%setelt is a function specific to SBCL. Second, you have to remove the &#8216;#:&#8217; from all of the symbols that use it because every use of #: creates a new symbol.'><sup>3</sup></a></span></p>
<pre class="brush: plain; title: ; notranslate" title="">
(let* ((#:seq1017 seq) 
       (#:x1016 x) 
       (#:new1015 (+ 1 (elt #:seq1017 #:x1016))))
  (sb-kernel:%setelt #:seq1017 #:x1016 #:new1015))
 </pre>
<p>To review, the above code first binds the gensyms in <em>temps</em> to the values of the expressions in <em>exprs</em>. This allows <i>access-expr</i> and <em>store-expr</em> to use the gensyms in <em>temps</em> in order to determine the place being worked with. Then the code uses <em>access-expr</em> to retrieve the value, adds one to that, and binds that value to the gensym in <em>stores</em>. This is because the value of the gensym in <em>stores</em> is ultimately going to be the one written to the place. Finally the code evaluates <em>store-expr</em> in order to actually store the value in the gensym into the place.</p>
<p>Now here is one possible implementation of <strong>incf</strong>,<span id='easy-footnote-4' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../2015/09/22/getting-places/index.html#easy-footnote-bottom-4' title='As I mentioned in a previous footnote, you are actually supposed to pass get-setf-expansion an environment object'><sup>4</sup></a></span> which is code for everything we just did by hand. I called it <strong>incf%</strong> so that it doesn&#8217;t have the same name as the builtin version.</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defmacro incf% (place)
  (multiple-value-bind
        (temps exprs stores store-expr access-expr)
      (get-setf-expansion place)
    `(let* (,@(mapcar #'list temps exprs)
            (,(car stores) (+ 1 ,access-expr)))
       ,store-expr)))
</pre>
<p>The above code first binds the five values returned by <strong>get-setf-expansion</strong> to variables. It then generates a <strong>let*</strong> binding which binds the symbols in <em>temps</em> to the expressions in <em>exprs</em> and also binds the gensym in <em>stores</em> to one plus the result of evaluating <em>access-expr</em>. Finally the above code splices in <em>store-expr</em> to actually write the value. And that is everything there is to <strong>incf</strong>.</p>
<p><b>Incf</b> is but a single example of what can be done with places. In the next couple of posts, I plan to cover some really cool macros that encapsulate a bunch of common patterns related to places.</p>
					</div><!-- .entry-content -->
				<div class="entry-meta clear">
			<span class="posted-on">Posted on <a href="../../2015/09/22/getting-places/index.html" rel="bookmark"><time class="entry-date published" datetime="2015-09-22T18:00:58+00:00">September 22, 2015</time><time class="updated" datetime="2015-09-20T14:12:49+00:00">September 20, 2015</time></a></span><span class="byline"> by <span class="author vcard"><a class="url fn n" href="../../author/malisper/index.html">malisper</a></span></span>			<span class="secondary-entry-meta">
																	<span class="comments-link"><a href="../../2015/09/22/getting-places/index.html#comments">3</a></span>							</span>
		</div><!-- .entry-meta -->
	</article><!-- #post-## -->

				
					
<article id="post-831" class="post-831 post type-post status-publish format-standard hentry category-advanced-macros">
	<header class="entry-header">
					<h1 class="entry-title"><a href="../../2015/09/08/defasm/index.html" rel="bookmark">Defasm</a></h1>			</header><!-- .entry-header -->
			<div class="entry-content">
			<p><em>This post is the second part of a two part series exploring the emulator <a href="https://github.com/kingcons/cl-6502">cl-6502</a>. If you haven&#8217;t read the first part exploring the implementation of addressing modes in cl-6502, you can find it <a href="../../2015/08/27/defaddress/index.html">here</a>.</em></p>
<p>This post is going to go over how cl-6502 implements the instruction set of the 6502. Most of the work in defining the instruction set is done by a single macro, <strong>defasm</strong>. But before I can go into the details of <strong>defasm</strong>, I have to explain how cl-6502 represents instructions.</p>
<p>cl-6502 represents each instruction as a function inside an array called <em>*array-funs*</em>. The function for a specific instruction is indexed by that instruction&#8217;s opcode.<span id='easy-footnote-1' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../2015/09/08/defasm/index.html#easy-footnote-bottom-1' title='If you don&#8217;t know, the opcode is the byte used in machine code to represent the instruction.'><sup>1</sup></a></span> To execute an instruction, cl-6502 looks up the opcode of the current instruction and calls the function at that location inside of <em>*array-funs*</em>. There is also a second array, <em>*opcode-metadata*,</em> which keeps track of some metadata about each instruction such as the number of bytes each one takes up. All <strong>d</strong><strong>efasm</strong> does is make it easy to generate all of the functions and metadata that wind up inside of those two arrays.</p>
<p>To show you just how easy it is to implement instructions with <strong>defasm</strong>, here is the implementation of the adc (add with carry) instruction:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defasm adc (:docs &quot;Add to Accumulator with Carry&quot;)
    ((#x61 6 2 indirect-x)
     (#x65 3 2 zero-page)
     (#x69 2 2 immediate)
     (#x6d 4 3 absolute)
     (#x71 5 2 indirect-y)
     (#x75 4 2 zero-page-x)
     (#x79 4 3 absolute-y)
     (#x7d 4 3 absolute-x))

  (let ((result (+ (cpu-ar cpu) 
                   (getter) 
                   (status-bit :carry))))
    (set-flags-if 
      :carry (&gt; result #xff)
      :overflow (overflow-p result (cpu-ar cpu) (getter))
      :negative (logbitp 7 result)
      :zero (zerop (wrap-byte result)))
    (setf (cpu-ar cpu) (wrap-byte result))))
</pre>
<p>There are two main parts to the above code. The first part specifies all of the addressing modes the instruction is compatible with along with the metadata for each variant of the instruction (there is a different version of the instruction for every possible addressing mode the instruction can be used with).</p>
<p>After that is the body &#8211; the code that actually implements the instruction being defined. The body is responsible for setting all of the appropriate flags and memory locations to the values they should have after executing the instruction. Make sure you note that just like in <strong>defaddress</strong>, the variable <em>cpu</em> can be used in the body to reference an object that represents the current state of the cpu.</p>
<p><b>Defasm</b> takes these two pieces, and generates one lambda expression for each variant of the instruction. All of the generated lambda expressions use the same body, except <strong>defasm</strong> generates some additional code that allows the body to work across all of the different addressing modes.</p>
<p>Now to get into the specifics of the DSL. In the addressing mode part of the DSL, there are four pieces of metadata that need to be associated with each version of the instruction. The first part is the opcode, the machine code representation of the instruction. Next up is the number of cycles it takes for the instruction to execute. After that is the size of the instruction, the number of bytes it takes up in memory. Last is the name of the addressing mode used for that specific variant of the instruction. As an example, here is the metadata for the adc instruction in the indirect-x addressing mode:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(#x61 6 2 indirect-x)
</pre>
<p>What it is saying is that this version of the instruction has the opcode #x61, takes six cycles to run, takes two bytes in memory, and uses the indirect-x addressing mode. The fact that when an instruction is used in different addressing modes, it uses a different number of clock cycles and takes up a different amount of space is one reason why different addressing modes are provided in assembly language.</p>
<p>For the body, <strong>defasm</strong> does something very clever to have the body work for every possible addressing modes. Within the body, the functions <b>getter</b> and <strong>setter</strong> are bound to local functions that can be used to obtain and modify the argument to the instruction. For each variant of the instruction, <strong>defasm</strong> generates the definition of these two functions differently so that they will always calculate the correct argument for the given addressing mode.</p>
<p>For example, in the version of adc that uses immediate addressing, <strong>getter</strong> will just return the value of the operand, but in the version that uses absolute addressing, <b>getter</b> will use the operand as an address and look up the value at that location in memory. In the definition of the adc instruction above, the body uses <strong>getter</strong> to obtain the argument, adds that to the value in the accumulator, adds in the carry, and then sets all of the appropriate flags and registers depending on the final value it winds up with. Since <strong>getter</strong> and <strong>setter</strong> work across all of the different addressing modes, so does the body!</p>
<p>Now let&#8217;s look at the actual implementation of <strong>defasm</strong>:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defmacro defasm (name (&amp;key (docs &quot;&quot;) raw-p (track-pc t))
                  modes &amp;body body)
  `(progn

     ,@(loop for (op cycles bytes mode) in modes collect
         `(setf (aref *opcode-meta* ,op) 
                ',(list name docs cycles bytes mode)))

     ,@(loop for (op cycles bytes mode) in modes collect
         `(setf (aref *opcode-funs* ,op)
                (lambda (cpu)
                  (incf (cpu-pc cpu))
                  (flet ((getter ()
                           ,(make-getter name mode raw-p))
                         (setter (x)
                           (setf (,mode cpu) x)))
                    ,@body)
                  ,@(when track-pc
                     `((incf (cpu-pc cpu) ,(1- bytes))))
                  (incf (cpu-cc cpu) ,cycles))))))
</pre>
<p>As usual, I&#8217;m going to show a snippet of the implementation of <strong>defasm</strong> and then show what the macroexpansion of that piece looks like. The first part of the implementation handles the addressing modes and metadata:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(loop for (op cycles bytes mode) in modes collect
  `(setf (aref *opcode-meta* ,op) 
         ',(list name docs cycles bytes mode)))
</pre>
<p>For each addressing mode, this generates code which will store a list containing the metadata into the proper place in the <em>*opcode-meta*</em> array. In other words it takes each part that looks like:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(#x61 6 2 indirect-x)
</pre>
<pre>and generates code that looks like:</pre>
<pre class="brush: plain; title: ; notranslate" title="">
(setf (aref *opcode-meta* #x61)
     '(adc &quot;Add to accumulator with carry&quot; 6 2 indirect-x))
</pre>
<p>After that we have the part that will generate the actual lambda expressions for the functions that will be stored in <em>*array-funs*</em>:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(loop for (op cycles bytes mode) in modes collect
  `(setf (aref *opcode-funs* ,op)
         (lambda (cpu)
           (incf (cpu-pc cpu))
           (flet ((getter ()
                   ,(make-getter name mode raw-p))
                 (setter (x)
                   (setf (,mode cpu) x)))
             ,@body)
          ,@(when track-pc
              `((incf (cpu-pc cpu) ,(1- bytes))))
          (incf (cpu-cc cpu) ,cycles))))
</pre>
<p>This code loops over all of the metadata for the different addressing modes and uses this information to generate the expression for each variant of the instruction. As mentioned previously, the function will be stored by the variant&#8217;s opcode. As for the actual function itself, it does something along these lines. First, it advances the pc. This is done so that the pc now points to the operand of the instruction. By doing this, the job of <strong>defaddress</strong> becomes much easier since it can use the pc as a pointer to the operand. Next, the function evaluates the body in an environment with <strong>getter</strong> and <strong>setter</strong> bound to functions that can be used to read and write to the argument. After that it will advance the pc forward to the next instruction (unless <em>track-pc</em> was false, which happens for instructions that modify the pc themselves such as jumps). Finally, the function will increment the cycle count by the number of cycles it takes the instruction to execute.</p>
<p>The definitions of <strong>getter</strong> and <strong>setter</strong> are really just calls to the function with the same name as the addressing mode associated with the variant of the instruction.<span id='easy-footnote-2' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../2015/09/08/defasm/index.html#easy-footnote-bottom-2' title='Getter actually uses a function make-getter along with the raw-p argument. This is just to smooth out some differences between instructions.'><sup>2</sup></a></span> If you look back at the last post, you will see that <strong>defaddress</strong> automatically generates these &#8220;mode&#8221; functions. All they do is calculate the effective argument for the given addressing mode! Exactly what <strong>getter</strong> does. As an example of what the expansion looks like, here is the lambda expression generated for the adc instruction in the indirect-x addressing mode.</p>
<pre class="brush: plain; title: ; notranslate" title="">
(setf (aref *opcode-funs* #x61)
      (lambda (cpu)
        (incf (cpu-pc cpu))
        (flet ((getter ()
                 (get-byte (indirect-x cpu)))
               (setter (x)
                 (setf (indirect-x cpu) x)))
         (let ((result (+ (cpu-ar cpu) 
                          (getter) 
                          (status-bit :carry))))
          (set-flags-if :carry (&gt; result 255) 
                        :overflow (overflow-p result 
                                              (cpu-ar cpu)
                                              (getter))
                        :negative (logbitp 7 result) 
                        :zero (zerop (wrap-byte result)))
          (setf (cpu-ar cpu) (wrap-byte result))))
        (incf (cpu-pc cpu) 1)
        (incf (cpu-cc cpu) 6)))
</pre>
<p>And that&#8217;s all there is to <strong>defasm</strong>! There are a couple really cool things you should note about cl-6502. First off, the macros expand into a lot of code. The definition of adc at the beginning of this post expands into roughly 500 lines of code. <a href="https://gist.github.com/malisper/610f691e7b3919d6a421">Here</a> is a link to a gist of it if you want to see it. More incredibly, cl-6502 implements an entire emulator in under 1000 lines of code. cl-6502 is a fantastic example of how effective macros are at creating concise DSLs.</p>
					</div><!-- .entry-content -->
				<div class="entry-meta clear">
			<span class="posted-on">Posted on <a href="../../2015/09/08/defasm/index.html" rel="bookmark"><time class="entry-date published" datetime="2015-09-08T12:48:05+00:00">September 8, 2015</time><time class="updated" datetime="2015-10-11T23:06:33+00:00">October 11, 2015</time></a></span><span class="byline"> by <span class="author vcard"><a class="url fn n" href="../../author/malisper/index.html">malisper</a></span></span>			<span class="secondary-entry-meta">
																	<span class="comments-link"><a href="../../2015/09/08/defasm/index.html#comments">2</a></span>							</span>
		</div><!-- .entry-meta -->
	</article><!-- #post-## -->

				
					
<article id="post-173" class="post-173 post type-post status-publish format-standard hentry category-advanced-macros">
	<header class="entry-header">
					<h1 class="entry-title"><a href="../../2015/06/10/cl-who/index.html" rel="bookmark">CL-WHO</a></h1>			</header><!-- .entry-header -->
			<div class="entry-content">
			<p>The <a href="http://weitz.de/cl-who/">CL-WHO</a> library is one of many that make it easy to generate HTML. When first checking out CL-WHO, I thought that it must be at least a couple thousand lines of code long. As it turns out, it is only several hundred. At the core of CL-WHO is <strong>with-html-output</strong> (hence the name &#8220;who&#8221;), which allows one to use a DSL for generating HTML. <strong>With-html-output</strong> works like all macros. At a high level, it takes your code in the DSL, and compiles it into Lisp code that will generate the desired HTML (<a href="http://weitz.de/cl-who/#example">here</a> are some examples).</p>
<p><strong>With-html-output</strong> does little by itself. Almost all of the work is done by three functions: <strong>tree-to-template</strong>, <strong>process-tag</strong>, and <strong>convert-tag-to-string-list</strong>. Most of the time these functions call one another recursively in order to process the entire DSL. It is possible to customize the control flow, but I will get to that later. <a href="https://gist.github.com/malisper/fe2cf8158714c196ec03">Here</a> is a link to a gist of the output after tracing all of the functions and using <strong>macroexpand-1</strong> to expand a simple example. The example only shows what happens when using basic tags in CL-WHO. It doesn&#8217;t show what happens when you embed Lisp expressions in the DSL.</p>
<p><strong>Tree-to-template</strong> is the entry point into the compilation process. It loops through the DSL tree, and builds up a &#8220;template&#8221;. A template is just a list of strings and expressions. The strings in the template contain HTML and are meant to be printed directly to the HTML stream. On the other hand, the expressions contain code that will print objects to that stream. Eventually all of this output put together will be the desired HTML. As <strong>tree-to-template</strong> loops through the code, if it sees a non-tag, it will just collect that into the list.<span id='easy-footnote-1' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../2015/06/10/cl-who/index.html#easy-footnote-bottom-1' title='It actually wraps it with a let that binds *indent* in order to handle indentation properly.'><sup>1</sup></a></span> When it does see a tag, <strong>tree-to-template</strong> calls <strong>process-tag</strong> to process it, and then concatenates the result of that into the template.</p>
<p><strong>Process-tag</strong> will extract the tag as well as the attribute list. Everything after the attribute list makes up the &#8220;body&#8221; of the tag. How is the body processed? Well, <strong>process-tag</strong> takes an additional argument, <em>body-fn</em>, which specifies how to process the body. <strong>Process-tag</strong> will then call <strong>convert-tag-to-string-list</strong> with the tag, the attribute list, the body, and <em>body-fn</em>. The reason <strong>process-tag</strong> doesn&#8217;t process the body itself is that <strong>convert-tag-to-string-list</strong> is a generic function, making it possible to customize its behavior.</p>
<p><strong>Convert-tag-to-string-list</strong> handles the semantics of the tag. It takes all of the arguments above and returns a list of strings and expressions. That list will become part of the template eventually returned by <strong>tree-to-template</strong>. Since <strong>c</strong><strong>onvert-tag-to-string-list</strong> is a generic function, it is possible to extend it. The documentation for CL-WHO gives an example of how one could create a custom &#8220;red&#8221; tag which changes the font of the text to red, even though there is no such HTML tag. In the default case, <strong>convert-tag-to-string-list</strong> takes the result from calling <em>body-fn</em> on <em>body</em> and surrounds that with strings for the opening and closing tags. Since <b>convert-tag-to-string-list</b> is customizable, it is possible to change the control flow and ultimately how the body is processed. If one wanted, they could make a call to <strong>process-tag</strong>, but with a different <em>body-fn</em> argument, changing how the code is processed further up (down?) the tree.</p>
<p>With the help of these functions <strong>with-html-output</strong> converts the DSL into a template. The template is then turned into a list of valid Lisp code.<span id='easy-footnote-2' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../2015/06/10/cl-who/index.html#easy-footnote-bottom-2' title='The first thing with-html-output does is pass the DSL tree to tree-to-commands. Tree-to-commands is the function that handles the entire process of converting the tree into valid Lisp code. Tree-to-commands just calls tree-to-template to do most of the work.'><sup>2</sup></a></span> <strong>With-html-output</strong> then wraps the body with a <strong>macrolet</strong> which binds several local macros. These macros are: <strong>htm, fmt, esc, str</strong>. These macros make it easier to print objects to the stream used for output. Check out the documentation for CL-WHO for a more detailed description of what these macros do.</p>
<p>I really like CL-WHO. It is a great example of an embedded DSL. A Lisp hacker still has full access to Lisp from within what is a great DSL. The only problem I have with CL-WHO is the inability to have macros expand into code for the DSL. This decreases the flexibility of CL-WHO somewhat. The only way I can see to fix this problem would be to use a library such as :hu.dwim.walker to expand all of the macros in advance.</p>
					</div><!-- .entry-content -->
				<div class="entry-meta clear">
			<span class="posted-on">Posted on <a href="../../2015/06/10/cl-who/index.html" rel="bookmark"><time class="entry-date published" datetime="2015-06-10T10:31:01+00:00">June 10, 2015</time><time class="updated" datetime="2015-07-04T15:55:37+00:00">July 4, 2015</time></a></span><span class="byline"> by <span class="author vcard"><a class="url fn n" href="../../author/malisper/index.html">malisper</a></span></span>			<span class="secondary-entry-meta">
																	<span class="comments-link"><a href="../../2015/06/10/cl-who/index.html#respond">0</a></span>							</span>
		</div><!-- .entry-meta -->
	</article><!-- #post-## -->

				
			
		
		</main><!-- #main -->
	</section><!-- #primary -->


	</div><!-- #content -->

	<footer id="colophon" class="site-footer" role="contentinfo">
		<div class="site-info">
			<a href="http://wordpress.org/">Proudly powered by WordPress</a>
			<span class="sep"> ~ </span>
			Theme: Scrawl by <a href="https://wordpress.com/themes/" rel="designer">WordPress.com</a>.		</div><!-- .site-info -->
	</footer><!-- #colophon -->
</div><!-- #page -->

<script type='text/javascript' src='../../wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shCore09b1.js?ver=3.0.9b'></script>
<script type='text/javascript' src='../../wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shBrushPlain09b1.js?ver=3.0.9b'></script>
<script type='text/javascript'>
	(function(){
		var corecss = document.createElement('link');
		var themecss = document.createElement('link');
		var corecssurl = "../../wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shCore09b1.css?ver=3.0.9b";
		if ( corecss.setAttribute ) {
				corecss.setAttribute( "rel", "stylesheet" );
				corecss.setAttribute( "type", "text/css" );
				corecss.setAttribute( "href", corecssurl );
		} else {
				corecss.rel = "stylesheet";
				corecss.href = corecssurl;
		}
		document.getElementsByTagName("head")[0].insertBefore( corecss, document.getElementById("syntaxhighlighteranchor") );
		var themecssurl = "../../wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shThemeEclipse09b1.css?ver=3.0.9b";
		if ( themecss.setAttribute ) {
				themecss.setAttribute( "rel", "stylesheet" );
				themecss.setAttribute( "type", "text/css" );
				themecss.setAttribute( "href", themecssurl );
		} else {
				themecss.rel = "stylesheet";
				themecss.href = themecssurl;
		}
		//document.getElementById("syntaxhighlighteranchor").appendChild(themecss);
		document.getElementsByTagName("head")[0].insertBefore( themecss, document.getElementById("syntaxhighlighteranchor") );
	})();
	SyntaxHighlighter.config.strings.expandSource = '+ expand source';
	SyntaxHighlighter.config.strings.help = '?';
	SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
	SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
	SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
	SyntaxHighlighter.defaults['pad-line-numbers'] = false;
	SyntaxHighlighter.defaults['toolbar'] = false;
	SyntaxHighlighter.all();
</script>
<link rel='stylesheet' id='qtipstyles-css'  href='../../wp-content/plugins/easy-footnotes/assets/qtip/jquery.qtip.min167b.css?ver=4.6' type='text/css' media='' />
<link rel='stylesheet' id='easyfootnotescss-css'  href='../../wp-content/plugins/easy-footnotes/assets/easy-footnotes167b.css?ver=4.6' type='text/css' media='' />
<link rel='stylesheet' id='dashicons-css'  href='../../wp-includes/css/dashicons.min167b.css?ver=4.6' type='text/css' media='all' />
<script type='text/javascript' src='../../wp-content/themes/scrawl-wpcom/js/scrawld56c.js?ver=20150309'></script>
<script type='text/javascript' src='../../wp-content/themes/scrawl-wpcom/js/skip-link-focus-fix08e0.js?ver=20130115'></script>
<script type='text/javascript' src='../../wp-includes/js/wp-embed.min167b.js?ver=4.6'></script>
<script type='text/javascript' src='../../wp-includes/js/imagesloaded.min55a0.js?ver=3.2.0'></script>
<script type='text/javascript' src='../../wp-content/plugins/easy-footnotes/assets/qtip/jquery.qtip.min167b.js?ver=4.6'></script>
<script type='text/javascript' src='../../wp-content/plugins/easy-footnotes/assets/qtip/jquery.qtipcall167b.js?ver=4.6'></script>

</body>

<!-- Mirrored from malisper.me/category/advanced-macros/ by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 01 Sep 2016 17:46:31 GMT -->
</html>
<!-- Dynamic page generated in 0.113 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2016-09-01 12:22:26 -->

<!-- super cache -->