<!DOCTYPE html>
<html lang="en-US" prefix="og: http://ogp.me/ns#">

<!-- Mirrored from malisper.me/category/loops-in-lisp/ by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 01 Sep 2016 17:46:31 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Loops in Lisp Archives - Macrology</title>
<link rel="profile" href="http://gmpg.org/xfn/11">
<link rel="pingback" href="../../xmlrpc.php">


<!-- This site is optimized with the Yoast SEO plugin v3.4.2 - https://yoast.com/wordpress/plugins/seo/ -->
<link rel="canonical" href="index.html" />
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="object" />
<meta property="og:title" content="Loops in Lisp Archives - Macrology" />
<meta property="og:url" content="index.html" />
<meta property="og:site_name" content="Macrology" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Loops in Lisp Archives - Macrology" />
<!-- / Yoast SEO plugin. -->

<link rel='dns-prefetch' href='http://fonts.googleapis.com/'>
<link rel="alternate" type="application/rss+xml" title="Macrology &raquo; Feed" href="../../feed/index.html" />
<link rel="alternate" type="application/rss+xml" title="Macrology &raquo; Comments Feed" href="../../comments/feed/index.html" />
<link rel="alternate" type="application/rss+xml" title="Macrology &raquo; Loops in Lisp Category Feed" href="feed/index.html" />
<link rel='stylesheet' id='scrawl-style-css'  href='../../wp-content/themes/scrawl-wpcom/style167b.css?ver=4.6' type='text/css' media='all' />
<link rel='stylesheet' id='scrawl-fonts-css'  href='https://fonts.googleapis.com/css?family=Lora:400,700|Merriweather:400italic,400,700,700italic&amp;subset=latin%2Clatin-ext' type='text/css' media='all' />
<link rel='stylesheet' id='genericons-css'  href='../../wp-content/themes/scrawl-wpcom/fonts/genericons6de8.css?ver=3.3' type='text/css' media='all' />
<script type='text/javascript' src='../../wp-includes/js/jquery/jqueryb8ff.js?ver=1.12.4'></script>
<script type='text/javascript' src='../../wp-includes/js/jquery/jquery-migrate.min330a.js?ver=1.4.1'></script>
<link rel='https://api.w.org/' href='../../wp-json/index.html' />
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="../../xmlrpc0db0.php?rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="../../wp-includes/wlwmanifest.xml" /> 
<meta name="generator" content="WordPress 4.6" />
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-63547056-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
<style type="text/css" id="syntaxhighlighteranchor"></style>

<script type="text/javascript">
  window.heap=window.heap||[],heap.load=function(e,t){window.heap.appid=e,window.heap.config=t=t||{};var n=t.forceSSL||"https:"===document.location.protocol,a=document.createElement("script");a.type="text/javascript",a.async=!0,a.src=(n?"https:":"http:")+"//cdn.heapanalytics.com/js/heap-"+e+".js";var o=document.getElementsByTagName("script")[0];o.parentNode.insertBefore(a,o);for(var r=function(e){return function(){heap.push([e].concat(Array.prototype.slice.call(arguments,0)))}},p=["clearEventProperties","identify","setEventProperties","track","unsetEventProperty"],c=0;c<p.length;c++)heap[p[c]]=r(p[c])};
    heap.load("931515525");
</script>
</head>

<body class="archive category category-loops-in-lisp category-8">
	<button class="menu-toggle x">
		<span class="lines"></span>
		<span class="screen-reader-text">Primary Menu</span>
	</button>
	<div class="slide-menu">
				
		<h1 class="site-title"><a href="../../index.html" rel="home">Macrology</a></h1>
		<h2 class="site-description">Case Studies in Lisp Macros</h2>
		
				
				
			<div id="secondary" class="widget-area" role="complementary">
		<aside id="search-2" class="widget widget_search"><form role="search" method="get" class="search-form" action="http://malisper.me/">
				<label>
					<span class="screen-reader-text">Search for:</span>
					<input type="search" class="search-field" placeholder="Search &hellip;" value="" name="s" />
				</label>
				<input type="submit" class="search-submit" value="Search" />
			</form></aside><aside id="pages-3" class="widget widget_pages"><h1 class="widget-title">Pages</h1>		<ul>
			<li class="page_item page-item-55"><a href="../../about-me/index.html">About Michael Malis</a></li>
<li class="page_item page-item-44"><a href="../../about-this-site-2/index.html">About This Site</a></li>
		</ul>
		</aside><aside id="nav_menu-3" class="widget widget_nav_menu"><h1 class="widget-title">Contact Me</h1><div class="menu-contact-me-container"><ul id="menu-contact-me" class="menu"><li id="menu-item-60" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-60"><a href="mailto:michaelmalis2@gmail.com">Email</a></li>
<li id="menu-item-58" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-58"><a href="https://github.com/malisper">Github</a></li>
<li id="menu-item-59" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-59"><a href="https://news.ycombinator.com/user?id=malisper">Hacker News</a></li>
</ul></div></aside><aside id="archives-2" class="widget widget_archive"><h1 class="widget-title">Archives</h1>		<ul>
			<li><a href='../../2016/06/index.html'>June 2016</a></li>
	<li><a href='../../2016/04/index.html'>April 2016</a></li>
	<li><a href='../../2016/01/index.html'>January 2016</a></li>
	<li><a href='../../2015/12/index.html'>December 2015</a></li>
	<li><a href='../../2015/11/index.html'>November 2015</a></li>
	<li><a href='../../2015/10/index.html'>October 2015</a></li>
	<li><a href='../../2015/09/index.html'>September 2015</a></li>
	<li><a href='../../2015/08/index.html'>August 2015</a></li>
	<li><a href='../../2015/07/index.html'>July 2015</a></li>
	<li><a href='../../2015/06/index.html'>June 2015</a></li>
	<li><a href='../../2015/05/index.html'>May 2015</a></li>
		</ul>
		</aside><aside id="categories-2" class="widget widget_categories"><h1 class="widget-title">Categories</h1>		<ul>
	<li class="cat-item cat-item-2"><a href="../basics/index.html" title="These are basic Lisp macros that should be trivial to understand.">Basic Macros</a>
</li>
	<li class="cat-item cat-item-5"><a href="../intermediate-macros/index.html" >Intermediate Macros</a>
</li>
	<li class="cat-item cat-item-6"><a href="../advanced-macros/index.html" >Advanced Macros</a>
</li>
	<li class="cat-item cat-item-7"><a href="../debugging-common-lisp/index.html" >Debugging Lisp</a>
</li>
	<li class="cat-item cat-item-8 current-cat"><a href="index.html" >Loops in Lisp</a>
</li>
		</ul>
</aside>	</div><!-- #secondary -->
	</div><!-- .slide-menu -->
<div id="page" class="hfeed site">
	<a class="skip-link screen-reader-text" href="#content">Skip to content</a>

	<header id="masthead" class="site-header" role="banner">

		<div class="site-branding">
						<h1 class="site-title"><a href="../../index.html" rel="home">Macrology</a></h1>
		</div>

	</header><!-- #masthead -->

	
	
	<div id="content" class="site-content">


	<section id="primary" class="content-area">
		<main id="main" class="site-main" role="main">

		
			<header class="page-header">
				<h1 class="page-title">Category: Loops in Lisp</h1>			</header><!-- .page-header -->

			
				
					
<article id="post-1366" class="post-1366 post type-post status-publish format-standard hentry category-advanced-macros category-loops-in-lisp">
	<header class="entry-header">
					<h1 class="entry-title"><a href="../../2016/04/13/loops-in-lisp-part-4-series/index.html" rel="bookmark">Loops in Lisp Part 4: Series</a></h1>			</header><!-- .entry-header -->
			<div class="entry-content">
			<p><em>This is part four of Loops in Lisp. Follow one of the following links for part <a href="../../2015/11/24/loops-lisp-part-1-goto/index.html">one</a>, <a href="../../2015/12/15/loops-in-lisp-part-2-loop/index.html">two</a>, or <a href="../../2016/01/12/loops-in-lisp-part-3-iterate/index.html">three</a>).</em></p>
<p>One of the many advantages of programming in a functional style (by this, I mean manipulating your data through the operations, map, fold, and filter) is that your program winds up being made up a bunch of tiny and composable pieces. Since each piece is so small, usually only a few lines each, it becomes trivial to unit test the entire program. Additionally, it is easy to express new features as just the composition of several existing functions. One disadvantage of programming through map and friends, is that there is fairly large time penalty for allocating the intermediate results. For example, every time filter is called on a list, a new list needs to be allocated. These costs add up pretty quickly and can make a functional program much slower than its imperative equivalent.</p>
<p>One solution to this problem is laziness. Instead of allocating a new list every time an operation is performed on a list, you instead keep track of all of the transformations made on the list. Then when you fold over the list, you perform all of the transformations as you are folding over it. By doing this, you don&#8217;t need to allocate intermediate lists. Although laziness doesn&#8217;t allocate any intermediate lists, there is still a small cost for keeping track of the laziness. An alternative solution that makes functional programming just as fast as imperative programming is provided by the Series library.<span id='easy-footnote-1' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../2016/04/13/loops-in-lisp-part-4-series/index.html#easy-footnote-bottom-1' title='The technique used by Series is sometimes referred to as &#8220;stream fusion&#8221;.'><sup>1</sup></a></span> Series lets you write your program in a functional style without <em>any</em> runtime penalty at all!</p>
<p>Personally, the Series library is my favorite example of the magic that can be pulled off with macros. In short, Series works by taking your functional code and compiling it down into a single loop. In this loop, there is one step per transformation performed on the original list. The loop iterates over the values of the original sequence on at a time. On each iteration, the loop takes a single element, performs all of the transformations performed on the list on that single element, and then accumulates that value into the result according to the folding operation. This loop requires no additional memory allocation at runtime, and their is no time penalty either! As an example, here is a program that sums the first N squares, written using Series:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defun integers ()
  &quot;Returns a 'series' of all of the natural numbers.&quot;
  (declare (optimizable-series-function))
  (scan-range :from 1))

(defun squares ()
  &quot;Returns a 'series' of all of the square numbers.&quot;
  (declare (optimizable-series-function))
  (map-fn t 
          (lambda (x) (* x x)) 
          (integers)))

(defun sum-squares (n)
  &quot;Returns the sum of the first N square numbers.&quot;
  (collect-sum (subseries (squares) 0 n)))

(sum-squares 10)
=&gt; 385
</pre>
<p>The above code certainly looks functional, there are no side effects in sight. Now let&#8217;s look at the code generated by Series. Here is what the macroexpansion of <strong>collect-sum</strong> looks like:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(common-lisp:let* ((#:out-969 n))
  (common-lisp:let ((#:numbers-966
                     (coerce-maybe-fold (- 1 1) 'number))
                    #:items-967
                    (#:index-965 -1)
                    (#:sum-959 0))
    (declare (type number #:numbers-966)
             (type (integer -1) #:index-965)
             (type number #:sum-959))
    (tagbody
       #:ll-970
       (setq #:numbers-966
             (+ #:numbers-966
                (coerce-maybe-fold 1 'number)))
       (setq #:items-967
             ((lambda (x) (* x x)) #:numbers-966))
       (incf #:index-965)
       (locally
          (declare (type nonnegative-integer #:index-965))
         (if (&gt;= #:index-965 #:out-969)
             (go end))
         (if (&lt; #:index-965 0)
             (go #:ll-970)))
       (setq #:sum-959 (+ #:sum-959 #:items-967))
       (go #:ll-970)
     end)
    #:sum-959))
</pre>
<p>What series does it looks at the entire lifetime of the sequence from its creation until it is folded. It uses this information to build the above loop which simultaneously generates the original sequence, maps over it, filters elements out of it, and folds it into the final result. Here is the breakdown of the expansion. Lines 1-9 are just initialization. They define all of the variables the loop will be using and set them to their starting values. The important variables to keep track of are #:NUMBERS-966, #:ITEMS-967, and #:SUM-959. As the code &#8220;iterates&#8221; over the original sequence, #:NUMBERS-966 is the value of the original sequence, #:ITEMS-967 is the square of that value, and #:SUM-959 is the sum of the squares so far. The rest of the code is the actual loop.</p>
<p>The loop first takes #:NUMBERS-966, the previous value of the sequence, and increments it in order to set it to current value of the sequence (since the sequence is the range from 1 to infinity). Next the loop takes the square of #:NUMBERS-966 to get the ith square number and stores that in #:ITEMS-967. Then the loop checks if it ha taken more than N elements out of the sequence, and if so, terminates. Finally the loop takes the value in #:ITEMS-967 and accumulates that into #:SUM-959.</p>
<p>Although the imperative version is equivalent to the original functional code, it is much faster than the functional code if the functional code were to allocate intermediate results or use laziness. This idea of turning transformations on a list into a loop doesn&#8217;t just work for this simple example, it also works for much more complicated programs. I just find it incredible that Series is able to take such pretty code and compile it into code that is extremely fast.</p>
					</div><!-- .entry-content -->
				<div class="entry-meta clear">
			<span class="posted-on">Posted on <a href="../../2016/04/13/loops-in-lisp-part-4-series/index.html" rel="bookmark"><time class="entry-date published" datetime="2016-04-13T03:06:36+00:00">April 13, 2016</time><time class="updated" datetime="2016-04-14T03:44:39+00:00">April 14, 2016</time></a></span><span class="byline"> by <span class="author vcard"><a class="url fn n" href="../../author/malisper/index.html">malisper</a></span></span>			<span class="secondary-entry-meta">
																	<span class="comments-link"><a href="../../2016/04/13/loops-in-lisp-part-4-series/index.html#comments">4</a></span>							</span>
		</div><!-- .entry-meta -->
	</article><!-- #post-## -->

				
					
<article id="post-1292" class="post-1292 post type-post status-publish format-standard hentry category-advanced-macros category-loops-in-lisp">
	<header class="entry-header">
					<h1 class="entry-title"><a href="../../2016/01/12/loops-in-lisp-part-3-iterate/index.html" rel="bookmark">Loops in Lisp Part 3: Iterate</a></h1>			</header><!-- .entry-header -->
			<div class="entry-content">
			<p><em>This is part 3 of Loops in Lisp. For part 1 on how you can build any kind of looping construct you want out of just goto and macros, click <a href="../../2015/11/24/loops-lisp-part-1-goto/index.html">here</a>. For part 2 on Loop, click <a href="../../2015/12/15/loops-in-lisp-part-2-loop/index.html">here</a>.</em></p>
<p>The <a href="https://common-lisp.net/project/iterate/">Iterate</a> library is pretty awesome. It provides a macro <strong>iterate</strong> (and an alias for it, <strong>iter</strong>) that is basically a Lispy version of <strong>loop</strong>. The most obvious consequence of this is that <strong>iterate</strong> uses a lot more parens than <strong>loop</strong> does:</p>
<pre class="brush: plain; title: ; notranslate" title="">
;; Loop code
(loop for i from 1 to 10
      collect i)

;; Iterate code
(iter (for i from 1 to 10)
      (collect i))
</pre>
<p>Even though all of the extra parens make <strong>iterate</strong> much uglier than <strong>loop</strong>, they give <strong>iterate</strong> all of the advantages of Lisp syntax. One such advantage is the ability to embed <strong>iterate</strong> clauses within Lisp code and vice versa. While you can&#8217;t do this with <strong>loop</strong>, you can do it with <strong>iterate</strong> because the syntax of <strong>iterate</strong> is so similar to the syntax of ordinary Lisp code. Here is what happens when you try to embed a <strong>collect</strong> clause within Lisp code with <strong>loop</strong> and with <strong>iterate</strong>:<span id='easy-footnote-1' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../2016/01/12/loops-in-lisp-part-3-iterate/index.html#easy-footnote-bottom-1' title='It is possible to write a valid version of the loop code below by using the version of &#8216;when&#8217; provided by loop. Although that trick works for this specific case, it doesn&#8217;t allow for the use of arbitrary Lisp expressions like iterate does.'><sup>1</sup></a></span></p>
<pre class="brush: plain; title: ; notranslate" title="">
;; Not valid loop code.
(loop for i from 1 to 10
      do (when (evenp i)
           (collect i)))

;; Valid iterate code
(iter (for i from 1 to 10)
      (when (evenp i)
        (collect i)))
</pre>
<p>Although the ability to seamlessly go between Lisp code and <strong>iterate</strong> is pretty awesome, the greatest feature provided by <strong>iterate</strong> is also the entire reason why Lisp syntax has so many parens in the first place. Lisp syntax (and by extension <strong>iterate</strong>) makes it easy to write macros! Because of this, you can add pretty much any feature you want to <strong>iterate</strong>. As a simple example, here&#8217;s how you could define an <strong>iterate</strong> clause specifically for looping over the digits of a number:<span id='easy-footnote-2' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../2016/01/12/loops-in-lisp-part-3-iterate/index.html#easy-footnote-bottom-2' title='Defmacro-clause is a macro provided by Iterate that can be used to define new iterate clauses.'><sup>2</sup></a></span></p>
<pre class="brush: plain; title: ; notranslate" title="">
(defun digits (n)
  &quot;Returns a list of the digits of N.&quot;
  (map 'list #'digit-char-p (princ-to-string n)))

(defmacro-clause (for var in-digits-of n)
  `(for ,var in (digits ,n)))
</pre>
<p>And here is how you would use it:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(iter (for i in-digits-of 123)
      (sum i))
=&gt; 6
</pre>
<p>I cannot express how awesome this is. If you want an <strong>iterate</strong> clause for iterating over SQL queries, you can add <a href="https://common-lisp.net/project/iterate-clsql/">it</a>. If you want an <strong>iterate</strong> clause for looping over your own custom data structure, you can add it. You can add any feature you want all because <strong>iterate</strong> allows for the use of macros!</p>
<p>Personally, I prefer to use <strong>iterate</strong> over <strong>loop</strong>. Even though it is uglier, it is much more extensible than <strong>loop</strong> because it decides to use a Lisp like syntax.</p>
					</div><!-- .entry-content -->
				<div class="entry-meta clear">
			<span class="posted-on">Posted on <a href="../../2016/01/12/loops-in-lisp-part-3-iterate/index.html" rel="bookmark"><time class="entry-date published" datetime="2016-01-12T12:00:11+00:00">January 12, 2016</time><time class="updated" datetime="2016-01-12T02:00:56+00:00">January 12, 2016</time></a></span><span class="byline"> by <span class="author vcard"><a class="url fn n" href="../../author/malisper/index.html">malisper</a></span></span>			<span class="secondary-entry-meta">
																	<span class="comments-link"><a href="../../2016/01/12/loops-in-lisp-part-3-iterate/index.html#comments">3</a></span>							</span>
		</div><!-- .entry-meta -->
	</article><!-- #post-## -->

				
					
<article id="post-1264" class="post-1264 post type-post status-publish format-standard hentry category-loops-in-lisp">
	<header class="entry-header">
					<h1 class="entry-title"><a href="../../2015/12/15/loops-in-lisp-part-2-loop/index.html" rel="bookmark">Loops in Lisp Part 2: Loop</a></h1>			</header><!-- .entry-header -->
			<div class="entry-content">
			<p><em>This is part 2 of Loops in Lisp. Click <a href="../../2015/11/24/loops-lisp-part-1-goto/index.html">here</a> to view the previous post on how you can build any iteration abstraction you want out of just goto and macros.</em></p>
<p>The <strong>loop</strong> macro is probably the most well known of all macros. It provides a DSL for performing any kind of iteration imaginable. To give you an idea of just how powerful <strong>loop</strong> is, here are the first two <a href="https://projecteuler.net/">Project Euler</a> problems, solved using just <strong>loop</strong>:</p>
<pre class="brush: plain; title: ; notranslate" title="">
;; Solution for problem #1.
(loop for i from 1 below 1000
      if (or (= 0 (mod i 3))
             (= 0 (mod i 5)))
        sum i)

;; Solution for problem #2.
(loop for a = 1 then (+ a b)
      and b = 0 then a
      while (&lt; a 4000000)
      if (evenp a)
        sum a)
</pre>
<p>The coolest part of <strong>loop</strong> is that it is just a macro! That means it would be possible to build <strong>loop</strong> in Common Lisp, even if it wasn&#8217;t provided as a builtin (<a href="https://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/lisp/code/iter/loop/mit/original/loop.cl">here</a> is one such implementation). That also means any <strong>loop</strong> code is eventually compiled down to goto! For example, here is the expansion of the solution to the first Project Euler problem:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(block nil
  (let ((i 1))
    (declare (type (and real number) i))
    (let ((#:loop-sum-2482 0))
      (declare (type number #:loop-sum-2482))
      (tagbody
       sb-loop::next-loop
        (if (&gt;= i '1000)
            (progn (go sb-loop::end-loop))
            nil)
        (if (let ((#:g2483 (= 0 (mod i 3))))
              (if #:g2483
                  #:g2483
                  (the t (= 0 (mod i 5)))))
            (setq #:loop-sum-2482 (+ #:loop-sum-2482 i)))
        (setq i (1+ i))
        (go sb-loop::next-loop)
       sb-loop::end-loop
        (return-from nil #:loop-sum-2482)))))
</pre>
<p>If you look carefully, the expansion is nothing more than a mix of a few gotos and conditionals. Also, even though the generated code is a complete mess, you are able to work with it through interface provided by <strong>loop</strong>. Even though <strong>loop</strong> is fairly complex, it is still much simpler than raw gotos. If you think about it, <strong>loop</strong> is really just a convenient way of specifying a combination of patterns of gotos and conditionals.</p>
<p>I don&#8217;t have much to add about <strong>loop</strong> that others haven&#8217;t already said. If you are looking for a basic introduction to <strong>loop</strong> you should read Peter Seibel&#8217;s guide which can be found <a href="http://www.gigamonkeys.com/book/loop-for-black-belts.html">here</a>. If you are looking for a more complete reference, check out the <strong>loop</strong> chapter in Common Lisp the Language which can be found <a href="https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node235.html">here</a>.</p>
<p>While all of the features of loop compose well with each other, they do not compose well with the rest of Common Lisp. You cannot embed a loop clause (e.g. collect) within ordinary lisp code. That brings us to what will be next week&#8217;s topic, <strong>i</strong><strong>terate</strong>. <strong>Iterate</strong> is basically a more lispy version of <strong>loop</strong>. It allows you to seamlessly go between <strong>iterate</strong> clauses and regular Lisp code. More importantly, <strong>iterate</strong> allows you to define macros that then become part of the <strong>iterate</strong> DSL!</p>
					</div><!-- .entry-content -->
				<div class="entry-meta clear">
			<span class="posted-on">Posted on <a href="../../2015/12/15/loops-in-lisp-part-2-loop/index.html" rel="bookmark"><time class="entry-date published" datetime="2015-12-15T09:00:22+00:00">December 15, 2015</time><time class="updated" datetime="2015-12-15T13:06:07+00:00">December 15, 2015</time></a></span><span class="byline"> by <span class="author vcard"><a class="url fn n" href="../../author/malisper/index.html">malisper</a></span></span>			<span class="secondary-entry-meta">
																	<span class="comments-link"><a href="../../2015/12/15/loops-in-lisp-part-2-loop/index.html#respond">0</a></span>							</span>
		</div><!-- .entry-meta -->
	</article><!-- #post-## -->

				
					
<article id="post-1106" class="post-1106 post type-post status-publish format-standard hentry category-basics category-loops-in-lisp">
	<header class="entry-header">
					<h1 class="entry-title"><a href="../../2015/11/24/loops-lisp-part-1-goto/index.html" rel="bookmark">Loops in Lisp Part 1: Goto</a></h1>			</header><!-- .entry-header -->
			<div class="entry-content">
			<p>At its core, Common Lisp provides two primitives for performing iteration. The first of those primitives is recursion. Recursion is an amazing technique, but in this post I am going to focus on the other primitive &#8211; goto.</p>
<p>Goto is extremely powerful. It lets you manipulate the control flow of your program in anyway you can think of. This freedom to do whatever you want is also what makes goto so dangerous. In any given piece of code that uses goto, it is difficult to tell what the purpose of the goto is because it could be used for so many different reasons. Because of this, most languages provide various kinds of builtin loops instead of providing raw goto. Even though loops aren&#8217;t as general as goto, they express the intention of the code much more clearly.</p>
<p>As an example, let&#8217;s say you want to print all of the characters in a file. If your language provided while loops, you could do this by printing characters from the file one at a time while there are more characters left. If Common Lisp had while loops,<span id='easy-footnote-1' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../2015/11/24/loops-lisp-part-1-goto/index.html#easy-footnote-bottom-1' title='Common Lisp does provide the do macro, which can be used as a while loop. I&#8217;m not mentioning it for pedagogical reasons.'><sup>1</sup></a></span> the code for this procedure would look like this:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(while (peek-char file nil nil)
  (write-char (read-char file)))
</pre>
<p>If your language only had goto, it becomes much more difficult to implement the procedure. In the end, you have to, in some way, simulate a while loop. One way to code the procedure with just goto is the following. First check if there are any characters left in the file. If there aren&#8217;t any, goto the end. Otherwise print the next character and go back to the start. Here is Common Lisp code that implements this:<span id='easy-footnote-2' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../2015/11/24/loops-lisp-part-1-goto/index.html#easy-footnote-bottom-2' title='In Common Lisp, you need to use tagbody when creating labels because otherwise the labels would be interpreted as variables to be evaluated.'><sup>2</sup></a></span></p>
<pre class="brush: plain; title: ; notranslate" title="">
(tagbody
  start
  (if (not (peek-char file nil nil))
      (go end))
  (write-char (read-char file))
  (go start)
  end)
</pre>
<p>Not only is the version with goto much more verbose, it is also much harder to understand. The code lacks clarity because goto is so general. It gives you no context into how it is being used. The reader of the code will have to think about the positioning of all of the gotos before they can think about the overall flow of the program. On the other hand, in the version with the while loop, merely the fact that a while loop is being used gives whoever is reading the code a decent idea of the control flow.</p>
<p>In reality all loops are eventually compiled down to gotos. Whenever the compiler for a language that provides loops sees a loop, it generates code that simulates the loop through goto. You can do the same thing with Lisp macros!</p>
<p>If you don&#8217;t know, Lisp macros are compile time functions which take code as their input and return code as their output. When Lisp code is being compiled, all of the macros in the code are called and each one is replaced with its result. This means you can write a macro that looks like a while loop when you use it, but at compile time generates code to simulate a while loop through goto. You are in effect adding while loops to the Lisp compiler! Here is code that defines such a macro:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defmacro while (test &amp;body body)
  (let ((gtop (gensym))
        (gend (gensym)))
    `(tagbody
       ,gtop
       (if (not ,test)
           (go ,gend))
       ,@body
       (go ,gtop)
       ,gend)))
</pre>
<p>With this macro, the first code example is now valid lisp code! The <strong>while </strong>macro takes as arguments a test and a body. It then generates code that uses the method used in the second example to simulate a while loop with goto. You can actually see what the first example looks like after expanding the macro by using the function <strong>macroexpand</strong>. Here is what the generated code looks like:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(tagbody
  #:g729
  (if (not (peek-char file nil nil))
      (go #:g730))
  (write-char (read-char file))
  (go #:g729)
  #:g730)
</pre>
<p>The generated code is the exact same as the code in the second example except for the names of the labels. This means the two examples are the same functionally! The only real difference between them is that the first one is expressed in terms of loops, and the second one is expressed in terms of goto. Since it is so much easier to think in terms of loops than goto, there is no reason why you wouldn&#8217;t use the first example over the second.</p>
<p>Macros allow you to build any feature you want as long as it is possible to simulate that feature through lower level features. With respect to goto, this means you can build any kind of control flow construct you want by simulating it with goto and then putting a macro on top. In Common Lisp, all of the looping constructs (<strong>do</strong>, <strong>do*</strong>, <strong>dotimes</strong>, <strong>dolist</strong>, <strong>loop</strong>) are really just macros that expand into goto. This is what Alan Kay meant when he said &#8220;Lisp isn&#8217;t a language, it&#8217;s a building material&#8221;. It bears repeating. In Lisp, you can build any feature you want as long as it is possible to simulate that feature in terms of lower level features.</p>
					</div><!-- .entry-content -->
				<div class="entry-meta clear">
			<span class="posted-on">Posted on <a href="../../2015/11/24/loops-lisp-part-1-goto/index.html" rel="bookmark"><time class="entry-date published" datetime="2015-11-24T10:00:44+00:00">November 24, 2015</time><time class="updated" datetime="2015-11-22T15:29:38+00:00">November 22, 2015</time></a></span><span class="byline"> by <span class="author vcard"><a class="url fn n" href="../../author/malisper/index.html">malisper</a></span></span>			<span class="secondary-entry-meta">
																	<span class="comments-link"><a href="../../2015/11/24/loops-lisp-part-1-goto/index.html#comments">6</a></span>							</span>
		</div><!-- .entry-meta -->
	</article><!-- #post-## -->

				
			
		
		</main><!-- #main -->
	</section><!-- #primary -->


	</div><!-- #content -->

	<footer id="colophon" class="site-footer" role="contentinfo">
		<div class="site-info">
			<a href="http://wordpress.org/">Proudly powered by WordPress</a>
			<span class="sep"> ~ </span>
			Theme: Scrawl by <a href="https://wordpress.com/themes/" rel="designer">WordPress.com</a>.		</div><!-- .site-info -->
	</footer><!-- #colophon -->
</div><!-- #page -->

<script type='text/javascript' src='../../wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shCore09b1.js?ver=3.0.9b'></script>
<script type='text/javascript' src='../../wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shBrushPlain09b1.js?ver=3.0.9b'></script>
<script type='text/javascript'>
	(function(){
		var corecss = document.createElement('link');
		var themecss = document.createElement('link');
		var corecssurl = "../../wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shCore09b1.css?ver=3.0.9b";
		if ( corecss.setAttribute ) {
				corecss.setAttribute( "rel", "stylesheet" );
				corecss.setAttribute( "type", "text/css" );
				corecss.setAttribute( "href", corecssurl );
		} else {
				corecss.rel = "stylesheet";
				corecss.href = corecssurl;
		}
		document.getElementsByTagName("head")[0].insertBefore( corecss, document.getElementById("syntaxhighlighteranchor") );
		var themecssurl = "../../wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shThemeEclipse09b1.css?ver=3.0.9b";
		if ( themecss.setAttribute ) {
				themecss.setAttribute( "rel", "stylesheet" );
				themecss.setAttribute( "type", "text/css" );
				themecss.setAttribute( "href", themecssurl );
		} else {
				themecss.rel = "stylesheet";
				themecss.href = themecssurl;
		}
		//document.getElementById("syntaxhighlighteranchor").appendChild(themecss);
		document.getElementsByTagName("head")[0].insertBefore( themecss, document.getElementById("syntaxhighlighteranchor") );
	})();
	SyntaxHighlighter.config.strings.expandSource = '+ expand source';
	SyntaxHighlighter.config.strings.help = '?';
	SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
	SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
	SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
	SyntaxHighlighter.defaults['pad-line-numbers'] = false;
	SyntaxHighlighter.defaults['toolbar'] = false;
	SyntaxHighlighter.all();
</script>
<link rel='stylesheet' id='qtipstyles-css'  href='../../wp-content/plugins/easy-footnotes/assets/qtip/jquery.qtip.min167b.css?ver=4.6' type='text/css' media='' />
<link rel='stylesheet' id='easyfootnotescss-css'  href='../../wp-content/plugins/easy-footnotes/assets/easy-footnotes167b.css?ver=4.6' type='text/css' media='' />
<link rel='stylesheet' id='dashicons-css'  href='../../wp-includes/css/dashicons.min167b.css?ver=4.6' type='text/css' media='all' />
<script type='text/javascript' src='../../wp-content/themes/scrawl-wpcom/js/scrawld56c.js?ver=20150309'></script>
<script type='text/javascript' src='../../wp-content/themes/scrawl-wpcom/js/skip-link-focus-fix08e0.js?ver=20130115'></script>
<script type='text/javascript' src='../../wp-includes/js/wp-embed.min167b.js?ver=4.6'></script>
<script type='text/javascript' src='../../wp-includes/js/imagesloaded.min55a0.js?ver=3.2.0'></script>
<script type='text/javascript' src='../../wp-content/plugins/easy-footnotes/assets/qtip/jquery.qtip.min167b.js?ver=4.6'></script>
<script type='text/javascript' src='../../wp-content/plugins/easy-footnotes/assets/qtip/jquery.qtipcall167b.js?ver=4.6'></script>

</body>

<!-- Mirrored from malisper.me/category/loops-in-lisp/ by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 01 Sep 2016 17:46:31 GMT -->
</html>
<!-- Dynamic page generated in 0.098 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2016-09-01 12:22:30 -->

<!-- super cache -->