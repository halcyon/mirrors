<!DOCTYPE html>
<html lang="en-US" prefix="og: http://ogp.me/ns#">

<!-- Mirrored from malisper.me/2016/06/11/building-fizzbuzz-fractran-bottom/ by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 01 Sep 2016 17:46:32 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Building Fizzbuzz in Fractran from the Bottom Up - Macrology</title>
<link rel="profile" href="http://gmpg.org/xfn/11">
<link rel="pingback" href="../../../../xmlrpc.php">


<!-- This site is optimized with the Yoast SEO plugin v3.4.2 - https://yoast.com/wordpress/plugins/seo/ -->
<link rel="canonical" href="index.html" />
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Building Fizzbuzz in Fractran from the Bottom Up - Macrology" />
<meta property="og:description" content="In this post, I am going to show you how to write Fizzbuzz in the programming language Fractran. If you don&#8217;t know, Fractran is an esoteric programming language. That means it is extraordinary difficult to write any program in Fractran. To mitigate this difficultly, instead of writing Fizzbuzz in raw Fractran, what we are going to do is &hellip;" />
<meta property="og:url" content="index.html" />
<meta property="og:site_name" content="Macrology" />
<meta property="article:section" content="Intermediate Macros" />
<meta property="article:published_time" content="2016-06-11T19:59:52-05:00" />
<meta property="article:modified_time" content="2016-06-16T16:54:14-05:00" />
<meta property="og:updated_time" content="2016-06-16T16:54:14-05:00" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:description" content="In this post, I am going to show you how to write Fizzbuzz in the programming language Fractran. If you don&#8217;t know, Fractran is an esoteric programming language. That means it is extraordinary difficult to write any program in Fractran. To mitigate this difficultly, instead of writing Fizzbuzz in raw Fractran, what we are going to do is [&hellip;]" />
<meta name="twitter:title" content="Building Fizzbuzz in Fractran from the Bottom Up - Macrology" />
<!-- / Yoast SEO plugin. -->

<link rel='dns-prefetch' href='http://fonts.googleapis.com/'>
<link rel="alternate" type="application/rss+xml" title="Macrology &raquo; Feed" href="../../../../feed/index.html" />
<link rel="alternate" type="application/rss+xml" title="Macrology &raquo; Comments Feed" href="../../../../comments/feed/index.html" />
<link rel="alternate" type="application/rss+xml" title="Macrology &raquo; Building Fizzbuzz in Fractran from the Bottom Up Comments Feed" href="feed/index.html" />
<link rel='stylesheet' id='scrawl-style-css'  href='../../../../wp-content/themes/scrawl-wpcom/style167b.css?ver=4.6' type='text/css' media='all' />
<link rel='stylesheet' id='scrawl-fonts-css'  href='https://fonts.googleapis.com/css?family=Lora:400,700|Merriweather:400italic,400,700,700italic&amp;subset=latin%2Clatin-ext' type='text/css' media='all' />
<link rel='stylesheet' id='genericons-css'  href='../../../../wp-content/themes/scrawl-wpcom/fonts/genericons6de8.css?ver=3.3' type='text/css' media='all' />
<script type='text/javascript' src='../../../../wp-includes/js/jquery/jqueryb8ff.js?ver=1.12.4'></script>
<script type='text/javascript' src='../../../../wp-includes/js/jquery/jquery-migrate.min330a.js?ver=1.4.1'></script>
<link rel='https://api.w.org/' href='../../../../wp-json/index.html' />
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="../../../../xmlrpc0db0.php?rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="../../../../wp-includes/wlwmanifest.xml" /> 
<meta name="generator" content="WordPress 4.6" />
<link rel='shortlink' href='../../../../index6cf2.html?p=1520' />
<link rel="alternate" type="application/json+oembed" href="../../../../wp-json/oembed/1.0/embedd594.json?url=http%3A%2F%2Fmalisper.me%2F2016%2F06%2F11%2Fbuilding-fizzbuzz-fractran-bottom%2F" />
<link rel="alternate" type="text/xml+oembed" href="../../../../wp-json/oembed/1.0/embedd53c?url=http%3A%2F%2Fmalisper.me%2F2016%2F06%2F11%2Fbuilding-fizzbuzz-fractran-bottom%2F&amp;format=xml" />
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-63547056-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
<style type="text/css" id="syntaxhighlighteranchor"></style>

<script type="text/javascript">
  window.heap=window.heap||[],heap.load=function(e,t){window.heap.appid=e,window.heap.config=t=t||{};var n=t.forceSSL||"https:"===document.location.protocol,a=document.createElement("script");a.type="text/javascript",a.async=!0,a.src=(n?"https:":"http:")+"//cdn.heapanalytics.com/js/heap-"+e+".js";var o=document.getElementsByTagName("script")[0];o.parentNode.insertBefore(a,o);for(var r=function(e){return function(){heap.push([e].concat(Array.prototype.slice.call(arguments,0)))}},p=["clearEventProperties","identify","setEventProperties","track","unsetEventProperty"],c=0;c<p.length;c++)heap[p[c]]=r(p[c])};
    heap.load("931515525");
</script>
</head>

<body class="single single-post postid-1520 single-format-standard">
	<button class="menu-toggle x">
		<span class="lines"></span>
		<span class="screen-reader-text">Primary Menu</span>
	</button>
	<div class="slide-menu">
				
		<h1 class="site-title"><a href="../../../../index.html" rel="home">Macrology</a></h1>
		<h2 class="site-description">Case Studies in Lisp Macros</h2>
		
				
				
			<div id="secondary" class="widget-area" role="complementary">
		<aside id="search-2" class="widget widget_search"><form role="search" method="get" class="search-form" action="http://malisper.me/">
				<label>
					<span class="screen-reader-text">Search for:</span>
					<input type="search" class="search-field" placeholder="Search &hellip;" value="" name="s" />
				</label>
				<input type="submit" class="search-submit" value="Search" />
			</form></aside><aside id="pages-3" class="widget widget_pages"><h1 class="widget-title">Pages</h1>		<ul>
			<li class="page_item page-item-55"><a href="../../../../about-me/index.html">About Michael Malis</a></li>
<li class="page_item page-item-44"><a href="../../../../about-this-site-2/index.html">About This Site</a></li>
		</ul>
		</aside><aside id="nav_menu-3" class="widget widget_nav_menu"><h1 class="widget-title">Contact Me</h1><div class="menu-contact-me-container"><ul id="menu-contact-me" class="menu"><li id="menu-item-60" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-60"><a href="mailto:michaelmalis2@gmail.com">Email</a></li>
<li id="menu-item-58" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-58"><a href="https://github.com/malisper">Github</a></li>
<li id="menu-item-59" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-59"><a href="https://news.ycombinator.com/user?id=malisper">Hacker News</a></li>
</ul></div></aside><aside id="archives-2" class="widget widget_archive"><h1 class="widget-title">Archives</h1>		<ul>
			<li><a href='../../index.html'>June 2016</a></li>
	<li><a href='../../../04/index.html'>April 2016</a></li>
	<li><a href='../../../01/index.html'>January 2016</a></li>
	<li><a href='../../../../2015/12/index.html'>December 2015</a></li>
	<li><a href='../../../../2015/11/index.html'>November 2015</a></li>
	<li><a href='../../../../2015/10/index.html'>October 2015</a></li>
	<li><a href='../../../../2015/09/index.html'>September 2015</a></li>
	<li><a href='../../../../2015/08/index.html'>August 2015</a></li>
	<li><a href='../../../../2015/07/index.html'>July 2015</a></li>
	<li><a href='../../../../2015/06/index.html'>June 2015</a></li>
	<li><a href='../../../../2015/05/index.html'>May 2015</a></li>
		</ul>
		</aside><aside id="categories-2" class="widget widget_categories"><h1 class="widget-title">Categories</h1>		<ul>
	<li class="cat-item cat-item-2"><a href="../../../../category/basics/index.html" title="These are basic Lisp macros that should be trivial to understand.">Basic Macros</a>
</li>
	<li class="cat-item cat-item-5"><a href="../../../../category/intermediate-macros/index.html" >Intermediate Macros</a>
</li>
	<li class="cat-item cat-item-6"><a href="../../../../category/advanced-macros/index.html" >Advanced Macros</a>
</li>
	<li class="cat-item cat-item-7"><a href="../../../../category/debugging-common-lisp/index.html" >Debugging Lisp</a>
</li>
	<li class="cat-item cat-item-8"><a href="../../../../category/loops-in-lisp/index.html" >Loops in Lisp</a>
</li>
		</ul>
</aside>	</div><!-- #secondary -->
	</div><!-- .slide-menu -->
<div id="page" class="hfeed site">
	<a class="skip-link screen-reader-text" href="#content">Skip to content</a>

	<header id="masthead" class="site-header" role="banner">

		<div class="site-branding">
						<h1 class="site-title"><a href="../../../../index.html" rel="home">Macrology</a></h1>
		</div>

	</header><!-- #masthead -->

	
	
	<div id="content" class="site-content">


	<div id="primary" class="content-area">
		<main id="main" class="site-main" role="main">

		
			<article id="post-1520" class="post-1520 post type-post status-publish format-standard hentry category-intermediate-macros">
			<header class="entry-header">
			<h1 class="entry-title">Building Fizzbuzz in Fractran from the Bottom Up</h1>		</header><!-- .entry-header -->
		<div class="entry-content">
		<p>In this post, I am going to show you how to write <a href="https://www.rosettacode.org/wiki/FizzBuzz">Fizzbuzz</a> in the programming language Fractran. If you don&#8217;t know, Fractran is an esoteric programming language. That means it is extraordinary difficult to write any program in Fractran. To mitigate this difficultly, instead of writing Fizzbuzz in raw Fractran, what we are going to do is build a language that compiles to Fractran, and then write Fizzbuzz in that language.</p>
<p>This post is broken up into three parts. The first part covers what Fractran is and a way of understanding what a Fractran program does. Part 2 will go over the foundation of the language we will build and how it will map to Fractran. Finally, in Part 3, we will keep adding new features to the language until it becomes easy to write Fizzbuzz in it.</p>
<hr />
<h2>Part 1: Understanding Fractran</h2>
<p>Before we can start writing programs in Fractran, we have to first understand what Fractran is. A Fractran program is represented as just a list of fractions. To execute a Fractran program, you start with a variable N=2. You then go through the list of fractions until you find a fraction F, such that N*F is an integer. You then set N=N*F and go back to the beginning of the list of fractions. You keep repeating this process until there is no fraction F such that N*F is an integer.</p>
<p>Since there is no way to print anything with the regular Fractran rules, we are going to add one additional rule on top of the ordinary ones. In addition to the list of fractions, each program will have a mapping from numbers to characters representing the &#8220;alphabet&#8221; of the program. After multiplying N by F, whenever the new N is a multiple of one of the numbers in the alphabet, that will &#8220;print&#8221; the character that the number maps to. I have written a function, <strong>run-fractran</strong>, which implements this version of Fractran and included it <a href="https://gist.github.com/malisper/3a8594c96cea47471565be8d08be25f9">here</a>. It takes a list of fractions and an alphabet as an <a href="https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node153.html">alist</a> and executes the program.</p>
<p>Let&#8217;s walk through a simple example. Let&#8217;s say we have the following Fractran program:</p>
<pre class="brush: plain; title: ; notranslate" title="">
9/2, 1/5, 5/3
</pre>
<p>with the alphabet 5-&gt;&#8217;a&#8217;. To run this program, we start with N=2. We then go through the list fractions until we find a fraction F such that N*F is an integer. On this first step, F becomes 9/2, since N*F = 2 * 9/2 = 9 which is an integer. We then set N to N*F so that N now becomes 9. Repeating this process again, we get F=5/3 and N=N*F=15. Since the number 5 is in the alphabet, and N is now a multiple of 5, we output the character that 5 maps to, &#8216;a&#8217;. If we keep repeating these steps, we eventually reach a point where N=1 and we have outputted the string &#8220;aa&#8221;. Since 1 times any of the fractions does not result in an integer, the program terminates with the output &#8220;aa&#8221;.</p>
<p>At this point, you may be thinking that writing any program in Fractran is nearly impossible. The truth is that there is a simple trick you can use that makes it much easier program Fractran. All you need to do is look at the prime factorization of all of the numbers. Let&#8217;s see what the above Fractran program looks like if we convert every number into a tuple (a,b,c) where a is the how many times 2 divides the number, b is how many times 3 does, and c is how many times 5 does. The program then becomes:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(0, 2, 0) / (1, 0, 0)
(0, 0, 0) / (0, 0, 1)
(0, 0, 1) / (0, 1, 0)
</pre>
<p>We also have the tuple (0,0,1) mapping to &#8216;a&#8217; for our alphabet. We start with N = (1,0,0). If you don&#8217;t know, multiplying two numbers is the same as adding the counts of each prime factors, and division is the same as subtracting the counts. For example, 2 * 6 = (1,0,0) + (1,1,0) = (2,1,0) = 12. With this way of looking at the program, finding a fraction F such that N*F is an integer becomes finding a &#8220;fraction&#8221; F such that each element in the tuple N is greater than or equal to the corresponding element in the tuple in the denominator of F. Once we find such F, instead of multiplying N by it, you subtract from each element of N the corresponding value in the denominator of F (equivalent to dividing by the denominator), and add the corresponding value in the numerator (equivalent to multiplying by the numerator). Executing the program with this interpretation proceeds as follows.</p>
<p>We start with N = (1,0,0). Since every value in N is greater than or equal to their corresponding values in the denominator of the first fraction, we subtract every value in the first denominator and then add every value in the numerator to get N = (1,0,0) &#8211; (1,0,0) + (0,2,0) = (0,2,0). Repeating this again, F becomes the third fraction. Subtracting the denominator and adding the numerator gets us N = (0,1,1). Then since every value in N is greater than or equal to their corresponding element in (0,0,1), we print &#8216;a&#8217;. The program continues, just like it did for the original Fractran program.</p>
<p>Basically we can think of every prime number as having a &#8220;register&#8221; which can take on non-negative integer values. Each fraction is an instruction that operates on some of the registers. You can interpret a fraction as saying if the current value of each register is greater than or equal to the the value specified by the denominator (the number of times the prime for that register divides the denominator), you subtract from the registers all of the values in the denominator, add all the values specified in the numerator (the number of times the prime for each register divides the numerator), and then jump back to the first instruction. Otherwise, if any register is less than the value specified in the denominator, continue to the next fraction. For example, the fraction 9/2 can be translated into the following pseudocode:</p>
<pre class="brush: plain; title: ; notranslate" title="">
;; If the register corresponding to the prime number 2 
;; is greater or equal to 1
if reg[2] &gt;= 1
  ;; Decrement it by 1 and increment the register 
  ;; corresponding to 3 by 2. 
  reg[2] = reg[2] - 1
  reg[3] = reg[3] + 2
  goto the beginning of the program
;; Otherwise continue with the rest of the program.
</pre>
<p>Although programming Fractran is still difficult, this technique suddenly makes writing Fizzbuzz in Fractran tractable.</p>
<hr />
<h2>Part 2: Compiling to Fractran</h2>
<p>For our compiler, we are going to need to generate a lot of primes. To do so, we will use a function, <strong>new-prime</strong>, which will generate a different prime each time it is called.<span id='easy-footnote-1' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='#easy-footnote-bottom-1' title='If you are wondering why *next-new-prime* is initialized to nil, it&#8217;s because we are going to initialize all of the variables that don&#8217;t persist between runs of the compiler in the compiler. *next-new-prime* is an example of such a variable.'><sup>1</sup></a></span></p>
<pre class="brush: plain; title: ; notranslate" title="">
(defun prime (n)
  &quot;Is N a prime number?&quot;
  (loop for i from 2 to (isqrt n)
        never (multiple n i)))

(defparameter *next-new-prime* nil)

(defun new-prime ()
  &quot;Returns a new prime we haven't used yet.&quot;
  (prog1 *next-new-prime*
    (setf *next-new-prime*
          (loop for i from (+ *next-new-prime* 1)
                if (prime i)
                  return i))))
</pre>
<p>So now that we&#8217;ve got <strong>new-prime</strong>, we&#8217;ve we can start figuring out how we are going to compile to Fractran. The first detail we will need to figure out is how to express control flow in Fractran.  In other words, we need a way to specify which fractions will execute after each other fractions. This is a problem because after a fraction executes, you always jump back to the first fraction.</p>
<p>Expressing control flow actually winds up being surprisingly easy. For each fraction we can designate a register. Then, we only execute a fraction if its register is set. It is easy to have a fraction conditionally execute depending on whether its register is set by using the trick we are using to interpret a Fractran program. All we need to do is multiply the denominator of each fraction by the prime for the register of that fraction. This way, we will pass over a fraction unless its register is set. Also, all we need to do to specify which fraction should execute after a given fraction is to multiply the numerator of the given fraction by the prime of the register for the next fraction. By doing this, after a fraction executes, it will set the register of the next fraction.</p>
<p>In order to keep track of the primes for the current fraction and for the next fraction, we will have two global variables. The first will be the prime number for the current instruction, and the second will be the prime number for the next instruction:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defparameter *cur-inst-prime* nil)
(defparameter *next-inst-prime* nil)
</pre>
<p>We will also need a function <strong>advance</strong> which will advance the values of the variables once we move on to the next instruction.</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defun advance ()
  (setf *cur-inst-prime* *next-inst-prime*
        *next-inst-prime* (new-prime)))
</pre>
<p>Now that we&#8217;ve got a way of expressing control flow, we can start planning out what the language we will build will look like. From this point on, I am going to call the language we are building, Lisptran. An easy way we represent a Lisptran program is as just a list of expressions. We can have several different kinds of expressions each of which does something different.</p>
<p>The simplest kind of expression we will want is an inline fraction. If a Lisptran expression is just a fraction, we can just add that fraction to the Fractran program being generated.</p>
<p>Another kind of expression that would be useful are labels. Whenever a Lisptran expression is a Lisp symbol, we can interpret that as a label. Each label will be converted into that fraction that is the prime of the next instruction after the label divided by the prime of the label. This way we can jump to the instruction after the label by setting the register for the label. In order to make keeping track of the primes of labels easy, we are going to keep a hash-table, <em>*lisptran-labels*</em>, mapping from labels to the primes for those labels. We will also have a function <strong>prime-for-label</strong>, which will lookup the prime for a label or assign a new prime if one hasn&#8217;t been assigned yet:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defparameter *lisptran-labels* nil)

(defun prime-for-label (label)
  (or (gethash label *lisptran-labels*)
      (setf (gethash label *lisptran-labels*)
            (new-prime))))
</pre>
<p>One last kind of expression that will be useful are macro calls. A macro call will be a list whose first element is the name of a macro followed by a list of arbitrary Lisp expressions (The expressions don&#8217;t have to be Fractran expressions. They can be interpreted however the macro wants them to be.). In order to compile a macro call, we will lookup the function associated with the macro, and call it on the expressions in the rest of the macro call. That function should then return a list of Lisptran expressions which will then be compiled in place of the macro call. After that we just continue compiling the new code generated by the macro expansion.</p>
<p>To keep track of the definitions of macros, we will keep a hash-table <em>*lisptran-macros*</em>, which will map from the name of the macro to the function for that macro. In order to make defining Lisptran macros easy, we can create a Lisp macro <strong>deftran</strong>, that works in a similar way to <strong>defmacro</strong>. When defining a macro with <strong>deftran</strong>, you are really just defining a function which will take the expressions in the macro call, and return a list of Lisptran instructions to be compiled in its place. Here is the definition for <strong>deftran</strong>:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defparameter *lisptran-macros* (make-hash-table))

(defmacro deftran (name args &amp;body body)
  &quot;Define a Lisptran macro.&quot;
  `(setf (gethash ',name *lisptran-macros*)
         (lambda ,args ,@body)))
</pre>
<p>And that&#8217;s all of the different kinds of expressions we will need in Lisptran.</p>
<p>Although we now have all of the expressions we need, there are a few more pieces of the compiler we need to figure out. For example, we still haven&#8217;t figured out how we are going to represent variables yet. Ultimately this is trivial. We can just assign a register to every variable and keep a mapping from variable names to primes in the same way we have the mapping for labels:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defparameter *lisptran-vars* nil)

(defun prime-for-var (var)
  (or (gethash var *lisptran-vars*)
      (setf (gethash var *lisptran-vars*)
            (new-prime))))
</pre>
<p>One last piece of the compiler we need to figure out is how we are going to represent the alphabet of the program. One way we can do this is just represent the characters in our alphabet as variables. The alphabet of a program could just be all of the variables that have characters for names and the primes of the registers for those variables. By doing it this way, we can print a character by just incrementing and then immediately decrementing a variable! Here is code that can be used to obtain the alphabet from <em>*lisptran-vars*</em>:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defun alphabet (vars)
  &quot;Given a hash-table of the Lisptran variables to primes, 
   returns an alist representing the alphabet.&quot;
  (loop for var being the hash-keys in vars 
        using (hash-value prime)
        if (characterp var)
          collect (cons var prime)))
</pre>
<p>Now that we can express control flow, variables, and macros, we have everything we need to write the actual Lisptran to Fractran compiler:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defun assemble (insts)
  &quot;Compile the given Lisptran program into Fractran. 
   Returns two values. The first is the Fractran program 
   and the second is the alphabet of the program.&quot;
  (let* ((*cur-prime* 2)
         (*cur-inst-prime* (new-prime))
         (*next-inst-prime* (new-prime))
         (*lisptran-labels* (make-hash-table))
         (*lisptran-vars* (make-hash-table)))
    (values (assemble-helper insts)
            (alphabet *lisptran-vars*))))

(defun assemble-helper (exprs)
  (if (null insts)
      '()
      (let ((expr (car exprs))
            (rest (cdr exprs)))
        (cond
          ;; If it's a number, we just add it to the 
          ;; Fractran  program and compile the rest 
          ;; of the Lisptran program
          ((numberp expr)
           (cons expr (assemble-helper rest)))

          ;; If it's a symbol, we divide the prime for 
          ;; the next instruction by the prime for the 
          ;; label.
          ((symbolp expr)
           (cons (/ *cur-inst-prime* 
                    (prime-for-label expr))
                 (assemble-helper rest)))

          ;; Otherwise it's a macro call. We look up the 
          ;; macro named by the first symbol in the 
          ;; expression and call it on the rest of the 
          ;; rest of the expressions in the macro call. 
          ;; We then append all of the instructions 
          ;; returned by it to the rest of the program 
          ;; and compile that.
          (:else
            (let ((macrofn (gethash (car inst)
                                    *lisptran-macros*)))
              (assemble-helper (append (apply macrofn
                                              (cdr inst))
                                       rest))))))))
</pre>
<p>The function <strong>assemble</strong> takes a Lisptran program and returns two values. It returns the generated Fractran program and the alphabet of that program. <strong>assemble</strong> first initializes all of the global variables for the program and then goes to <strong>assemble-helper</strong> which recursively processes the Lisptran program according to the specification above. Using the function <strong>run-fractran</strong> that I mentioned above, we can write a function that will execute a given Lisptran program as follows:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defun run-lisptran (insts)
  &quot;Run the given Lisptran program.&quot;
  (multiple-value-call #'run-fractran (assemble insts)))
</pre>
<hr />
<h2>Part 3: Building Lisptran</h2>
<p>Now that we&#8217;ve completed the core compiler, we can start adding actual features to it. From here on out, we will not touch the core compiler. All we are going to do is define a couple Lisptran macros. Eventually we will have enough macros such that programming Lisptran seems like programming a high level assembly language.</p>
<p>The first operations we are going should define are basic arithmetic operations. For example, addition. In order to add addition to Lisptran, we can define a macro <strong>addi</strong>, which stands for add immediate. Immediate just means that we know what number we are adding at compile time. The macro <strong>a</strong><strong>ddi</strong> will take a variable and a number, and will expand into a fraction which will add the given number to the register for the variable. In this case, the denominator for the fraction will just be the prime for the current instruction (execute this instruction when that register is set) and the numerator will be the prime for the next instruction (execute the next instruction after this one) times the prime for the variable raised to the power of the number we are adding (add the immediate to the register). Here is what the definition for <strong>addi</strong> looks like:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(deftran addi (x y)
  (prog1 (list (/ (* *next* (expt (prime-for-var x) y))
                  *cur*))
    (advance)))
</pre>
<p>With are also going to want an operation that performs subtraction. It&#8217;s a bit tricky, but we can implement a macro <strong>subi </strong>(subtract immediate) in terms of <strong>addi</strong>, since adding a number is the same as adding the negative of that number:<span id='easy-footnote-2' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='#easy-footnote-bottom-2' title='We&#8217;ll just say that it results in undefined behavior if the immediate is greater than the variable.'><sup>2</sup></a></span></p>
<pre class="brush: plain; title: ; notranslate" title="">
(deftran subi (x y) `((addi x ,(- y))))
</pre>
<p>Now that we&#8217;ve got some macros for performing basic arithmetic, we can start focusing on macros that allow us to express control flow. The first control flow macro we will implement is <strong>&gt;=i</strong> (jump if greater than or equal to immediate). In order to implement <strong>&gt;=i</strong>, we will have it expand into three fractions. The first fraction will test if the variable is greater or equal to the immediate. If the test succeeds, we will then advance to the second fraction which will restore the variable (since when a test succeeds, all of the values from the denominator are decremented from the corresponding registers), and then jump to the label passed in to <strong>&gt;=i</strong>. If the test fails, we will fall through to the third fraction which will just continue onto the next fraction after that.</p>
<p>The denominator of the first fraction will be the prime for current instruction (execute the instruction if that register is set) times the prime for the register raised to the power of the constant (how we test that the register is greater than or equal to the immediate) and the numerator will be the prime for the second instruction (so we go to the second instruction if the test succeeds). The second fraction is just the prime for the label passed into <strong>&gt;=i</strong> (so we jump to wherever the label designates) divided the prime for that instruction. Lastly, the denominator of the third fraction is the prime for the current instruction (so we fall through to it if the test in the first fraction fails), and the numerator is just the prime for the next instruction so that we continue to that if the test fails:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(deftran &gt;=i (var val label)
  (prog1 (let ((restore (new-prime)))
           (list (/ restore
                    (expt (prime-for-var var) val)
                    *cur-inst-prime*)
                 (/ (* (prime-for-label label)
                       (expt (prime-for-var var) val))
                    restore)
                 (/ *next-inst-prime* *cur-inst-prime*)))
    (advance)))
</pre>
<p>Believe it or not, but after this point, we won&#8217;t need to even think about fractions anymore. Lisptran now has enough of a foundation that all of the further macros we will need can be expressed in terms of <strong>addi</strong>, <strong>subi</strong> and <strong>&gt;=i</strong>. The only two functions that actually need to be implemented in terms of Fractran are <strong>addi</strong> and <strong>&gt;=i</strong>. That means no more thinking about Fractran. From here on out, all we have is Lisptran!</p>
<p>We can easily define unconditional goto in terms of <strong>&gt;=i</strong>. Since all of the registers start at 0, we can implement <strong>goto</strong> as greater than or equal to zero. We use the Lisp function <strong>gensym</strong> to generate a variable without a name so that the variable doesn&#8217;t conflict with any other Lisptran variables:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(deftran goto (label) `((&gt;=i ,(gensym) 0 ,label)))
</pre>
<p>Then through a combination of <strong>&gt;=i</strong> and <strong>goto</strong>, we can define <strong>&lt;=i</strong>:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(deftran &lt;=i (var val label)
  (let ((gskip (gensym))) 
    `((&gt;=i ,var (+ ,val 1) ,gskip)
      (goto ,label)
      ,gskip)))
</pre>
<p>Now that we have several macros for doing control flow, we can start building some utilities for printing. As mentioned previously printing a character is the same as incrementing the variable with the character as its name and then immediately decrementing it:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(deftran print-char (char)
  `((addi ,char 1)
    (subi ,char 1)))
</pre>
<p>Then if we want to write a macro that prints a string, it can just expand into a series of calls to <strong>print-char</strong>, each of which prints a single character in the string:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(deftran print-string (str)
  (loop for char across str
        collect `(print-char ,char)))
</pre>
<p>We are also going to need a function to print a number. Writing this with the current state of Lisptran is fairly difficult since we haven&#8217;t implemented several utilities such as mod yet, but we can start by implementing a macro <strong>print-digit </strong>that prints the value of a variable that is between 0 and 9. We can implement it, by having it expand into a series of conditions. The first one will check if the variable is less than or equal to zero. If so it will print the character zero and jump past the rest of the conditions. Otherwise it falls through to the next condition which tests if the variable is less than or equal to one and so on. We don&#8217;t have to manually write the code for <strong>print-digit</strong> because we can use Lisp to generate the code for us:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(deftran print-digit (var)
  (loop with gend = (gensym)
        for i from 0 to 9
        for gprint = (gensym)
        for gskip = (gensym)
        append `((&lt;=i ,var ,i ,gprint)
                 (goto ,gskip)
                 ,gprint
                 (print-char ,(digit-char i))
                 (goto ,gend)
                 ,gskip)
        into result
        finally (return `(,@result ,gend))))
</pre>
<p>At this point, now that we have macros for performing basic arithmetic, basic control flow, and printing, we can start writing some recognizable programs. For example here is a program that prints the numbers from zero to nine:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(start
 (&gt;=i x 10 end)
 (print-digit x)
 (print-char #\newline)
 (addi x 1)
 (goto start)
 end)
</pre>
<p>If you are curious I have included the Fractran program generated by this Lisptran program <a href="https://gist.github.com/malisper/46635d7e3723c911e5f2ec9440908ced">here</a>. It&#8217;s hard to believe that the above Lisptran program and the Fractran program are equivalent. They look completely different!</p>
<p>Now that we have a bunch of low level operations, we can start building some higher level ones. You may not have thought of it, but instructions don&#8217;t need to just have flat structure. For example, now that we have <strong>goto</strong>, we can use it to define while loops (just like in <a href="../../../../2015/11/24/loops-lisp-part-1-goto/index.html">Loops in Lisp</a>):</p>
<pre class="brush: plain; title: ; notranslate" title="">
(deftran while (test &amp;rest body)
  (let ((gstart (gensym))
        (gend (gensym)))
    `((goto ,gend)
      ,gstart
      ,@body
      ,gend
      (,@test ,gstart))))
</pre>
<p>In order to implement <strong>while</strong>, we are assuming that all predicates take labels as their last argument which is where they will jump to if the predicate succeeds. Now that we have while loops, we can start writing some much more powerful macros around manipulating variables. Here&#8217;s two useful ones, one that sets a variable to zero, and one that copies the value in one variable to another:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(deftran zero (var)
  `((while (&gt;=i ,var 1)
      (subi ,var 1))))

(deftran move (to from)
  (let ((gtemp (gensym)))
    `((zero ,to)
      (while (&gt;=i ,from 1)
        (addi ,gtemp 1)
        (subi ,from 1))
      (while (&gt;=i ,gtemp 1)
        (addi ,to 1)
        (addi ,from 1)
        (subi ,gvar 1)))))
</pre>
<p>For <strong>move</strong>, we first have to decrement the number we are moving from and increment a temporary variable. Than we restore both the original variable and the variable we are moving the value to at the same time.</p>
<p>With all of these macros, we can finally start focusing on macros that are actually relevant to Fizzbuzz. One operation that is absolutely going to be necessary for Fizzbuzz is mod. We can implement a macro <strong>modi</strong> by repeatedly subtracting the immediate until the variable is less than the immediate.</p>
<pre class="brush: plain; title: ; notranslate" title="">
(deftran modi (var val)
  `((while (&gt;=i ,var ,val)
      (subi ,var ,val))))
</pre>
<p>We only need one more real feature before we can start writing Fizzbuzz. We are going to need a way of printing numbers. In order to print an arbitrary number, we are going to need a way of doing integer division. We can implement a macro <strong>divi</strong> by repeatedly subtracting the immediate until the variable is less than the immediate and keeping track of the number of times we&#8217;ve subtracted the immediate.</p>
<pre class="brush: plain; title: ; notranslate" title="">
(deftran divi (x y)
  (let ((gresult (gensym)))
    `((zero ,gresult)
      (while (&gt;=i ,x ,y)
        (addi ,gresult 1)
        (subi ,x ,y))
      (move ,x ,gresult))))
</pre>
<p>Now for the final macro we will need. A macro for printing numbers. Actually, we are going to cheat a little. Printing numbers winds up being pretty difficult since you have to print the digits from left to right, but you can only look at the lowest digit at a time. To make things easier, we are only to write a macro that is able to print two digit numbers. We won&#8217;t need to print 100 since &#8220;buzz&#8221; will be printed instead.</p>
<pre class="brush: plain; title: ; notranslate" title="">
(deftran print-number (var)
  (let ((gtemp (gensym))
        (gskip (gensym)))
    `((move ,gtemp ,var)
      (divi ,gtemp 10)
      (&gt;=i ,gtemp 0 ,gskip)
      (print-digit ,gtemp)
      ,gskip
      (move ,gtemp ,var)
      (modi ,gtemp 10)
      (print-digit ,gtemp)
      (print-char #\newline))))
</pre>
<p>Now our language is sufficiently high enough that Fizzbuzz is going to be practically as easy as it will get. Here is an implementation of Fizzbuzz in Fractran.</p>
<pre class="brush: plain; title: ; notranslate" title="">
((move x 1)
 (while (&lt;=i x 100)
   (move rem x)
   (modi rem 15)
   (&lt;=i rem 0 fizzbuzz)

   (move rem x)
   (modi rem 3)
   (&lt;=i rem 0 fizz)

   (move rem x)
   (modi rem 5)
   (&lt;=i rem 0 buzz)

   (print-number x)
   (goto end)

   fizzbuzz
   (print-string &quot;fizzbuzz&quot;)
   (goto end)

   fizz
   (print-string &quot;fizz&quot;)
   (goto end)

   buzz
   (print-string &quot;buzz&quot;)
   (goto end)

   end
   (addi x 1)))
</pre>
<p>I&#8217;ve also included the generated Fractran program <a href="https://gist.github.com/malisper/7227bc8c428949d8c1f277effca28d14">here</a> and included all of the full source code for this blog post <a href="https://gist.github.com/malisper/fcd5fda9741220355f6ce36a423c69cc">here</a>.</p>
<p>I find it absolutely amazing that we were able to build a pretty decent language by repeatedly adding more and more features on top of what we already had. To recap, we implemented a basic arithmetic operation (<strong>addi</strong>) in terms of raw Fractran and then defined a second (<strong>subi</strong>) in terms of that. From there we defined three macros for doing control flow (<strong>&gt;=i</strong>, <strong>goto</strong>, <strong>&lt;=i</strong>), with the second two being defined in terms of the first. Then we were then able to define macros for printing (<strong>print-char</strong>, <strong>print-string</strong>, <strong>print-digit</strong>). At this point we had all of the low level operations we needed so we could start implement while loops (<strong>while)</strong>, a high level control flow construct. With while loops, we were able to define several macros for manipulating variables (<strong>zero</strong>, <strong>move)</strong>. With these new utilities for manipulating variables we could define more advanced arithmetic operations (<strong>modi</strong>, <strong>divi</strong>). Then with these new operations we were able to define a way to print an arbitrary two digit number (<strong>print-number</strong>). Finally, using everything we had up to this point, we were able to write Fizzbuzz. It&#8217;s just incredible that we could make a language by always making slight abstractions on top of the operations we already had.</p>
<ol class="easy-footnotes-wrapper"><li class="easy-footnote-single"><span id="easy-footnote-bottom-1" class="easy-footnote-margin-adjust"></span>If you are wondering why *next-new-prime* is initialized to nil, it&#8217;s because we are going to initialize all of the variables that don&#8217;t persist between runs of the compiler in the compiler. *next-new-prime* is an example of such a variable.<a class="easy-footnote-to-top" href="#easy-footnote-1"></a></li><li class="easy-footnote-single"><span id="easy-footnote-bottom-2" class="easy-footnote-margin-adjust"></span>We&#8217;ll just say that it results in undefined behavior if the immediate is greater than the variable.<a class="easy-footnote-to-top" href="#easy-footnote-2"></a></li></ol>			</div><!-- .entry-content -->

	<footer class="entry-footer">
				<div class="entry-meta clear">
			<span class="posted-on">Posted on <a href="index.html" rel="bookmark"><time class="entry-date published" datetime="2016-06-11T19:59:52+00:00">June 11, 2016</time><time class="updated" datetime="2016-06-16T16:54:14+00:00">June 16, 2016</time></a></span><span class="byline"> by <span class="author vcard"><a class="url fn n" href="../../../../author/malisper/index.html">malisper</a></span></span><span class="category-links"> in <a href="../../../../category/intermediate-macros/index.html" rel="category tag">Intermediate Macros</a></span>			<span class="secondary-entry-meta">
								<span class="comments-link"><a href="index.html#respond">0</a></span>							</span>
		</div><!-- .entry-meta -->
	</footer><!-- .entry-footer -->
</article><!-- #post-## -->

			
	<nav class="navigation post-navigation" role="navigation">
		<h2 class="screen-reader-text">Post navigation</h2>
		<div class="nav-links"><div class="nav-previous"><a href="../../../04/20/writing-self-referential-programs/index.html" rel="prev"><span class="title">Previous post</span>How to Generate Self-Referential Programs</a></div></div>
	</nav>
			
<div id="comments" class="comments-area">

	
	
	
					<div id="respond" class="comment-respond">
			<h3 id="reply-title" class="comment-reply-title">Leave a Reply <small><a rel="nofollow" id="cancel-comment-reply-link" title="Cancel reply" href="index.html#respond" style="display:none;"><span class="screen-reader-text">Cancel reply</span></a></small></h3>				<form action="http://malisper.me/wp-comments-post.php" method="post" id="commentform" class="comment-form" novalidate>
					<p class="comment-notes"><span id="email-notes">Your email address will not be published.</span> Required fields are marked <span class="required">*</span></p><p class="comment-form-comment"><label for="comment">Comment</label> <textarea id="comment" name="comment" cols="45" rows="8" maxlength="65525" aria-required="true" required="required"></textarea></p><p class="comment-form-author"><label for="author">Name <span class="required">*</span></label> <input id="author" name="author" type="text" value="" size="30" maxlength="245" aria-required='true' required='required' /></p>
<p class="comment-form-email"><label for="email">Email <span class="required">*</span></label> <input id="email" name="email" type="email" value="" size="30" maxlength="100" aria-describedby="email-notes" aria-required='true' required='required' /></p>
<p class="comment-form-url"><label for="url">Website</label> <input id="url" name="url" type="url" value="" size="30" maxlength="200" /></p>
<p class="form-submit"><input name="submit" type="submit" id="submit" class="submit" value="Post Comment" /> <input type='hidden' name='comment_post_ID' value='1520' id='comment_post_ID' />
<input type='hidden' name='comment_parent' id='comment_parent' value='0' />
</p><p style="display: none;"><input type="hidden" id="akismet_comment_nonce" name="akismet_comment_nonce" value="37102f1644" /></p><p style="display: none;"><input type="hidden" id="ak_js" name="ak_js" value="182"/></p>				</form>
					</div><!-- #respond -->
		
</div><!-- #comments -->
		
		</main><!-- #main -->
	</div><!-- #primary -->

	</div><!-- #content -->

	<footer id="colophon" class="site-footer" role="contentinfo">
		<div class="site-info">
			<a href="http://wordpress.org/">Proudly powered by WordPress</a>
			<span class="sep"> ~ </span>
			Theme: Scrawl by <a href="https://wordpress.com/themes/" rel="designer">WordPress.com</a>.		</div><!-- .site-info -->
	</footer><!-- #colophon -->
</div><!-- #page -->

<script type='text/javascript' src='../../../../wp-content/plugins/akismet/_inc/form2d73.html?ver=3.1.11'></script>
<script type='text/javascript' src='../../../../wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shCore09b1.js?ver=3.0.9b'></script>
<script type='text/javascript' src='../../../../wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shBrushPlain09b1.js?ver=3.0.9b'></script>
<script type='text/javascript'>
	(function(){
		var corecss = document.createElement('link');
		var themecss = document.createElement('link');
		var corecssurl = "../../../../wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shCore09b1.css?ver=3.0.9b";
		if ( corecss.setAttribute ) {
				corecss.setAttribute( "rel", "stylesheet" );
				corecss.setAttribute( "type", "text/css" );
				corecss.setAttribute( "href", corecssurl );
		} else {
				corecss.rel = "stylesheet";
				corecss.href = corecssurl;
		}
		document.getElementsByTagName("head")[0].insertBefore( corecss, document.getElementById("syntaxhighlighteranchor") );
		var themecssurl = "../../../../wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shThemeEclipse09b1.css?ver=3.0.9b";
		if ( themecss.setAttribute ) {
				themecss.setAttribute( "rel", "stylesheet" );
				themecss.setAttribute( "type", "text/css" );
				themecss.setAttribute( "href", themecssurl );
		} else {
				themecss.rel = "stylesheet";
				themecss.href = themecssurl;
		}
		//document.getElementById("syntaxhighlighteranchor").appendChild(themecss);
		document.getElementsByTagName("head")[0].insertBefore( themecss, document.getElementById("syntaxhighlighteranchor") );
	})();
	SyntaxHighlighter.config.strings.expandSource = '+ expand source';
	SyntaxHighlighter.config.strings.help = '?';
	SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
	SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
	SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
	SyntaxHighlighter.defaults['pad-line-numbers'] = false;
	SyntaxHighlighter.defaults['toolbar'] = false;
	SyntaxHighlighter.all();
</script>
<link rel='stylesheet' id='qtipstyles-css'  href='../../../../wp-content/plugins/easy-footnotes/assets/qtip/jquery.qtip.min167b.css?ver=4.6' type='text/css' media='' />
<link rel='stylesheet' id='easyfootnotescss-css'  href='../../../../wp-content/plugins/easy-footnotes/assets/easy-footnotes167b.css?ver=4.6' type='text/css' media='' />
<link rel='stylesheet' id='dashicons-css'  href='../../../../wp-includes/css/dashicons.min167b.css?ver=4.6' type='text/css' media='all' />
<script type='text/javascript' src='../../../../wp-content/themes/scrawl-wpcom/js/scrawld56c.js?ver=20150309'></script>
<script type='text/javascript' src='../../../../wp-content/themes/scrawl-wpcom/js/skip-link-focus-fix08e0.js?ver=20130115'></script>
<script type='text/javascript' src='../../../../wp-includes/js/comment-reply.min167b.js?ver=4.6'></script>
<script type='text/javascript' src='../../../../wp-includes/js/wp-embed.min167b.js?ver=4.6'></script>
<script type='text/javascript' src='../../../../wp-includes/js/imagesloaded.min55a0.js?ver=3.2.0'></script>
<script type='text/javascript' src='../../../../wp-content/plugins/easy-footnotes/assets/qtip/jquery.qtip.min167b.js?ver=4.6'></script>
<script type='text/javascript' src='../../../../wp-content/plugins/easy-footnotes/assets/qtip/jquery.qtipcall167b.js?ver=4.6'></script>

</body>

<!-- Mirrored from malisper.me/2016/06/11/building-fizzbuzz-fractran-bottom/ by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 01 Sep 2016 17:46:32 GMT -->
</html>
<!-- Dynamic page generated in 0.104 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2016-09-01 12:22:32 -->

<!-- super cache -->