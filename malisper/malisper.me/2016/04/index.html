<!DOCTYPE html>
<html lang="en-US" prefix="og: http://ogp.me/ns#">

<!-- Mirrored from malisper.me/2016/04/ by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 01 Sep 2016 17:46:26 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>April 2016 - Macrology</title>
<link rel="profile" href="http://gmpg.org/xfn/11">
<link rel="pingback" href="../../xmlrpc.php">


<!-- This site is optimized with the Yoast SEO plugin v3.4.2 - https://yoast.com/wordpress/plugins/seo/ -->
<meta name="robots" content="noindex,follow"/>
<link rel="canonical" href="index.html" />
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="object" />
<meta property="og:title" content="April 2016 - Macrology" />
<meta property="og:url" content="index.html" />
<meta property="og:site_name" content="Macrology" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="April 2016 - Macrology" />
<!-- / Yoast SEO plugin. -->

<link rel='dns-prefetch' href='http://fonts.googleapis.com/'>
<link rel="alternate" type="application/rss+xml" title="Macrology &raquo; Feed" href="../../feed/index.html" />
<link rel="alternate" type="application/rss+xml" title="Macrology &raquo; Comments Feed" href="../../comments/feed/index.html" />
<link rel='stylesheet' id='scrawl-style-css'  href='../../wp-content/themes/scrawl-wpcom/style167b.css?ver=4.6' type='text/css' media='all' />
<link rel='stylesheet' id='scrawl-fonts-css'  href='https://fonts.googleapis.com/css?family=Lora:400,700|Merriweather:400italic,400,700,700italic&amp;subset=latin%2Clatin-ext' type='text/css' media='all' />
<link rel='stylesheet' id='genericons-css'  href='../../wp-content/themes/scrawl-wpcom/fonts/genericons6de8.css?ver=3.3' type='text/css' media='all' />
<script type='text/javascript' src='../../wp-includes/js/jquery/jqueryb8ff.js?ver=1.12.4'></script>
<script type='text/javascript' src='../../wp-includes/js/jquery/jquery-migrate.min330a.js?ver=1.4.1'></script>
<link rel='https://api.w.org/' href='../../wp-json/index.html' />
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="../../xmlrpc0db0.php?rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="../../wp-includes/wlwmanifest.xml" /> 
<meta name="generator" content="WordPress 4.6" />
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-63547056-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
<style type="text/css" id="syntaxhighlighteranchor"></style>

<script type="text/javascript">
  window.heap=window.heap||[],heap.load=function(e,t){window.heap.appid=e,window.heap.config=t=t||{};var n=t.forceSSL||"https:"===document.location.protocol,a=document.createElement("script");a.type="text/javascript",a.async=!0,a.src=(n?"https:":"http:")+"//cdn.heapanalytics.com/js/heap-"+e+".js";var o=document.getElementsByTagName("script")[0];o.parentNode.insertBefore(a,o);for(var r=function(e){return function(){heap.push([e].concat(Array.prototype.slice.call(arguments,0)))}},p=["clearEventProperties","identify","setEventProperties","track","unsetEventProperty"],c=0;c<p.length;c++)heap[p[c]]=r(p[c])};
    heap.load("931515525");
</script>
</head>

<body class="archive date">
	<button class="menu-toggle x">
		<span class="lines"></span>
		<span class="screen-reader-text">Primary Menu</span>
	</button>
	<div class="slide-menu">
				
		<h1 class="site-title"><a href="../../index.html" rel="home">Macrology</a></h1>
		<h2 class="site-description">Case Studies in Lisp Macros</h2>
		
				
				
			<div id="secondary" class="widget-area" role="complementary">
		<aside id="search-2" class="widget widget_search"><form role="search" method="get" class="search-form" action="http://malisper.me/">
				<label>
					<span class="screen-reader-text">Search for:</span>
					<input type="search" class="search-field" placeholder="Search &hellip;" value="" name="s" />
				</label>
				<input type="submit" class="search-submit" value="Search" />
			</form></aside><aside id="pages-3" class="widget widget_pages"><h1 class="widget-title">Pages</h1>		<ul>
			<li class="page_item page-item-55"><a href="../../about-me/index.html">About Michael Malis</a></li>
<li class="page_item page-item-44"><a href="../../about-this-site-2/index.html">About This Site</a></li>
		</ul>
		</aside><aside id="nav_menu-3" class="widget widget_nav_menu"><h1 class="widget-title">Contact Me</h1><div class="menu-contact-me-container"><ul id="menu-contact-me" class="menu"><li id="menu-item-60" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-60"><a href="mailto:michaelmalis2@gmail.com">Email</a></li>
<li id="menu-item-58" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-58"><a href="https://github.com/malisper">Github</a></li>
<li id="menu-item-59" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-59"><a href="https://news.ycombinator.com/user?id=malisper">Hacker News</a></li>
</ul></div></aside><aside id="archives-2" class="widget widget_archive"><h1 class="widget-title">Archives</h1>		<ul>
			<li><a href='../06/index.html'>June 2016</a></li>
	<li><a href='index.html'>April 2016</a></li>
	<li><a href='../01/index.html'>January 2016</a></li>
	<li><a href='../../2015/12/index.html'>December 2015</a></li>
	<li><a href='../../2015/11/index.html'>November 2015</a></li>
	<li><a href='../../2015/10/index.html'>October 2015</a></li>
	<li><a href='../../2015/09/index.html'>September 2015</a></li>
	<li><a href='../../2015/08/index.html'>August 2015</a></li>
	<li><a href='../../2015/07/index.html'>July 2015</a></li>
	<li><a href='../../2015/06/index.html'>June 2015</a></li>
	<li><a href='../../2015/05/index.html'>May 2015</a></li>
		</ul>
		</aside><aside id="categories-2" class="widget widget_categories"><h1 class="widget-title">Categories</h1>		<ul>
	<li class="cat-item cat-item-2"><a href="../../category/basics/index.html" title="These are basic Lisp macros that should be trivial to understand.">Basic Macros</a>
</li>
	<li class="cat-item cat-item-5"><a href="../../category/intermediate-macros/index.html" >Intermediate Macros</a>
</li>
	<li class="cat-item cat-item-6"><a href="../../category/advanced-macros/index.html" >Advanced Macros</a>
</li>
	<li class="cat-item cat-item-7"><a href="../../category/debugging-common-lisp/index.html" >Debugging Lisp</a>
</li>
	<li class="cat-item cat-item-8"><a href="../../category/loops-in-lisp/index.html" >Loops in Lisp</a>
</li>
		</ul>
</aside>	</div><!-- #secondary -->
	</div><!-- .slide-menu -->
<div id="page" class="hfeed site">
	<a class="skip-link screen-reader-text" href="#content">Skip to content</a>

	<header id="masthead" class="site-header" role="banner">

		<div class="site-branding">
						<h1 class="site-title"><a href="../../index.html" rel="home">Macrology</a></h1>
		</div>

	</header><!-- #masthead -->

	
	
	<div id="content" class="site-content">


	<section id="primary" class="content-area">
		<main id="main" class="site-main" role="main">

		
			<header class="page-header">
				<h1 class="page-title">Month: April 2016</h1>			</header><!-- .page-header -->

			
				
					
<article id="post-1410" class="post-1410 post type-post status-publish format-standard hentry category-basics">
	<header class="entry-header">
					<h1 class="entry-title"><a href="20/writing-self-referential-programs/index.html" rel="bookmark">How to Generate Self-Referential Programs</a></h1>			</header><!-- .entry-header -->
			<div class="entry-content">
			<p>In this post, I am going to show you how to write programs that are self-referential. By self-referential, I mean programs which are able to obtain their own source code without any external input. In other words, they won&#8217;t just read from their own files. This post is based on section 6.1 of the book <em>Introduction to the Theory of Computation</em>.</p>
<p>Before we can start generating self-referential programs we are first going to need some techniques for generating programs in general. The first technique we need is a method of taking a given program and writing a second program that outputs the given program. As an example, given (+ 2 2), we would need to write a program that outputs (+ 2 2). In most languages this is easy. One way to do it in Lisp is to put a quote in front of the program:</p>
<pre class="brush: plain; title: ; notranslate" title="">
'(+ 2 2)
=&gt; (+ 2 2)
</pre>
<p>We are also going to need a function that automates this process. Such a function would take a program as its argument and return a new program that when ran, outputs the program that was originally passed to the function. In most languages doing this is fairly tricky. In Lisp, we can write this function easily through backquote:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defun code-that-generates (program)
  `',program)

(code-that-generates '(+ 2 2))
=&gt; '(+ 2 2)
</pre>
<p>If you don&#8217;t understand how backquote works, you can read <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Backquote.html">this</a>. Even though it&#8217;s for Emacs Lisp, everything there is still applicable to other Lisps. Just make sure that you understand that <strong>code-that-generates</strong> can be used to generate a program that outputs a given program.</p>
<p>Now that we have these two techniques, we can begin writing programs that are able to refer to themselves. The first self-referential program we will write will be an example of a <em>quine</em>. If you don&#8217;t know, a quine is a program that outputs its own source code. The quine we are going to write is made up of two parts, part A and part B, where part A is a function that is applied to part B:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(A B)
</pre>
<p>To describe how the quine works, it is easiest to start with part B. All that part B needs to do is return the source code of part A:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(A 'A)
</pre>
<p>Part A&#8217;s job is to take its own source code, and use it to obtain the source code of the entire quine. Since B is a program that outputs A, A can use <strong>code-that-generates</strong> on its own source code in order to obtain the source code of B. Once A has the source code of both A and B, it becomes trivial to combine the two to obtain the source code of the entire quine. Here is the complete quine, with the call to <strong>code-that-generates</strong> inlined:</p>
<pre class="brush: plain; title: ; notranslate" title="">
((lambda (a)
   (let ((b `',a))
     `(,a ,b)))
 '(lambda (a)
    (let ((b `',a))
      `(,a ,b))))
=&gt;
((lambda (a)
   (let ((b `',a))
     `(,a ,b)))
 '(lambda (a)
    (let ((b `',a))
      `(,a ,b))))
</pre>
<p>Now this is where things start getting interesting. A quine can be thought of as a program that generates its own source code, and immediately returns it. What if instead of immediately returning its own source code, the quine applied a function to it first, and then returned the result of that. The steps for building such a program are almost exactly the same as the steps we took for building the quine. This time, there is a third part F, for the function we want to call. The structure of the program will look like the following:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(F AB)
</pre>
<p>Where AB has a similar structure to our quine. After breaking AB into the two parts, A and B, the program looks like the following:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(F (A B))
</pre>
<p>Part B in the above program has the same responsibilities as B in the quine, it returns the source code for A:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(F (A 'A))
</pre>
<p>Then once A has the source code for itself, it can use <strong>code-that-generates </strong>to obtain the source code for B. Now that it has the source of A and B, it is easy for it to construct AB. Once part A has the code for AB, it can easily generate the source of the entire program. Here is what the program becomes after filling in everything except F:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(F
 ((lambda (a)
    (let ((b `',a))
      (let ((ab `(,a ,b)))
        `(F ,ab))))
  '(lambda (a)
     (let ((b `',a))
       (let ((ab `(,a ,b)))
         `(F ,ab))))))
</pre>
<p>What makes this so awesome is that F can be any function we want, and the above program will run F with the source code of the entire program! For example, replacing F with <strong>identity</strong> causes the program to become a quine:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(identity
 ((lambda (a)
    (let ((b `',a))
      (let ((ab `(,a ,b)))
        `(identity ,ab))))
  '(lambda (a)
    (let ((b `',a))
      (let ((ab `(,a ,b)))
        `(identity ,ab))))))
=&gt;
(identity
 ((lambda (a)
    (let ((b `',a))
      (let ((ab `(,a ,b)))
        `(identity ,ab))))
  '(lambda (a)
    (let ((b `',a))
      (let ((ab `(,a ,b)))
        `(identity ,ab))))))
</pre>
<p>But we can also do some much more impressive things. We can replace F with a function that lists its argument twice, and get a program that returns a list containing its own source code twice:</p>
<pre class="brush: plain; title: ; notranslate" title="">
((lambda (x) (list x x))
 ((lambda (a)
    (let ((b `',a))
      (let ((ab `(,a ,b)))
        `((lambda (x) (list x x)) ,ab))))
  '(lambda (a)
     (let ((b `',a))
       (let ((ab `(,a ,b)))
         `((lambda (x) (list x x)) ,ab))))))

=&gt;

(((lambda (x) (list x x))
  ((lambda (a)
     (let ((b `',a))
       (let ((ab `(,a ,b)))
         `((lambda (x) (list x x)) ,ab))))
   '(lambda (a)
      (let ((b `',a))
        (let ((ab `(,a ,b)))
          `((lambda (x) (list x x)) ,ab))))))
 ((lambda (x) (list x x))
  ((lambda (a)
     (let ((b `',a))
       (let ((ab `(,a ,b)))
         `((lambda (x) (list x x)) ,ab))))
   '(lambda (a)
      (let ((b `',a))
        (let ((ab `(,a ,b)))
          `((lambda (x) (list x x)) ,ab)))))))
</pre>
<p>To make writing these self-referential programs easier, we can define a function that fills in F for us. It just requires a little nested backquote trickery.<span id='easy-footnote-1' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='20/writing-self-referential-programs/index.html#easy-footnote-bottom-1' title='You may have noticed the extra comma and quote in front of F in the generated program. Although it doesn&#8217;t make a difference semantically it does make a different syntactically. Luckily, all of the code generated by a program with the extra comma and quote will also contain the extra comma and quote, so everything is okay.'><sup>1</sup></a></span></p>
<pre class="brush: plain; title: ; notranslate" title="">
(defun self-referential-version-of (f)
  `(,f
     ((lambda (a)
        (let ((b `',a))
          (let ((ab `(,a ,b)))
            `(,',f ,ab))))
       '(lambda (a)
          (let ((b `',a))
            (let ((ab `(,a ,b)))
              `(,',f ,ab)))))))

(self-referential-version-of '(lambda (x) (list x x))
=&gt;
((lambda (x) (list x x))
 ((lambda (a)
    (let ((b `',a))
      (let ((ab `(,a ,b)))
        `(,'(lambda (x) (list x x)) ,ab))))
  '(lambda (a)
     (let ((b `',a))
       (let ((ab `(,a ,b)))
         `(,'(lambda (x) (list x x)) ,ab))))))
</pre>
<p>Now that we&#8217;ve got a function that can generate self-referential programs for us, I am going to show you how to build something called a <em>quine-relay</em>. A quine-relay is like a normal quine, except it passes through multiple languages. The <em>quine-relay</em> we are going to write is a Lisp program that outputs a C program that outputs the original Lisp program. All we have to do is write a function that takes its argument and writes a C program that prints the argument it was given. Then we can pass that function to <strong>self-referential-version-of</strong> to get the quine-relay! That&#8217;s it! Here is a program that will generate the quine-relay:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(self-referential-version-of
  '(lambda (self)
     (format t

&quot;#include &lt;stdio.h&gt;~%int main(){printf(\&quot;%s\&quot;,~(~s~));}&quot;

             (remove #\newline (prin1-to-string self)))))
</pre>
<p>I&#8217;ve omitted the actual quine-relay for brevity, but you can find it <a href="https://gist.github.com/malisper/77db18aa8b1cb96fa7a984144eaf51aa">here</a> if you are curious. There are a few idiosyncrasies in the above program and in the quine-relay because of the differences in behavior between Lisp and C. For example, in C you can&#8217;t have multi-line strings, so it becomes easier to remove all of the newlines from the Lisp program, than it is to keep them.</p>
<p>And that&#8217;s all it takes to write self-referential programs. After seeing how easy it is to generate a quine-relay, it shouldn&#8217;t be hard to imagine how to write one with many more steps. You may even be able to get up to <a href="https://github.com/mame/quine-relay">100</a> if you work at it long enough.</p>
					</div><!-- .entry-content -->
				<div class="entry-meta clear">
			<span class="posted-on">Posted on <a href="20/writing-self-referential-programs/index.html" rel="bookmark"><time class="entry-date published" datetime="2016-04-20T00:39:07+00:00">April 20, 2016</time><time class="updated" datetime="2016-04-20T00:57:04+00:00">April 20, 2016</time></a></span><span class="byline"> by <span class="author vcard"><a class="url fn n" href="../../author/malisper/index.html">malisper</a></span></span>			<span class="secondary-entry-meta">
																	<span class="comments-link"><a href="20/writing-self-referential-programs/index.html#respond">0</a></span>							</span>
		</div><!-- .entry-meta -->
	</article><!-- #post-## -->

				
					
<article id="post-1366" class="post-1366 post type-post status-publish format-standard hentry category-advanced-macros category-loops-in-lisp">
	<header class="entry-header">
					<h1 class="entry-title"><a href="13/loops-in-lisp-part-4-series/index.html" rel="bookmark">Loops in Lisp Part 4: Series</a></h1>			</header><!-- .entry-header -->
			<div class="entry-content">
			<p><em>This is part four of Loops in Lisp. Follow one of the following links for part <a href="../../2015/11/24/loops-lisp-part-1-goto/index.html">one</a>, <a href="../../2015/12/15/loops-in-lisp-part-2-loop/index.html">two</a>, or <a href="../01/12/loops-in-lisp-part-3-iterate/index.html">three</a>).</em></p>
<p>One of the many advantages of programming in a functional style (by this, I mean manipulating your data through the operations, map, fold, and filter) is that your program winds up being made up a bunch of tiny and composable pieces. Since each piece is so small, usually only a few lines each, it becomes trivial to unit test the entire program. Additionally, it is easy to express new features as just the composition of several existing functions. One disadvantage of programming through map and friends, is that there is fairly large time penalty for allocating the intermediate results. For example, every time filter is called on a list, a new list needs to be allocated. These costs add up pretty quickly and can make a functional program much slower than its imperative equivalent.</p>
<p>One solution to this problem is laziness. Instead of allocating a new list every time an operation is performed on a list, you instead keep track of all of the transformations made on the list. Then when you fold over the list, you perform all of the transformations as you are folding over it. By doing this, you don&#8217;t need to allocate intermediate lists. Although laziness doesn&#8217;t allocate any intermediate lists, there is still a small cost for keeping track of the laziness. An alternative solution that makes functional programming just as fast as imperative programming is provided by the Series library.<span id='easy-footnote-1' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='13/loops-in-lisp-part-4-series/index.html#easy-footnote-bottom-1' title='The technique used by Series is sometimes referred to as &#8220;stream fusion&#8221;.'><sup>1</sup></a></span> Series lets you write your program in a functional style without <em>any</em> runtime penalty at all!</p>
<p>Personally, the Series library is my favorite example of the magic that can be pulled off with macros. In short, Series works by taking your functional code and compiling it down into a single loop. In this loop, there is one step per transformation performed on the original list. The loop iterates over the values of the original sequence on at a time. On each iteration, the loop takes a single element, performs all of the transformations performed on the list on that single element, and then accumulates that value into the result according to the folding operation. This loop requires no additional memory allocation at runtime, and their is no time penalty either! As an example, here is a program that sums the first N squares, written using Series:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defun integers ()
  &quot;Returns a 'series' of all of the natural numbers.&quot;
  (declare (optimizable-series-function))
  (scan-range :from 1))

(defun squares ()
  &quot;Returns a 'series' of all of the square numbers.&quot;
  (declare (optimizable-series-function))
  (map-fn t 
          (lambda (x) (* x x)) 
          (integers)))

(defun sum-squares (n)
  &quot;Returns the sum of the first N square numbers.&quot;
  (collect-sum (subseries (squares) 0 n)))

(sum-squares 10)
=&gt; 385
</pre>
<p>The above code certainly looks functional, there are no side effects in sight. Now let&#8217;s look at the code generated by Series. Here is what the macroexpansion of <strong>collect-sum</strong> looks like:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(common-lisp:let* ((#:out-969 n))
  (common-lisp:let ((#:numbers-966
                     (coerce-maybe-fold (- 1 1) 'number))
                    #:items-967
                    (#:index-965 -1)
                    (#:sum-959 0))
    (declare (type number #:numbers-966)
             (type (integer -1) #:index-965)
             (type number #:sum-959))
    (tagbody
       #:ll-970
       (setq #:numbers-966
             (+ #:numbers-966
                (coerce-maybe-fold 1 'number)))
       (setq #:items-967
             ((lambda (x) (* x x)) #:numbers-966))
       (incf #:index-965)
       (locally
          (declare (type nonnegative-integer #:index-965))
         (if (&gt;= #:index-965 #:out-969)
             (go end))
         (if (&lt; #:index-965 0)
             (go #:ll-970)))
       (setq #:sum-959 (+ #:sum-959 #:items-967))
       (go #:ll-970)
     end)
    #:sum-959))
</pre>
<p>What series does it looks at the entire lifetime of the sequence from its creation until it is folded. It uses this information to build the above loop which simultaneously generates the original sequence, maps over it, filters elements out of it, and folds it into the final result. Here is the breakdown of the expansion. Lines 1-9 are just initialization. They define all of the variables the loop will be using and set them to their starting values. The important variables to keep track of are #:NUMBERS-966, #:ITEMS-967, and #:SUM-959. As the code &#8220;iterates&#8221; over the original sequence, #:NUMBERS-966 is the value of the original sequence, #:ITEMS-967 is the square of that value, and #:SUM-959 is the sum of the squares so far. The rest of the code is the actual loop.</p>
<p>The loop first takes #:NUMBERS-966, the previous value of the sequence, and increments it in order to set it to current value of the sequence (since the sequence is the range from 1 to infinity). Next the loop takes the square of #:NUMBERS-966 to get the ith square number and stores that in #:ITEMS-967. Then the loop checks if it ha taken more than N elements out of the sequence, and if so, terminates. Finally the loop takes the value in #:ITEMS-967 and accumulates that into #:SUM-959.</p>
<p>Although the imperative version is equivalent to the original functional code, it is much faster than the functional code if the functional code were to allocate intermediate results or use laziness. This idea of turning transformations on a list into a loop doesn&#8217;t just work for this simple example, it also works for much more complicated programs. I just find it incredible that Series is able to take such pretty code and compile it into code that is extremely fast.</p>
					</div><!-- .entry-content -->
				<div class="entry-meta clear">
			<span class="posted-on">Posted on <a href="13/loops-in-lisp-part-4-series/index.html" rel="bookmark"><time class="entry-date published" datetime="2016-04-13T03:06:36+00:00">April 13, 2016</time><time class="updated" datetime="2016-04-14T03:44:39+00:00">April 14, 2016</time></a></span><span class="byline"> by <span class="author vcard"><a class="url fn n" href="../../author/malisper/index.html">malisper</a></span></span>			<span class="secondary-entry-meta">
																	<span class="comments-link"><a href="13/loops-in-lisp-part-4-series/index.html#comments">4</a></span>							</span>
		</div><!-- .entry-meta -->
	</article><!-- #post-## -->

				
			
		
		</main><!-- #main -->
	</section><!-- #primary -->


	</div><!-- #content -->

	<footer id="colophon" class="site-footer" role="contentinfo">
		<div class="site-info">
			<a href="http://wordpress.org/">Proudly powered by WordPress</a>
			<span class="sep"> ~ </span>
			Theme: Scrawl by <a href="https://wordpress.com/themes/" rel="designer">WordPress.com</a>.		</div><!-- .site-info -->
	</footer><!-- #colophon -->
</div><!-- #page -->

<script type='text/javascript' src='../../wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shCore09b1.js?ver=3.0.9b'></script>
<script type='text/javascript' src='../../wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shBrushPlain09b1.js?ver=3.0.9b'></script>
<script type='text/javascript'>
	(function(){
		var corecss = document.createElement('link');
		var themecss = document.createElement('link');
		var corecssurl = "../../wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shCore09b1.css?ver=3.0.9b";
		if ( corecss.setAttribute ) {
				corecss.setAttribute( "rel", "stylesheet" );
				corecss.setAttribute( "type", "text/css" );
				corecss.setAttribute( "href", corecssurl );
		} else {
				corecss.rel = "stylesheet";
				corecss.href = corecssurl;
		}
		document.getElementsByTagName("head")[0].insertBefore( corecss, document.getElementById("syntaxhighlighteranchor") );
		var themecssurl = "../../wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shThemeEclipse09b1.css?ver=3.0.9b";
		if ( themecss.setAttribute ) {
				themecss.setAttribute( "rel", "stylesheet" );
				themecss.setAttribute( "type", "text/css" );
				themecss.setAttribute( "href", themecssurl );
		} else {
				themecss.rel = "stylesheet";
				themecss.href = themecssurl;
		}
		//document.getElementById("syntaxhighlighteranchor").appendChild(themecss);
		document.getElementsByTagName("head")[0].insertBefore( themecss, document.getElementById("syntaxhighlighteranchor") );
	})();
	SyntaxHighlighter.config.strings.expandSource = '+ expand source';
	SyntaxHighlighter.config.strings.help = '?';
	SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
	SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
	SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
	SyntaxHighlighter.defaults['pad-line-numbers'] = false;
	SyntaxHighlighter.defaults['toolbar'] = false;
	SyntaxHighlighter.all();
</script>
<link rel='stylesheet' id='qtipstyles-css'  href='../../wp-content/plugins/easy-footnotes/assets/qtip/jquery.qtip.min167b.css?ver=4.6' type='text/css' media='' />
<link rel='stylesheet' id='easyfootnotescss-css'  href='../../wp-content/plugins/easy-footnotes/assets/easy-footnotes167b.css?ver=4.6' type='text/css' media='' />
<link rel='stylesheet' id='dashicons-css'  href='../../wp-includes/css/dashicons.min167b.css?ver=4.6' type='text/css' media='all' />
<script type='text/javascript' src='../../wp-content/themes/scrawl-wpcom/js/scrawld56c.js?ver=20150309'></script>
<script type='text/javascript' src='../../wp-content/themes/scrawl-wpcom/js/skip-link-focus-fix08e0.js?ver=20130115'></script>
<script type='text/javascript' src='../../wp-includes/js/wp-embed.min167b.js?ver=4.6'></script>
<script type='text/javascript' src='../../wp-includes/js/imagesloaded.min55a0.js?ver=3.2.0'></script>
<script type='text/javascript' src='../../wp-content/plugins/easy-footnotes/assets/qtip/jquery.qtip.min167b.js?ver=4.6'></script>
<script type='text/javascript' src='../../wp-content/plugins/easy-footnotes/assets/qtip/jquery.qtipcall167b.js?ver=4.6'></script>

</body>

<!-- Mirrored from malisper.me/2016/04/ by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 01 Sep 2016 17:46:26 GMT -->
</html>
<!-- Dynamic page generated in 0.173 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2016-09-01 12:14:23 -->

<!-- super cache -->