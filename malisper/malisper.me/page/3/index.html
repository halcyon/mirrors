<!DOCTYPE html>
<html lang="en-US" prefix="og: http://ogp.me/ns#">

<!-- Mirrored from malisper.me/page/3/ by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 01 Sep 2016 17:46:39 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Macrology - Page 3 of 3 - Case Studies in Lisp Macros</title>
<link rel="profile" href="http://gmpg.org/xfn/11">
<link rel="pingback" href="../../xmlrpc.php">


<!-- This site is optimized with the Yoast SEO plugin v3.4.2 - https://yoast.com/wordpress/plugins/seo/ -->
<meta name="description" content="Case Studies in Lisp Macros"/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="index.html" />
<link rel="prev" href="../2/index.html" />
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="website" />
<meta property="og:title" content="Macrology - Page 3 of 3 - Case Studies in Lisp Macros" />
<meta property="og:description" content="Case Studies in Lisp Macros" />
<meta property="og:url" content="index.html" />
<meta property="og:site_name" content="Macrology" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:description" content="Case Studies in Lisp Macros" />
<meta name="twitter:title" content="Macrology - Page 3 of 3 - Case Studies in Lisp Macros" />
<script type='application/ld+json'>{"@context":"http:\/\/schema.org","@type":"WebSite","url":"http:\/\/malisper.me\/","name":"Macrology","potentialAction":{"@type":"SearchAction","target":"http:\/\/malisper.me\/?s={search_term_string}","query-input":"required name=search_term_string"}}</script>
<!-- / Yoast SEO plugin. -->

<link rel='dns-prefetch' href='http://fonts.googleapis.com/'>
<link rel="alternate" type="application/rss+xml" title="Macrology &raquo; Feed" href="../../feed/index.html" />
<link rel="alternate" type="application/rss+xml" title="Macrology &raquo; Comments Feed" href="../../comments/feed/index.html" />
<link rel='stylesheet' id='scrawl-style-css'  href='../../wp-content/themes/scrawl-wpcom/style167b.css?ver=4.6' type='text/css' media='all' />
<link rel='stylesheet' id='scrawl-fonts-css'  href='https://fonts.googleapis.com/css?family=Lora:400,700|Merriweather:400italic,400,700,700italic&amp;subset=latin%2Clatin-ext' type='text/css' media='all' />
<link rel='stylesheet' id='genericons-css'  href='../../wp-content/themes/scrawl-wpcom/fonts/genericons6de8.css?ver=3.3' type='text/css' media='all' />
<script type='text/javascript' src='../../wp-includes/js/jquery/jqueryb8ff.js?ver=1.12.4'></script>
<script type='text/javascript' src='../../wp-includes/js/jquery/jquery-migrate.min330a.js?ver=1.4.1'></script>
<link rel='https://api.w.org/' href='../../wp-json/index.html' />
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="../../xmlrpc0db0.php?rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="../../wp-includes/wlwmanifest.xml" /> 
<meta name="generator" content="WordPress 4.6" />
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-63547056-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
<style type="text/css" id="syntaxhighlighteranchor"></style>

<script type="text/javascript">
  window.heap=window.heap||[],heap.load=function(e,t){window.heap.appid=e,window.heap.config=t=t||{};var n=t.forceSSL||"https:"===document.location.protocol,a=document.createElement("script");a.type="text/javascript",a.async=!0,a.src=(n?"https:":"http:")+"//cdn.heapanalytics.com/js/heap-"+e+".js";var o=document.getElementsByTagName("script")[0];o.parentNode.insertBefore(a,o);for(var r=function(e){return function(){heap.push([e].concat(Array.prototype.slice.call(arguments,0)))}},p=["clearEventProperties","identify","setEventProperties","track","unsetEventProperty"],c=0;c<p.length;c++)heap[p[c]]=r(p[c])};
    heap.load("931515525");
</script>
</head>

<body class="home blog paged paged-3">
	<button class="menu-toggle x">
		<span class="lines"></span>
		<span class="screen-reader-text">Primary Menu</span>
	</button>
	<div class="slide-menu">
				
		<h1 class="site-title"><a href="../../index.html" rel="home">Macrology</a></h1>
		<h2 class="site-description">Case Studies in Lisp Macros</h2>
		
				
				
			<div id="secondary" class="widget-area" role="complementary">
		<aside id="search-2" class="widget widget_search"><form role="search" method="get" class="search-form" action="http://malisper.me/">
				<label>
					<span class="screen-reader-text">Search for:</span>
					<input type="search" class="search-field" placeholder="Search &hellip;" value="" name="s" />
				</label>
				<input type="submit" class="search-submit" value="Search" />
			</form></aside><aside id="pages-3" class="widget widget_pages"><h1 class="widget-title">Pages</h1>		<ul>
			<li class="page_item page-item-55"><a href="../../about-me/index.html">About Michael Malis</a></li>
<li class="page_item page-item-44"><a href="../../about-this-site-2/index.html">About This Site</a></li>
		</ul>
		</aside><aside id="nav_menu-3" class="widget widget_nav_menu"><h1 class="widget-title">Contact Me</h1><div class="menu-contact-me-container"><ul id="menu-contact-me" class="menu"><li id="menu-item-60" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-60"><a href="mailto:michaelmalis2@gmail.com">Email</a></li>
<li id="menu-item-58" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-58"><a href="https://github.com/malisper">Github</a></li>
<li id="menu-item-59" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-59"><a href="https://news.ycombinator.com/user?id=malisper">Hacker News</a></li>
</ul></div></aside><aside id="archives-2" class="widget widget_archive"><h1 class="widget-title">Archives</h1>		<ul>
			<li><a href='../../2016/06/index.html'>June 2016</a></li>
	<li><a href='../../2016/04/index.html'>April 2016</a></li>
	<li><a href='../../2016/01/index.html'>January 2016</a></li>
	<li><a href='../../2015/12/index.html'>December 2015</a></li>
	<li><a href='../../2015/11/index.html'>November 2015</a></li>
	<li><a href='../../2015/10/index.html'>October 2015</a></li>
	<li><a href='../../2015/09/index.html'>September 2015</a></li>
	<li><a href='../../2015/08/index.html'>August 2015</a></li>
	<li><a href='../../2015/07/index.html'>July 2015</a></li>
	<li><a href='../../2015/06/index.html'>June 2015</a></li>
	<li><a href='../../2015/05/index.html'>May 2015</a></li>
		</ul>
		</aside><aside id="categories-2" class="widget widget_categories"><h1 class="widget-title">Categories</h1>		<ul>
	<li class="cat-item cat-item-2"><a href="../../category/basics/index.html" title="These are basic Lisp macros that should be trivial to understand.">Basic Macros</a>
</li>
	<li class="cat-item cat-item-5"><a href="../../category/intermediate-macros/index.html" >Intermediate Macros</a>
</li>
	<li class="cat-item cat-item-6"><a href="../../category/advanced-macros/index.html" >Advanced Macros</a>
</li>
	<li class="cat-item cat-item-7"><a href="../../category/debugging-common-lisp/index.html" >Debugging Lisp</a>
</li>
	<li class="cat-item cat-item-8"><a href="../../category/loops-in-lisp/index.html" >Loops in Lisp</a>
</li>
		</ul>
</aside>	</div><!-- #secondary -->
	</div><!-- .slide-menu -->
<div id="page" class="hfeed site">
	<a class="skip-link screen-reader-text" href="#content">Skip to content</a>

	<header id="masthead" class="site-header" role="banner">

		<div class="site-branding">
						<h1 class="site-title"><a href="../../index.html" rel="home">Macrology</a></h1>
		</div>

	</header><!-- #masthead -->

	
	
	<div id="content" class="site-content">


	<div id="primary" class="content-area">
		<main id="main" class="site-main" role="main">

		
						
				
<article id="post-173" class="post-173 post type-post status-publish format-standard hentry category-advanced-macros">
	<header class="entry-header">
					<h1 class="entry-title"><a href="../../2015/06/10/cl-who/index.html" rel="bookmark">CL-WHO</a></h1>			</header><!-- .entry-header -->
			<div class="entry-content">
			<p>The <a href="http://weitz.de/cl-who/">CL-WHO</a> library is one of many that make it easy to generate HTML. When first checking out CL-WHO, I thought that it must be at least a couple thousand lines of code long. As it turns out, it is only several hundred. At the core of CL-WHO is <strong>with-html-output</strong> (hence the name &#8220;who&#8221;), which allows one to use a DSL for generating HTML. <strong>With-html-output</strong> works like all macros. At a high level, it takes your code in the DSL, and compiles it into Lisp code that will generate the desired HTML (<a href="http://weitz.de/cl-who/#example">here</a> are some examples).</p>
<p><strong>With-html-output</strong> does little by itself. Almost all of the work is done by three functions: <strong>tree-to-template</strong>, <strong>process-tag</strong>, and <strong>convert-tag-to-string-list</strong>. Most of the time these functions call one another recursively in order to process the entire DSL. It is possible to customize the control flow, but I will get to that later. <a href="https://gist.github.com/malisper/fe2cf8158714c196ec03">Here</a> is a link to a gist of the output after tracing all of the functions and using <strong>macroexpand-1</strong> to expand a simple example. The example only shows what happens when using basic tags in CL-WHO. It doesn&#8217;t show what happens when you embed Lisp expressions in the DSL.</p>
<p><strong>Tree-to-template</strong> is the entry point into the compilation process. It loops through the DSL tree, and builds up a &#8220;template&#8221;. A template is just a list of strings and expressions. The strings in the template contain HTML and are meant to be printed directly to the HTML stream. On the other hand, the expressions contain code that will print objects to that stream. Eventually all of this output put together will be the desired HTML. As <strong>tree-to-template</strong> loops through the code, if it sees a non-tag, it will just collect that into the list.<span id='easy-footnote-1' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../2015/06/10/cl-who/index.html#easy-footnote-bottom-1' title='It actually wraps it with a let that binds *indent* in order to handle indentation properly.'><sup>1</sup></a></span> When it does see a tag, <strong>tree-to-template</strong> calls <strong>process-tag</strong> to process it, and then concatenates the result of that into the template.</p>
<p><strong>Process-tag</strong> will extract the tag as well as the attribute list. Everything after the attribute list makes up the &#8220;body&#8221; of the tag. How is the body processed? Well, <strong>process-tag</strong> takes an additional argument, <em>body-fn</em>, which specifies how to process the body. <strong>Process-tag</strong> will then call <strong>convert-tag-to-string-list</strong> with the tag, the attribute list, the body, and <em>body-fn</em>. The reason <strong>process-tag</strong> doesn&#8217;t process the body itself is that <strong>convert-tag-to-string-list</strong> is a generic function, making it possible to customize its behavior.</p>
<p><strong>Convert-tag-to-string-list</strong> handles the semantics of the tag. It takes all of the arguments above and returns a list of strings and expressions. That list will become part of the template eventually returned by <strong>tree-to-template</strong>. Since <strong>c</strong><strong>onvert-tag-to-string-list</strong> is a generic function, it is possible to extend it. The documentation for CL-WHO gives an example of how one could create a custom &#8220;red&#8221; tag which changes the font of the text to red, even though there is no such HTML tag. In the default case, <strong>convert-tag-to-string-list</strong> takes the result from calling <em>body-fn</em> on <em>body</em> and surrounds that with strings for the opening and closing tags. Since <b>convert-tag-to-string-list</b> is customizable, it is possible to change the control flow and ultimately how the body is processed. If one wanted, they could make a call to <strong>process-tag</strong>, but with a different <em>body-fn</em> argument, changing how the code is processed further up (down?) the tree.</p>
<p>With the help of these functions <strong>with-html-output</strong> converts the DSL into a template. The template is then turned into a list of valid Lisp code.<span id='easy-footnote-2' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../2015/06/10/cl-who/index.html#easy-footnote-bottom-2' title='The first thing with-html-output does is pass the DSL tree to tree-to-commands. Tree-to-commands is the function that handles the entire process of converting the tree into valid Lisp code. Tree-to-commands just calls tree-to-template to do most of the work.'><sup>2</sup></a></span> <strong>With-html-output</strong> then wraps the body with a <strong>macrolet</strong> which binds several local macros. These macros are: <strong>htm, fmt, esc, str</strong>. These macros make it easier to print objects to the stream used for output. Check out the documentation for CL-WHO for a more detailed description of what these macros do.</p>
<p>I really like CL-WHO. It is a great example of an embedded DSL. A Lisp hacker still has full access to Lisp from within what is a great DSL. The only problem I have with CL-WHO is the inability to have macros expand into code for the DSL. This decreases the flexibility of CL-WHO somewhat. The only way I can see to fix this problem would be to use a library such as :hu.dwim.walker to expand all of the macros in advance.</p>
					</div><!-- .entry-content -->
				<div class="entry-meta clear">
			<span class="posted-on">Posted on <a href="../../2015/06/10/cl-who/index.html" rel="bookmark"><time class="entry-date published" datetime="2015-06-10T10:31:01+00:00">June 10, 2015</time><time class="updated" datetime="2015-07-04T15:55:37+00:00">July 4, 2015</time></a></span><span class="byline"> by <span class="author vcard"><a class="url fn n" href="../../author/malisper/index.html">malisper</a></span></span>			<span class="secondary-entry-meta">
																	<span class="comments-link"><a href="../../2015/06/10/cl-who/index.html#respond">0</a></span>							</span>
		</div><!-- .entry-meta -->
	</article><!-- #post-## -->

			
				
<article id="post-111" class="post-111 post type-post status-publish format-standard hentry category-intermediate-macros">
	<header class="entry-header">
					<h1 class="entry-title"><a href="../../2015/06/06/once-only/index.html" rel="bookmark">Once-only</a></h1>			</header><!-- .entry-header -->
			<div class="entry-content">
			<p>One of the most common mistakes made when writing macros is evaluating one of the arguments multiple times. Not only can this be inefficient, but when side effects are involved, it leads to quirky behavior. Take a macro <strong>square</strong>, which simply squares its argument (in reality one would use a function to do this):</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defmacro square (x)
  `(* ,x ,x))
</pre>
<p>The above implementation is buggy. Why? Because the <em>x</em> argument is evaluated twice. To see why this is a bad thing, check out the following code:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(square (incf a))
</pre>
<p>The above winds up expanding into:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(* (incf a) (incf a))
</pre>
<p>Which is buggy since it increments <em>a</em> twice. A way to fix this problem is to bind the value of <em>x</em> to a gensym, and then use that gensym throughout the rest of the macro. Here is a bug free definition of <strong>square</strong> that uses <a href="../../2015/06/02/automatically-binding-gensyms/index.html">with-gensyms</a>:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defmacro square (x)
  (with-gensyms (gx)
    `(let ((,gx ,x))
       (* ,gx ,gx))))
</pre>
<p>Is there a way to automate this? Yes, there is, by using a macro called <strong>once-only</strong>. <strong>Once-only</strong> is a relatively complicated macro, but it eliminates lots of boilerplate code. <strong>Once-only</strong> takes a list of expressions, generally arguments to a macro, and makes sure they are evaluated only once in the final macro expansion. Here is an implementation of <strong>once-only</strong> based on the one from <a href="http://www.gigamonkeys.com/book/">Practical Common Lisp</a>:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defmacro once-only ((&amp;rest names) &amp;body body)
  (let ((gensyms (loop for n in names collect (gensym))))
    `(with-gensyms (,@gensyms)
      `(let (,,@(loop for g in gensyms
                      for n in names
                      collect ``(,,g ,,n)))
        ,(let (,@(loop for n in names
                       for g in gensyms
                       collect `(,n ,g)))
           ,@body)))))
</pre>
<p>In order to explain how <strong>once-only</strong> works, I&#8217;m first going to show how to rewrite <strong>square</strong> using it. From there I will show what <strong>square</strong> looks like after <strong>once-only</strong> has been expanded. After that I will show what the macro expansion of <strong>square</strong> looks like. Finally, I will give an explanation as to what is going on. If you are reading on a computer, I strongly recommed you open this page in another window so you can follow along with the code and the explanation at the same time. Here is an implementation of <strong>square</strong> that uses <strong>once-only</strong>:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defmacro square (x)
  (once-only (x)
    `(* ,x ,x)))
</pre>
<p>Here is what <strong>square</strong> looks like after <strong>once-only </strong>has been expanded inline:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defmacro square (x)
  (with-gensyms (#:g830)
    `(let (,`(,#:g830 ,x))
       ,(let ((x #:g830))
          `(* ,x ,x)))))
</pre>
<p>So a usage of <strong>square</strong> such as the following:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(square (incf x))
</pre>
<p>will wind up looking like the code below after macro expansion.</p>
<pre class="brush: plain; title: ; notranslate" title="">
(let ((#:g831 (incf x)))
  (* #:g831 #:g831))
</pre>
<p>So what the heck is going on? In line 2 of <strong>once-only</strong>, it creates a list of gensyms, one for each of the expressions that should only be evaluated once. We then take these gensyms and on line 3, generate code that will bind them to fresh gensyms. That generated code becomes line 2 of <strong>square</strong> after <strong>once-only</strong> has been expanded. We need to do this because we are writing a macro that writes a macro or code that writes code that writes code. So, after <strong>once-only</strong> has been expanded, <strong>square</strong>’s body will contain a use of <strong>with-gensyms</strong> which will bind a bunch of gensyms to new gensyms every time <strong>square</strong> is ran. These fresh gensyms will eventually be the ones used to store the value of the expressions we want to be evaluated once only.</p>
<p>Now for lines 4-6. By using the double backquote, this code generates code that will generate code that will be part of the expansion of <strong>square</strong>. Lines 4-6 of <strong>once-only</strong> become line 3 of the definition of <strong>square</strong>, which becomes line 1 of the expansion of <strong>square</strong>. Basically the little segment</p>
<pre class="brush: plain; title: ; notranslate" title="">
``(,,g ,,n)
</pre>
<p>says to generate code that will generate code (double backquote), that will be a list containing the value of the value of <em>g</em>, and the value of the value of <em>n</em>. The value of <em>g</em> will be one of the gensyms we created in <strong>once-only</strong>. From line 3 of <strong>square </strong>after <strong>once-only</strong> has been expanded, we see that this gensym was <em>#:g830</em>. The value of <em>#:g830</em> will be another gensym, whatever it was bound to by <strong>with-gensyms</strong>. From the code will can see that this gensym was <em>#:g831</em>. The value of <em>n</em> will be one of the arguments to <strong>once-only</strong>. From the original code for <strong>square</strong> we see that the only argument to <strong>once-only</strong> is <em>x</em>. Then the value of<em> x</em>, or the value of the value of n, will be whatever is passed as the argument to the <strong>square</strong> macro, in this case (incf x). Ultimately the code looks like this as it goes through the multiple expansions:</p>
<pre class="brush: plain; title: ; notranslate" title="">
``(,,g ,,n) =&gt; `(,#:g830 ,x) =&gt; (#:g831 (incf x))
</pre>
<p>Lines 4-6 take a list of expressions similar to those in the middle of the above process, splices them into a let by using the comma-at, then evaluates each one of them by using the comma in order to evaluate them once more. This works because the single comma in ,,@ actually applies to every element in the spliced list. Here is an example that demonstrates this:</p>
<pre class="brush: plain; title: ; notranslate" title="">
``(,,@ '(x y z)) =&gt; `(,x ,y ,z)
</pre>
<p>Then on line 3 of <strong>square</strong> after <strong>once-only</strong> has been expanded, we wind up with the comma followed by a backquote which wind up canceling each other out. So this is how lines 4-6 of <strong>once-only</strong> get us line 3 of <strong>square</strong> which then gives us line 1 of the expansion of square.</p>
<p>Now for lines 7-10 of <strong>once-only</strong>. These lines generate lines 4 and 5 of the code for <strong>square</strong> after <strong>once-only</strong> has been expanded. All these lines do is generate code that will bind the given names to the gensyms that will contain their values at runtime. In this case we want to bind <em>x</em> to the gensym <em>#:g831</em>. Since the value of <em>#:g830</em> is <em>#:g831</em>, we can just bind <em>x</em> to the value of <em>#:g830</em>. Then we just evaluate the body in this environment. By doing this, we bind <em>x</em> to an expression that will give us the same value as the expression previously contained in <em>x</em>! And that is how <strong>once-only</strong> ultimately works. In the expansion of <b>square</b>, we bind <em>#:g831</em> to the value of (incf x). Then we bind <em>x</em> to <em>#:g831</em> so any where we insert the expression <em>x</em>, we get<em> #:g831</em>, a gensym which is bound to the value of the expression that was initially bound to <em>x</em>, but only evaluated once.</p>
<p>Ultimately, <strong>once-only</strong> is a fairly useful macro. Like <b>with-gensyms</b> it is a utility for writing other macros. <strong>Once-only</strong> greatly reduces boiler plate and complexity in cases where it is used. It is because of these reasons <strong>once-only</strong> is one of the most popular macros out there.</p>
					</div><!-- .entry-content -->
				<div class="entry-meta clear">
			<span class="posted-on">Posted on <a href="../../2015/06/06/once-only/index.html" rel="bookmark"><time class="entry-date published" datetime="2015-06-06T23:31:21+00:00">June 6, 2015</time><time class="updated" datetime="2015-06-20T13:14:59+00:00">June 20, 2015</time></a></span><span class="byline"> by <span class="author vcard"><a class="url fn n" href="../../author/malisper/index.html">malisper</a></span></span>			<span class="secondary-entry-meta">
																	<span class="comments-link"><a href="../../2015/06/06/once-only/index.html#comments">4</a></span>							</span>
		</div><!-- .entry-meta -->
	</article><!-- #post-## -->

			
				
<article id="post-102" class="post-102 post type-post status-publish format-standard hentry category-basics">
	<header class="entry-header">
					<h1 class="entry-title"><a href="../../2015/06/02/automatically-binding-gensyms/index.html" rel="bookmark">Automatically Binding Gensyms</a></h1>			</header><!-- .entry-header -->
			<div class="entry-content">
			<p>One of the most common macros that almost everyone keeps in their utilities file is <strong>with-gensyms</strong>. <strong>With-gensyms</strong> is a macro that binds a list of variables to gensyms. That&#8217;s it! All <strong>with-gensyms</strong> does it take a list of symbols and generates code which binds each of those symbols to a gensym.  Although <strong>with-gensyms</strong> is simple, it removes a lot of boiler plate code. Here is a simple implementation of <strong>with-gensyms</strong>:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defmacro with-gensyms (vars &amp;body body)
  `(let ,(loop for v in vars collect `(,v (gensym)))
     ,@body))
</pre>
<p>Looking at my implementation of <a href="../../2015/05/31/efficiently-building-lists/index.html">accum</a>, here is how one could simplify it by using <strong>with-gensyms</strong>. Pay attention to how much boiler plate is removed.</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defmacro accum (accfn &amp;body body)
  (with-gensyms (ghead gtail garg)
    `(let* ((,ghead (list nil))
            (,gtail ,ghead))
       (macrolet ((,accfn (,garg)
                    `(setf ,',gtail
                           (setf (cdr ,',gtail)
                                 (list ,,garg)))))
         ,@body
         (cdr ,ghead)))))
</pre>
<p>By removing so much boiler plate, <strong>with-gensyms</strong> helps greatly reduce the cognitive load in certain cases. This will be important when I introduce <strong>once-only</strong>, the next macro I plan to talk about. There are also other variations of <strong>with-gensyms</strong> such as the one in <a href="https://common-lisp.net/project/alexandria/">Alexandria</a> which makes it easier to have base names associated with the gensyms created.</p>
					</div><!-- .entry-content -->
				<div class="entry-meta clear">
			<span class="posted-on">Posted on <a href="../../2015/06/02/automatically-binding-gensyms/index.html" rel="bookmark"><time class="entry-date published" datetime="2015-06-02T13:53:36+00:00">June 2, 2015</time><time class="updated" datetime="2015-06-02T13:56:08+00:00">June 2, 2015</time></a></span><span class="byline"> by <span class="author vcard"><a class="url fn n" href="../../author/malisper/index.html">malisper</a></span></span>			<span class="secondary-entry-meta">
																	<span class="comments-link"><a href="../../2015/06/02/automatically-binding-gensyms/index.html#respond">0</a></span>							</span>
		</div><!-- .entry-meta -->
	</article><!-- #post-## -->

			
				
<article id="post-61" class="post-61 post type-post status-publish format-standard hentry category-intermediate-macros">
	<header class="entry-header">
					<h1 class="entry-title"><a href="../../2015/05/31/efficiently-building-lists/index.html" rel="bookmark">Efficiently Building Lists</a></h1>			</header><!-- .entry-header -->
			<div class="entry-content">
			<p>It is a common problem to need to build up a list of objects and keep all of the objects in the same order they were generated in. The idiom I see everyone use to solve this problem is to push the objects onto the head of a list as they are generated. Unfortunately, doing this reverses the initial order of the elements, so in order to preserve the ordering, a call to either <strong>reverse</strong> or <strong>nreverse</strong> is needed. For example, here is code from <a href="https://common-lisp.net/project/alexandria/">Alexandria</a> that converts an alist into a plist: <span id='easy-footnote-1' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../2015/05/31/efficiently-building-lists/index.html#easy-footnote-bottom-1' title='It is important to preserve order since an alist/plist can have multiple keys that are the same, in which case the first one in the list is generally the desired key.'><sup>1</sup></a></span></p>
<pre class="brush: plain; title: ; notranslate" title="">
(defun alist-plist (alist)
  (let (plist)
    (dolist (pair alist)
      (push (car pair) plist)
      (push (cdr pair) plist))
    (nreverse plist)))
</pre>
<p>A better method to build up a list is to add the elements to the tail of the list. By adding them to the tail, you avoid having to reverse the list later. This is the same technique that some implementations of <strong>Loop</strong> use for the &#8220;collect&#8221; clause in order to efficiently collect objects into lists.  In order to build up a list this way, you need to keep track of the head of the list (what you are ultimately going to return) and the tail of the list (where you add the next element). Doing all of that by hand would be painful. Instead we can write a macro to handle that for us automagically. Here is an implementation of <strong>accum</strong><span id='easy-footnote-2' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../2015/05/31/efficiently-building-lists/index.html#easy-footnote-bottom-2' title='This implementation of accum uses nested backquotes. For an explanation as to how double backquotes are processed, see Appendix C of Common Lisp the Language'><sup>2</sup></a></span>, a macro which makes accumulating elements easy and efficient.</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defmacro accum (accfn &amp;body body)
  (let ((ghead (gensym &quot;HEAD&quot;))
        (gtail (gensym &quot;TAIL&quot;))
        (garg  (gensym &quot;ARG&quot;)))
    `(let* ((,ghead (list nil))
            (,gtail ,ghead))
       (macrolet ((,accfn (,garg)
                    `(setf ,',gtail
                           (setf (cdr ,',gtail)
                                 (list ,,garg)))))
         ,@body
         (cdr ,ghead)))))
</pre>
<p><strong>Accum</strong> is an example of a macro that writes a macro, or code that writes code that writes code. In order to explain how <strong>accum</strong> works, I am going to show how to rewrite <strong>alist-plist</strong> using <strong>accum</strong> and then explain how <strong>accum</strong> expands into code that does what we desire. Here is an implementation of <strong>alist-plist</strong> that uses <strong>accum</strong> instead of using <strong>nreverse</strong>:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defun alist-plist (alist)
  (accum a
    (dolist (pair alist)
      (a (car pair))
      (a (cdr pair)))))
</pre>
<p>The above is both simpler and more efficient than the original version! Now for an explanation as to how it works. <strong>Accum</strong> works by generating a <strong>macrolet</strong> binding. <strong>Macrolet</strong> allows for the creation of lexically scoped macros. The lexically scoped macro is named by whatever is passed in as the &#8220;accfn&#8221; argument to <strong>accum</strong>, in this case &#8220;a&#8221;. That macro, named &#8220;a&#8221;, will take its argument and generate code that will evaluate the argument, and add the result of that to the tail of the list. Similar to how <strong>push</strong> is a macro that takes an argument and generates code that adds the result of evaluating that to the front of the list passed in as its second argument. After <strong>accum</strong> is expanded, the code will look like the following:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defun alist-plist (alist)
  (let* ((#:head1460 (list nil))
         (#:tail1461 #:head1460))
    (macrolet ((a (#:arg1462)
                 `(setf #:tail1461
                        (setf (cdr #:tail1461)
                              (list ,#:arg1462)))))
      (dolist (pair alist)
        (a (car pair))
        (a (cdr pair)))
      (cdr #:head1460))))
</pre>
<p>As you should be able to see, &#8220;a&#8221; becomes a local macro which does what I described above.</p>
<p>I find <b>accum</b> to be one of many similar macros. Macros that abstract out a common pattern, and at the same time, are more efficient than what a human would normally write by hand. While many of these macros may be trivial, they both simplify code and make it faster!</p>
					</div><!-- .entry-content -->
				<div class="entry-meta clear">
			<span class="posted-on">Posted on <a href="../../2015/05/31/efficiently-building-lists/index.html" rel="bookmark"><time class="entry-date published" datetime="2015-05-31T23:01:17+00:00">May 31, 2015</time><time class="updated" datetime="2015-07-04T15:57:00+00:00">July 4, 2015</time></a></span><span class="byline"> by <span class="author vcard"><a class="url fn n" href="../../author/malisper/index.html">malisper</a></span></span>			<span class="secondary-entry-meta">
																	<span class="comments-link"><a href="../../2015/05/31/efficiently-building-lists/index.html#comments">1</a></span>							</span>
		</div><!-- .entry-meta -->
	</article><!-- #post-## -->

			
				
<article id="post-8" class="post-8 post type-post status-publish format-standard hentry category-basics">
	<header class="entry-header">
					<h1 class="entry-title"><a href="../../2015/05/30/the-ret-macro/index.html" rel="bookmark">The Ret Macro</a></h1>			</header><!-- .entry-header -->
			<div class="entry-content">
			<p>The <strong>ret</strong> macro is simple, but useful. It allows you to bind a variable and simultaneously specify the final value of that variable as the result of the <strong>ret</strong> expression, hence the name &#8220;ret&#8221;, a blend of <strong>let</strong> and <strong>return</strong>. Here is the implementation of <strong>ret</strong>:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defmacro ret (var val &amp;body body)
  `(let ((,var ,val))
     ,@body
     ,var))
</pre>
<p>And now for an example. If you want to write a function that converts a hash-table into an alist, here is how you could do that using <strong>ret</strong>.</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defun table-&gt;alist (table)
  (ret result '()
    (maphash (lambda (k v)
               (push (cons k v) result))
             table)))
</pre>
<p>Personally, I find code using <strong>ret</strong> to be much clearer than the equivalent code using <strong>let</strong>. When writing the <b>let </b>version, I commonly find myself forgetting to return the value I want to at the end. <strong>Ret </strong>eliminates this problem by returning the result for me. The only downside I see to using <strong>ret</strong> is that it has the same problem as all of the &#8220;do&#8221; macros (dotimes, dolist, etc), they change where the resulting value comes from. Even so, this problem is much more mild with <strong>ret</strong> because <strong>ret</strong> will always change the control flow, whereas the &#8220;do&#8221; macros may or may not change the final value depending on the number of arguments passed to them.</p>
					</div><!-- .entry-content -->
				<div class="entry-meta clear">
			<span class="posted-on">Posted on <a href="../../2015/05/30/the-ret-macro/index.html" rel="bookmark"><time class="entry-date published" datetime="2015-05-30T16:31:59+00:00">May 30, 2015</time><time class="updated" datetime="2015-05-30T15:27:39+00:00">May 30, 2015</time></a></span><span class="byline"> by <span class="author vcard"><a class="url fn n" href="../../author/malisper/index.html">malisper</a></span></span>			<span class="secondary-entry-meta">
																	<span class="comments-link"><a href="../../2015/05/30/the-ret-macro/index.html#comments">2</a></span>							</span>
		</div><!-- .entry-meta -->
	</article><!-- #post-## -->

			
			
	<nav class="navigation posts-navigation" role="navigation">
		<h2 class="screen-reader-text">Posts navigation</h2>
		<div class="nav-links"><div class="nav-next"><a href="../2/index.html" >Newer posts</a></div></div>
	</nav>
		
		</main><!-- #main -->
	</div><!-- #primary -->


	</div><!-- #content -->

	<footer id="colophon" class="site-footer" role="contentinfo">
		<div class="site-info">
			<a href="http://wordpress.org/">Proudly powered by WordPress</a>
			<span class="sep"> ~ </span>
			Theme: Scrawl by <a href="https://wordpress.com/themes/" rel="designer">WordPress.com</a>.		</div><!-- .site-info -->
	</footer><!-- #colophon -->
</div><!-- #page -->

<script type='text/javascript' src='../../wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shCore09b1.js?ver=3.0.9b'></script>
<script type='text/javascript' src='../../wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shBrushPlain09b1.js?ver=3.0.9b'></script>
<script type='text/javascript'>
	(function(){
		var corecss = document.createElement('link');
		var themecss = document.createElement('link');
		var corecssurl = "../../wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shCore09b1.css?ver=3.0.9b";
		if ( corecss.setAttribute ) {
				corecss.setAttribute( "rel", "stylesheet" );
				corecss.setAttribute( "type", "text/css" );
				corecss.setAttribute( "href", corecssurl );
		} else {
				corecss.rel = "stylesheet";
				corecss.href = corecssurl;
		}
		document.getElementsByTagName("head")[0].insertBefore( corecss, document.getElementById("syntaxhighlighteranchor") );
		var themecssurl = "../../wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shThemeEclipse09b1.css?ver=3.0.9b";
		if ( themecss.setAttribute ) {
				themecss.setAttribute( "rel", "stylesheet" );
				themecss.setAttribute( "type", "text/css" );
				themecss.setAttribute( "href", themecssurl );
		} else {
				themecss.rel = "stylesheet";
				themecss.href = themecssurl;
		}
		//document.getElementById("syntaxhighlighteranchor").appendChild(themecss);
		document.getElementsByTagName("head")[0].insertBefore( themecss, document.getElementById("syntaxhighlighteranchor") );
	})();
	SyntaxHighlighter.config.strings.expandSource = '+ expand source';
	SyntaxHighlighter.config.strings.help = '?';
	SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
	SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
	SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
	SyntaxHighlighter.defaults['pad-line-numbers'] = false;
	SyntaxHighlighter.defaults['toolbar'] = false;
	SyntaxHighlighter.all();
</script>
<link rel='stylesheet' id='qtipstyles-css'  href='../../wp-content/plugins/easy-footnotes/assets/qtip/jquery.qtip.min167b.css?ver=4.6' type='text/css' media='' />
<link rel='stylesheet' id='easyfootnotescss-css'  href='../../wp-content/plugins/easy-footnotes/assets/easy-footnotes167b.css?ver=4.6' type='text/css' media='' />
<link rel='stylesheet' id='dashicons-css'  href='../../wp-includes/css/dashicons.min167b.css?ver=4.6' type='text/css' media='all' />
<script type='text/javascript' src='../../wp-content/themes/scrawl-wpcom/js/scrawld56c.js?ver=20150309'></script>
<script type='text/javascript' src='../../wp-content/themes/scrawl-wpcom/js/skip-link-focus-fix08e0.js?ver=20130115'></script>
<script type='text/javascript' src='../../wp-includes/js/wp-embed.min167b.js?ver=4.6'></script>
<script type='text/javascript' src='../../wp-includes/js/imagesloaded.min55a0.js?ver=3.2.0'></script>
<script type='text/javascript' src='../../wp-content/plugins/easy-footnotes/assets/qtip/jquery.qtip.min167b.js?ver=4.6'></script>
<script type='text/javascript' src='../../wp-content/plugins/easy-footnotes/assets/qtip/jquery.qtipcall167b.js?ver=4.6'></script>

</body>

<!-- Mirrored from malisper.me/page/3/ by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 01 Sep 2016 17:46:39 GMT -->
</html>
<!-- Dynamic page generated in 0.094 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2016-09-01 12:22:49 -->

<!-- super cache -->