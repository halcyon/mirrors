<!DOCTYPE html>
<html lang="en-US" prefix="og: http://ogp.me/ns#">

<!-- Mirrored from malisper.me/author/malisper/page/2/ by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 01 Sep 2016 17:46:53 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>malisper, Author at Macrology - Page 2 of 3</title>
<link rel="profile" href="http://gmpg.org/xfn/11">
<link rel="pingback" href="../../../../xmlrpc.php">


<!-- This site is optimized with the Yoast SEO plugin v3.4.2 - https://yoast.com/wordpress/plugins/seo/ -->
<link rel="canonical" href="index.html" />
<link rel="prev" href="../../index.html" />
<link rel="next" href="../3/index.html" />
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="object" />
<meta property="og:title" content="malisper, Author at Macrology - Page 2 of 3" />
<meta property="og:url" content="index.html" />
<meta property="og:site_name" content="Macrology" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="malisper, Author at Macrology - Page 2 of 3" />
<!-- / Yoast SEO plugin. -->

<link rel='dns-prefetch' href='http://fonts.googleapis.com/'>
<link rel="alternate" type="application/rss+xml" title="Macrology &raquo; Feed" href="../../../../feed/index.html" />
<link rel="alternate" type="application/rss+xml" title="Macrology &raquo; Comments Feed" href="../../../../comments/feed/index.html" />
<link rel="alternate" type="application/rss+xml" title="Macrology &raquo; Posts by malisper Feed" href="../../feed/index.html" />
<link rel='stylesheet' id='scrawl-style-css'  href='../../../../wp-content/themes/scrawl-wpcom/style167b.css?ver=4.6' type='text/css' media='all' />
<link rel='stylesheet' id='scrawl-fonts-css'  href='https://fonts.googleapis.com/css?family=Lora:400,700|Merriweather:400italic,400,700,700italic&amp;subset=latin%2Clatin-ext' type='text/css' media='all' />
<link rel='stylesheet' id='genericons-css'  href='../../../../wp-content/themes/scrawl-wpcom/fonts/genericons6de8.css?ver=3.3' type='text/css' media='all' />
<script type='text/javascript' src='../../../../wp-includes/js/jquery/jqueryb8ff.js?ver=1.12.4'></script>
<script type='text/javascript' src='../../../../wp-includes/js/jquery/jquery-migrate.min330a.js?ver=1.4.1'></script>
<link rel='https://api.w.org/' href='../../../../wp-json/index.html' />
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="../../../../xmlrpc0db0.php?rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="../../../../wp-includes/wlwmanifest.xml" /> 
<meta name="generator" content="WordPress 4.6" />
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-63547056-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
<style type="text/css" id="syntaxhighlighteranchor"></style>

<script type="text/javascript">
  window.heap=window.heap||[],heap.load=function(e,t){window.heap.appid=e,window.heap.config=t=t||{};var n=t.forceSSL||"https:"===document.location.protocol,a=document.createElement("script");a.type="text/javascript",a.async=!0,a.src=(n?"https:":"http:")+"//cdn.heapanalytics.com/js/heap-"+e+".js";var o=document.getElementsByTagName("script")[0];o.parentNode.insertBefore(a,o);for(var r=function(e){return function(){heap.push([e].concat(Array.prototype.slice.call(arguments,0)))}},p=["clearEventProperties","identify","setEventProperties","track","unsetEventProperty"],c=0;c<p.length;c++)heap[p[c]]=r(p[c])};
    heap.load("931515525");
</script>
</head>

<body class="archive paged author author-malisper author-1 paged-2 author-paged-2">
	<button class="menu-toggle x">
		<span class="lines"></span>
		<span class="screen-reader-text">Primary Menu</span>
	</button>
	<div class="slide-menu">
				
		<h1 class="site-title"><a href="../../../../index.html" rel="home">Macrology</a></h1>
		<h2 class="site-description">Case Studies in Lisp Macros</h2>
		
				
				
			<div id="secondary" class="widget-area" role="complementary">
		<aside id="search-2" class="widget widget_search"><form role="search" method="get" class="search-form" action="http://malisper.me/">
				<label>
					<span class="screen-reader-text">Search for:</span>
					<input type="search" class="search-field" placeholder="Search &hellip;" value="" name="s" />
				</label>
				<input type="submit" class="search-submit" value="Search" />
			</form></aside><aside id="pages-3" class="widget widget_pages"><h1 class="widget-title">Pages</h1>		<ul>
			<li class="page_item page-item-55"><a href="../../../../about-me/index.html">About Michael Malis</a></li>
<li class="page_item page-item-44"><a href="../../../../about-this-site-2/index.html">About This Site</a></li>
		</ul>
		</aside><aside id="nav_menu-3" class="widget widget_nav_menu"><h1 class="widget-title">Contact Me</h1><div class="menu-contact-me-container"><ul id="menu-contact-me" class="menu"><li id="menu-item-60" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-60"><a href="mailto:michaelmalis2@gmail.com">Email</a></li>
<li id="menu-item-58" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-58"><a href="https://github.com/malisper">Github</a></li>
<li id="menu-item-59" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-59"><a href="https://news.ycombinator.com/user?id=malisper">Hacker News</a></li>
</ul></div></aside><aside id="archives-2" class="widget widget_archive"><h1 class="widget-title">Archives</h1>		<ul>
			<li><a href='../../../../2016/06/index.html'>June 2016</a></li>
	<li><a href='../../../../2016/04/index.html'>April 2016</a></li>
	<li><a href='../../../../2016/01/index.html'>January 2016</a></li>
	<li><a href='../../../../2015/12/index.html'>December 2015</a></li>
	<li><a href='../../../../2015/11/index.html'>November 2015</a></li>
	<li><a href='../../../../2015/10/index.html'>October 2015</a></li>
	<li><a href='../../../../2015/09/index.html'>September 2015</a></li>
	<li><a href='../../../../2015/08/index.html'>August 2015</a></li>
	<li><a href='../../../../2015/07/index.html'>July 2015</a></li>
	<li><a href='../../../../2015/06/index.html'>June 2015</a></li>
	<li><a href='../../../../2015/05/index.html'>May 2015</a></li>
		</ul>
		</aside><aside id="categories-2" class="widget widget_categories"><h1 class="widget-title">Categories</h1>		<ul>
	<li class="cat-item cat-item-2"><a href="../../../../category/basics/index.html" title="These are basic Lisp macros that should be trivial to understand.">Basic Macros</a>
</li>
	<li class="cat-item cat-item-5"><a href="../../../../category/intermediate-macros/index.html" >Intermediate Macros</a>
</li>
	<li class="cat-item cat-item-6"><a href="../../../../category/advanced-macros/index.html" >Advanced Macros</a>
</li>
	<li class="cat-item cat-item-7"><a href="../../../../category/debugging-common-lisp/index.html" >Debugging Lisp</a>
</li>
	<li class="cat-item cat-item-8"><a href="../../../../category/loops-in-lisp/index.html" >Loops in Lisp</a>
</li>
		</ul>
</aside>	</div><!-- #secondary -->
	</div><!-- .slide-menu -->
<div id="page" class="hfeed site">
	<a class="skip-link screen-reader-text" href="#content">Skip to content</a>

	<header id="masthead" class="site-header" role="banner">

		<div class="site-branding">
						<h1 class="site-title"><a href="../../../../index.html" rel="home">Macrology</a></h1>
		</div>

	</header><!-- #masthead -->

	
	
	<div id="content" class="site-content">


	<section id="primary" class="content-area">
		<main id="main" class="site-main" role="main">

		
			<header class="page-header">
				<h1 class="page-title">Author: <span class="vcard">malisper</span></h1>			</header><!-- .page-header -->

			
				
					
<article id="post-831" class="post-831 post type-post status-publish format-standard hentry category-advanced-macros">
	<header class="entry-header">
					<h1 class="entry-title"><a href="../../../../2015/09/08/defasm/index.html" rel="bookmark">Defasm</a></h1>			</header><!-- .entry-header -->
			<div class="entry-content">
			<p><em>This post is the second part of a two part series exploring the emulator <a href="https://github.com/kingcons/cl-6502">cl-6502</a>. If you haven&#8217;t read the first part exploring the implementation of addressing modes in cl-6502, you can find it <a href="../../../../2015/08/27/defaddress/index.html">here</a>.</em></p>
<p>This post is going to go over how cl-6502 implements the instruction set of the 6502. Most of the work in defining the instruction set is done by a single macro, <strong>defasm</strong>. But before I can go into the details of <strong>defasm</strong>, I have to explain how cl-6502 represents instructions.</p>
<p>cl-6502 represents each instruction as a function inside an array called <em>*array-funs*</em>. The function for a specific instruction is indexed by that instruction&#8217;s opcode.<span id='easy-footnote-1' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../../../2015/09/08/defasm/index.html#easy-footnote-bottom-1' title='If you don&#8217;t know, the opcode is the byte used in machine code to represent the instruction.'><sup>1</sup></a></span> To execute an instruction, cl-6502 looks up the opcode of the current instruction and calls the function at that location inside of <em>*array-funs*</em>. There is also a second array, <em>*opcode-metadata*,</em> which keeps track of some metadata about each instruction such as the number of bytes each one takes up. All <strong>d</strong><strong>efasm</strong> does is make it easy to generate all of the functions and metadata that wind up inside of those two arrays.</p>
<p>To show you just how easy it is to implement instructions with <strong>defasm</strong>, here is the implementation of the adc (add with carry) instruction:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defasm adc (:docs &quot;Add to Accumulator with Carry&quot;)
    ((#x61 6 2 indirect-x)
     (#x65 3 2 zero-page)
     (#x69 2 2 immediate)
     (#x6d 4 3 absolute)
     (#x71 5 2 indirect-y)
     (#x75 4 2 zero-page-x)
     (#x79 4 3 absolute-y)
     (#x7d 4 3 absolute-x))

  (let ((result (+ (cpu-ar cpu) 
                   (getter) 
                   (status-bit :carry))))
    (set-flags-if 
      :carry (&gt; result #xff)
      :overflow (overflow-p result (cpu-ar cpu) (getter))
      :negative (logbitp 7 result)
      :zero (zerop (wrap-byte result)))
    (setf (cpu-ar cpu) (wrap-byte result))))
</pre>
<p>There are two main parts to the above code. The first part specifies all of the addressing modes the instruction is compatible with along with the metadata for each variant of the instruction (there is a different version of the instruction for every possible addressing mode the instruction can be used with).</p>
<p>After that is the body &#8211; the code that actually implements the instruction being defined. The body is responsible for setting all of the appropriate flags and memory locations to the values they should have after executing the instruction. Make sure you note that just like in <strong>defaddress</strong>, the variable <em>cpu</em> can be used in the body to reference an object that represents the current state of the cpu.</p>
<p><b>Defasm</b> takes these two pieces, and generates one lambda expression for each variant of the instruction. All of the generated lambda expressions use the same body, except <strong>defasm</strong> generates some additional code that allows the body to work across all of the different addressing modes.</p>
<p>Now to get into the specifics of the DSL. In the addressing mode part of the DSL, there are four pieces of metadata that need to be associated with each version of the instruction. The first part is the opcode, the machine code representation of the instruction. Next up is the number of cycles it takes for the instruction to execute. After that is the size of the instruction, the number of bytes it takes up in memory. Last is the name of the addressing mode used for that specific variant of the instruction. As an example, here is the metadata for the adc instruction in the indirect-x addressing mode:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(#x61 6 2 indirect-x)
</pre>
<p>What it is saying is that this version of the instruction has the opcode #x61, takes six cycles to run, takes two bytes in memory, and uses the indirect-x addressing mode. The fact that when an instruction is used in different addressing modes, it uses a different number of clock cycles and takes up a different amount of space is one reason why different addressing modes are provided in assembly language.</p>
<p>For the body, <strong>defasm</strong> does something very clever to have the body work for every possible addressing modes. Within the body, the functions <b>getter</b> and <strong>setter</strong> are bound to local functions that can be used to obtain and modify the argument to the instruction. For each variant of the instruction, <strong>defasm</strong> generates the definition of these two functions differently so that they will always calculate the correct argument for the given addressing mode.</p>
<p>For example, in the version of adc that uses immediate addressing, <strong>getter</strong> will just return the value of the operand, but in the version that uses absolute addressing, <b>getter</b> will use the operand as an address and look up the value at that location in memory. In the definition of the adc instruction above, the body uses <strong>getter</strong> to obtain the argument, adds that to the value in the accumulator, adds in the carry, and then sets all of the appropriate flags and registers depending on the final value it winds up with. Since <strong>getter</strong> and <strong>setter</strong> work across all of the different addressing modes, so does the body!</p>
<p>Now let&#8217;s look at the actual implementation of <strong>defasm</strong>:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defmacro defasm (name (&amp;key (docs &quot;&quot;) raw-p (track-pc t))
                  modes &amp;body body)
  `(progn

     ,@(loop for (op cycles bytes mode) in modes collect
         `(setf (aref *opcode-meta* ,op) 
                ',(list name docs cycles bytes mode)))

     ,@(loop for (op cycles bytes mode) in modes collect
         `(setf (aref *opcode-funs* ,op)
                (lambda (cpu)
                  (incf (cpu-pc cpu))
                  (flet ((getter ()
                           ,(make-getter name mode raw-p))
                         (setter (x)
                           (setf (,mode cpu) x)))
                    ,@body)
                  ,@(when track-pc
                     `((incf (cpu-pc cpu) ,(1- bytes))))
                  (incf (cpu-cc cpu) ,cycles))))))
</pre>
<p>As usual, I&#8217;m going to show a snippet of the implementation of <strong>defasm</strong> and then show what the macroexpansion of that piece looks like. The first part of the implementation handles the addressing modes and metadata:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(loop for (op cycles bytes mode) in modes collect
  `(setf (aref *opcode-meta* ,op) 
         ',(list name docs cycles bytes mode)))
</pre>
<p>For each addressing mode, this generates code which will store a list containing the metadata into the proper place in the <em>*opcode-meta*</em> array. In other words it takes each part that looks like:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(#x61 6 2 indirect-x)
</pre>
<pre>and generates code that looks like:</pre>
<pre class="brush: plain; title: ; notranslate" title="">
(setf (aref *opcode-meta* #x61)
     '(adc &quot;Add to accumulator with carry&quot; 6 2 indirect-x))
</pre>
<p>After that we have the part that will generate the actual lambda expressions for the functions that will be stored in <em>*array-funs*</em>:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(loop for (op cycles bytes mode) in modes collect
  `(setf (aref *opcode-funs* ,op)
         (lambda (cpu)
           (incf (cpu-pc cpu))
           (flet ((getter ()
                   ,(make-getter name mode raw-p))
                 (setter (x)
                   (setf (,mode cpu) x)))
             ,@body)
          ,@(when track-pc
              `((incf (cpu-pc cpu) ,(1- bytes))))
          (incf (cpu-cc cpu) ,cycles))))
</pre>
<p>This code loops over all of the metadata for the different addressing modes and uses this information to generate the expression for each variant of the instruction. As mentioned previously, the function will be stored by the variant&#8217;s opcode. As for the actual function itself, it does something along these lines. First, it advances the pc. This is done so that the pc now points to the operand of the instruction. By doing this, the job of <strong>defaddress</strong> becomes much easier since it can use the pc as a pointer to the operand. Next, the function evaluates the body in an environment with <strong>getter</strong> and <strong>setter</strong> bound to functions that can be used to read and write to the argument. After that it will advance the pc forward to the next instruction (unless <em>track-pc</em> was false, which happens for instructions that modify the pc themselves such as jumps). Finally, the function will increment the cycle count by the number of cycles it takes the instruction to execute.</p>
<p>The definitions of <strong>getter</strong> and <strong>setter</strong> are really just calls to the function with the same name as the addressing mode associated with the variant of the instruction.<span id='easy-footnote-2' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../../../2015/09/08/defasm/index.html#easy-footnote-bottom-2' title='Getter actually uses a function make-getter along with the raw-p argument. This is just to smooth out some differences between instructions.'><sup>2</sup></a></span> If you look back at the last post, you will see that <strong>defaddress</strong> automatically generates these &#8220;mode&#8221; functions. All they do is calculate the effective argument for the given addressing mode! Exactly what <strong>getter</strong> does. As an example of what the expansion looks like, here is the lambda expression generated for the adc instruction in the indirect-x addressing mode.</p>
<pre class="brush: plain; title: ; notranslate" title="">
(setf (aref *opcode-funs* #x61)
      (lambda (cpu)
        (incf (cpu-pc cpu))
        (flet ((getter ()
                 (get-byte (indirect-x cpu)))
               (setter (x)
                 (setf (indirect-x cpu) x)))
         (let ((result (+ (cpu-ar cpu) 
                          (getter) 
                          (status-bit :carry))))
          (set-flags-if :carry (&gt; result 255) 
                        :overflow (overflow-p result 
                                              (cpu-ar cpu)
                                              (getter))
                        :negative (logbitp 7 result) 
                        :zero (zerop (wrap-byte result)))
          (setf (cpu-ar cpu) (wrap-byte result))))
        (incf (cpu-pc cpu) 1)
        (incf (cpu-cc cpu) 6)))
</pre>
<p>And that&#8217;s all there is to <strong>defasm</strong>! There are a couple really cool things you should note about cl-6502. First off, the macros expand into a lot of code. The definition of adc at the beginning of this post expands into roughly 500 lines of code. <a href="https://gist.github.com/malisper/610f691e7b3919d6a421">Here</a> is a link to a gist of it if you want to see it. More incredibly, cl-6502 implements an entire emulator in under 1000 lines of code. cl-6502 is a fantastic example of how effective macros are at creating concise DSLs.</p>
					</div><!-- .entry-content -->
				<div class="entry-meta clear">
			<span class="posted-on">Posted on <a href="../../../../2015/09/08/defasm/index.html" rel="bookmark"><time class="entry-date published" datetime="2015-09-08T12:48:05+00:00">September 8, 2015</time><time class="updated" datetime="2015-10-11T23:06:33+00:00">October 11, 2015</time></a></span><span class="byline"> by <span class="author vcard"><a class="url fn n" href="../../index.html">malisper</a></span></span>			<span class="secondary-entry-meta">
																	<span class="comments-link"><a href="../../../../2015/09/08/defasm/index.html#comments">2</a></span>							</span>
		</div><!-- .entry-meta -->
	</article><!-- #post-## -->

				
					
<article id="post-735" class="post-735 post type-post status-publish format-standard hentry category-intermediate-macros">
	<header class="entry-header">
					<h1 class="entry-title"><a href="../../../../2015/08/27/defaddress/index.html" rel="bookmark">Defaddress</a></h1>			</header><!-- .entry-header -->
			<div class="entry-content">
			<p><em>This post is the first part of a two part series exploring the emulator <a href="https://github.com/kingcons/cl-6502">cl-6502</a>. This post will cover how addressing modes are implemented in cl-6502. The second part will go over the implementation of the opcodes.</em></p>
<p>cl-6502 is an emulator for the MOS 6502 processor, used in devices such as the Apple II and the NES. As an emulator, cl-6502 has three distinct roles. It needs to be able to convert assembly code into machine code (assembly), it needs to be able to convert machine code back into assembly (disassembly), and it needs to be able to actually interpret the machine code (execution). By using macros in clever ways, cl-6502 is able to create multiple DSLs for defining different components of the emulator. One of those macros is <strong>defaddress</strong>, which makes it easy to add addressing modes to the emulator. First some background.</p>
<p>Assembly language has what are known as &#8220;addressing modes&#8221;. Depending on which addressing mode is being used, the argument to the instruction will be calculated in a different manner. The programmer is able to specify different addressing modes by using slightly different syntaxes. As an example here is the same jump instruction just with two different addressing modes:</p>
<pre class="brush: plain; title: ; notranslate" title="">
JMP $0
JMP ($0)
</pre>
<p>From here on out, I&#8217;m going to use the term &#8220;operand&#8221; to refer to the value given to the instruction before the addressing mode has been taken into account and the term &#8220;argument&#8221; to refer to the value after the addressing mode has been considered. As you should be able to tell, both instructions above are passed the same operand of zero, but because they are using different addressing modes, they will calculate their arguments in two different ways.</p>
<p>Since the first instruction doesn&#8217;t use any extra syntax (except the dollar sign which just means base 16), it uses &#8220;absolute&#8221; addressing. With absolute addressing the argument is the same as the operand.<span id='easy-footnote-1' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../../../2015/08/27/defaddress/index.html#easy-footnote-bottom-1' title='Actually it isn&#8217;t. The operand is actually the address of the argument. The real argument to jump is the instruction being jumped to. Just for simplicity sake I am removing a layer of indirection. What I am saying only makes sense for jump. For pretty much every other instruction, the operand is the address of the argument.'><sup>1</sup></a></span> The first instruction can be read as, continue execution at the instruction at address zero.</p>
<p>Since the second instruction has parens around the operand, it uses what is known as &#8220;indirect&#8221; addressing. For indirect addressing, the operand is actually the memory location of the argument.<span id='easy-footnote-2' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../../../2015/08/27/defaddress/index.html#easy-footnote-bottom-2' title='As I said in the previous footnote there is actually an extra layer of indirection that I am removing for simplicity.'><sup>2</sup></a></span> The second instruction can be read as, get the address that is stored at address zero, and continue execution at the instruction at that location in memory. Assuming the value 123 was stored at address zero, the operand would be zero, the argument would be 123, and the instruction would cause execution to be resumed at the instruction at location 123.</p>
<p>In total there are 13 different addressing modes for the 6502. In order to make it easy to define all of these different addressing modes, cl-6502 creates a macro <strong>defaddress</strong>. <strong>Defaddress</strong> is a DSL for the sole purpose of defining addressing modes. Each one of the main arguments to <strong>defaddress</strong> handles one of the jobs (assembly/disassembly/execution) that an emulator has to perform with respect to the addressing mode. As to what the <strong>defaddress</strong> DSL looks like, here is the code that defines the absolute addressing mode.</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defaddress absolute (:reader &quot;^_$&quot; :writer &quot;$~{~2,'0x~}&quot;)
  (get-word (cpu-pc cpu)))
</pre>
<p>The code above has three distinct parts. The first piece is the reader, which is used to parse the assembly code:</p>
<pre class="brush: plain; title: ; notranslate" title=""> &quot;^_$&quot; </pre>
<p>The reader argument is a regular expression that recognizes the syntax of the addressing mode being defined, in this case aboslute addressing. The regex is a normal perl compatible regex except it may use an underscore to match (and capture) an operand. The regex above matches a lone operand, which is exactly the syntax for absolute addressing. After the reader is the writer:</p>
<pre class="brush: plain; title: ; notranslate" title="">
&quot;$~{2,'0x~}&quot;
</pre>
<p>The writer is a format string that is able to reproduce the original assembly (with the proper syntax for the addressing mode) from the machine code. The writer for absolute addressing says to print the operand as a zero padded, two digit, hexadecimal number. Basically, it just prints the lone operand in assembly language without any additional syntax. Since there is no extra syntax, that means the generated code is using absolute addressing.</p>
<p>The last part is the body. The body is a block of code that calculates the argument from the operands.<span id='easy-footnote-3' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../../../2015/08/27/defaddress/index.html#easy-footnote-bottom-3' title='As I have said in previous footnotes it should actually calculate the address of the real argument. Jump is just a bit weird since the real argument is the instruction being jumped to, but it needs the address of it to get there. For simplicity sake I have been pretending the address of the argument is the actual argument, but this makes sense only for jump and pretty much nothing else.'><sup>3</sup></a></span> For absolute addressing the body is:</p>
<pre class="brush: plain; title: ; notranslate" title=""> 
(get-word (cpu-pc cpu)) 
</pre>
<p>When this code is ran, the variable <em>cpu</em> will be bound to an object representing the current state of the cpu. The pc of the cpu normally points to the current instruction being executed, but cl-6502 uses a slight trick. By incrementing the pc, it will now point to the first operand of the instruction! All the body does is take the value of the pc (which is the address of the argument/operand), and looks up the value at that address<span id='easy-footnote-4' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../../../2015/08/27/defaddress/index.html#easy-footnote-bottom-4' title='Get-word is just a function which looks up the 16-bit value at the given memory address.'><sup>4</sup></a></span> to get the actual argument.</p>
<p>As a second example of <strong>defaddress</strong>, here is the code for indirect addressing:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defaddress indirect (:reader &quot;^\\(_\\)$&quot; 
                      :writer &quot;($~{~2,'0x~})&quot;)
  (get-word (get-word (cpu-pc cpu)) t))
</pre>
<p>There are only a few differences between the code for indirect and absolute addressing. In the reader and writer, there are now an extra pair of parens around the operand. This is because the syntax for indirect addressing is an operand surrounded by parens. Another difference is with the body. Since there is an extra layer of indirection with indirect addressing, there is an additional call to <strong>get-word</strong>. For indirect addressing, the body says to calculate the argument, get the value of the pc (the address of the operand or the address of the address of the argument), get the value at that address (the operand or the address of the argument), and then get the value at that address (the actual argument).</p>
<p>Since I have already shown you some examples of how to use <strong>defaddress</strong>, I am now going to explain how <strong>defaddress</strong> works. Here is the complete definition of <strong>defaddress</strong>:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defmacro defaddress (name (&amp;key reader writer cpu-reg)
                      &amp;body body)
  `(progn 
    (defmethod reader ((mode (eql ',name)))
      ,(cl-ppcre:regex-replace-all 
         &quot;_&quot; reader &quot;([^,()#&amp;]+)&quot;))
     (defmethod writer ((mode (eql ',name))) ,writer)
     (push ',name *address-modes*)
     (defun ,name (cpu) ,@body)
     (defun (setf ,name) (value cpu)
       ,(if cpu-reg
            `(setf ,@body value)
            `(setf (get-byte ,@body) value)))))
</pre>
<p>I&#8217;m going to break down the code for <strong>defaddress</strong> one part at a time. After explaining a piece does, I will show you what the expansion of that piece looks like when defining absolute addressing. The first part of <strong>defaddress</strong> handles the reader:</p>
<pre class="brush: plain; title: ; notranslate" title="">
 (defmethod reader ((mode (eql ',name)))
   ,(cl-ppcre:regex-replace-all &quot;_&quot; reader &quot;([^,()#&amp;]+)&quot;)) 
</pre>
<p>This part generates code which will define a method on the generic (virtual) function <strong>reader</strong>. <strong>Reader</strong> takes in the name of the mode as an argument and is supposed to return a regex (a true perl compatible regex, i.e. no underscores) that will recognize the mode and extract the operands:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(reader 'absolute)
=&gt; &quot;^([^,()#&amp;]+)$&quot;
</pre>
<p>To produce the method, <strong>defaddress</strong> just takes the reader argument, substitutes the underscore with a regex that can be used to recognize operands, and uses that as the value <strong>reader</strong> should return for the mode being defined. Here is what the piece of code expands into for absolute addressing:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defmethod reader ((mode (eql 'absolute))) &quot;^([^,()#&amp;]+)$&quot;)
</pre>
<p>The next part does pretty much the exact same thing, only for the writer:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defmethod writer ((mode (eql ',name))) ,writer)
</pre>
<p>It generates the code for a method for the generic function <strong>writer</strong>. Since the format string is used unmodified, <strong>defaddress</strong> just inserts the string into the body of the function. There result winds up being:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defmethod writer ((mode (eql 'absolute))) &quot;$~{~2,'0x~}&quot;)
</pre>
<p>Next up is the piece:</p>
<pre class="brush: plain; title: ; notranslate" title=""> (push ',name *address-modes*) </pre>
<p>This piece of code adds the mode being defined to a list of all of the addressing modes. The list is used to find all of the addressing modes that match the syntax of a given instruction. The snippet simply expands into:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(push 'absolute *address-modes*)
</pre>
<p>Now for the most important part of <strong>defaddress </strong>&#8211; the code that handles the body:</p>
<pre class="brush: plain; title: ; notranslate" title=""> (defun ,name (cpu) ,@body) </pre>
<p>It just puts the body inside of a function named by the addressing mode. The function is supposed to take the in the current state of the cpu as an object and return the argument used for the current instruction. Note that the variable <em>cpu</em> is available to the body. This is how the body of <strong>defaddress</strong> is able to access the cpu object. The expansion winds up looking like:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defun absolute (cpu) (get-word (cpu-pc cpu)))
</pre>
<p>There is just one more part, a <strong>setf</strong> function for the addressing mode:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defun (setf ,name) (value cpu)
  ,(if cpu-reg
       `(setf ,@body value)
       `(setf (get-byte ,@body) value)))
</pre>
<p>This code generates a <strong>setf</strong> function, basically a way to modify the argument of the instruction. Many instructions not only use the argument, but they store a new value to the memory location of the argument. The <strong>setf</strong> function defined by <strong>defaddress</strong> is just a way to do that. I&#8217;m not going to go in depth about it, but this is the only piece of code that uses the <em>cpu-reg</em> argument. The <em>cpu-reg</em> argument is just used to smooth out some differences between different addressing modes. The code generated by the above code winds up looking like:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defun (setf absolute) (value cpu)
   (setf (get-byte (get-word (cpu-pc cpu))) value))
</pre>
<p>As I just said, the <strong>setf</strong> function defined can be used to set the value of the argument. To do it for absolute addressing, get the operand and set the value at that memory location.<span id='easy-footnote-5' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../../../2015/08/27/defaddress/index.html#easy-footnote-bottom-5' title='Get-byte is just like get-word only it access the 8-bit value at the given memory address.'><sup>5</sup></a></span><span id='easy-footnote-6' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../../../2015/08/27/defaddress/index.html#easy-footnote-bottom-6' title='If jump were to modify the argument, it would actually be modifying the instruction being jumped to.'><sup>6</sup></a></span></p>
<p>And that is pretty much everything there is to know about <strong>defaddress</strong>. In the next post I am going to talk a bout <strong>defasm, </strong>a macro that makes it easy to define different instructions for the emulator. It piggybacks off of the information provided by <strong>defaddress</strong> in order to handle all of the instructions in all of the different possible addressing modes.</p>
					</div><!-- .entry-content -->
				<div class="entry-meta clear">
			<span class="posted-on">Posted on <a href="../../../../2015/08/27/defaddress/index.html" rel="bookmark"><time class="entry-date published" datetime="2015-08-27T00:53:45+00:00">August 27, 2015</time><time class="updated" datetime="2015-08-27T01:05:12+00:00">August 27, 2015</time></a></span><span class="byline"> by <span class="author vcard"><a class="url fn n" href="../../index.html">malisper</a></span></span>			<span class="secondary-entry-meta">
																	<span class="comments-link"><a href="../../../../2015/08/27/defaddress/index.html#comments">1</a></span>							</span>
		</div><!-- .entry-meta -->
	</article><!-- #post-## -->

				
					
<article id="post-698" class="post-698 post type-post status-publish format-standard hentry category-debugging-common-lisp">
	<header class="entry-header">
					<h1 class="entry-title"><a href="../../../../2015/08/19/debugging-lisp-part-5-miscellaneous/index.html" rel="bookmark">Debugging Lisp Part 5: Miscellaneous</a></h1>			</header><!-- .entry-header -->
			<div class="entry-content">
			<p><em>This post is for all of the miscellaneous features that aren&#8217;t large enough to get their own individual posts. If you haven&#8217;t read all of them, here are the links to the previous posts on <em><a href="../../../../2015/07/07/debugging-lisp-part-1-recompilation/index.html">recompilation</a>, <a href="../../../../2015/07/14/debugging-lisp-part-2-inspecting/index.html">inspection</a>, <a href="../../../../2015/07/22/debugging-lisp-part-3-redefining-classes/index.html">class redefinition</a>, and <a href="../../../../2015/08/05/debugging-lisp-part-4-restarts/index.html">restarts</a>.</em></em></p>
<p>One somewhat obscure tool for debugging is SBCL&#8217;s <strong>trace</strong>. SBCL&#8217;s <strong>trace</strong> goes way beyond what most other implementations provide. In SBCL, <strong>trace</strong> takes several additional keyword arguments.<span id='easy-footnote-1' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../../../2015/08/19/debugging-lisp-part-5-miscellaneous/index.html#easy-footnote-bottom-1' title='A keyword argument is an optional named argument. To use a keyword argument you pass in the the name of the argument, followed by the value. By using keyword arguments, a function can accept multiple optional arguments of which any subset can be used.'><sup>1</sup></a></span> For example, <strong>trace</strong> accepts a keyword argument, <em>:break</em>. The expression passed in as the value of <em>:break</em> will be evaluated every time the traced function is called. When that expression evaluates to true, the debugger will be invoked. For example if you have a Fibonacci function:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defun fib (n)
  (if (&lt;= 0 n 1)
      n
      (+ (fib (- n 1))
         (fib (- n 2)))))
</pre>
<p>you can use <strong>trace</strong> to break specifically when <strong>fib</strong> is called with an argument of zero:</p>
<p>&nbsp;</p>
<p><a href="../../../../wp-content/uploads/2015/08/ezgif.com-optimize-4.gif"><img class="aligncenter wp-image-713" src="../../../../wp-content/uploads/2015/08/ezgif.com-optimize-4.gif" alt="ezgif.com-optimize (4)" width="600" height="330" /></a></p>
<p>&nbsp;</p>
<p>A bit of mangling has to be done (using <strong>sb-debug:arg)</strong> since the expression refers to variables within the <strong>fib</strong> function. <strong>Trace</strong> also accepts several variants of <em>:break</em>, such as <em>:break-after</em>, which evaluate the expression after the function has been called instead of before. There are also arguments <em>:print</em> and <em>:</em><em>print-after</em>, which are like their break counterparts, only they print the value of the expression before/after the function is called. You could use <em>:print-after</em> to say, print the time (Unix time) whenever <strong>fib</strong> returns:</p>
<p>&nbsp;</p>
<p><a href="../../../../wp-content/uploads/2015/08/ezgif.com-optimize-6.gif"><img class="aligncenter wp-image-714" src="../../../../wp-content/uploads/2015/08/ezgif.com-optimize-6.gif" alt="ezgif.com-optimize (6)" width="600" height="330" /></a></p>
<p>&nbsp;</p>
<p>For a complete list of all of the arguments that <strong>trace</strong> can accept, check out<b> </b><a href="http://www.sbcl.org/1.0/manual/Function-Tracing.html">this</a> page of the SBCL manual.</p>
<p>Another relatively unknown group of features are the cross referencing commands. The cross referencing commands are commands which lookup all of the places where something is referenced. All of the bindings for the cross referencing commands begin with C-c C-w.<span id='easy-footnote-2' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../../../2015/08/19/debugging-lisp-part-5-miscellaneous/index.html#easy-footnote-bottom-2' title='C-c is pressed because that is the binding Slime uses. C-w is pressed for &#8220;who&#8221;, which is binding for all of the cross referencing commands.'><sup>2</sup></a></span> The cross referencing command I find myself using the most, &#8220;slime-who-calls&#8221;, which is bound to C-c C-w C-c, shows you all of the places where a function is called from. Here is what it would look like if you were to lookup all of the places where the <strong>scan</strong> function is used in <a href="http://weitz.de/cl-ppcre/">cl-ppcre</a> and then scroll through them:<span id='easy-footnote-3' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../../../2015/08/19/debugging-lisp-part-5-miscellaneous/index.html#easy-footnote-bottom-3' title='All of the places that use a macro whose expansion uses the function being cross referenced will also be pulled up.'><sup>3</sup></a></span></p>
<p>&nbsp;</p>
<p><a href="../../../../wp-content/uploads/2015/08/ezgif.com-optimize-7.gif"><img class="aligncenter wp-image-717" src="../../../../wp-content/uploads/2015/08/ezgif.com-optimize-7.gif" alt="ezgif.com-optimize (7)" width="600" height="330" /></a></p>
<p>&nbsp;</p>
<p>Slime-who-calls makes it easy to figure out how a function is supposed be used. You can pull up all of the usages of a function and just look at them. There are also several analogs of slime-who-calls. There is slime-who-macroexpands (C-c C-w RET), which pulls up all of the places where a macro is used and there is also slime-who-references (C-C C-w C-r) which is the same thing only for variables.</p>
<p>Another important feature is how to pull up the source code of a function on the stack while inside of the debugger. One way to do it is to press the &#8216;v&#8217; key with the cursor on the frame you want to view the source of. An alternative option is to use M-p (the alt key and the &#8216;p&#8217; key at the same time) and M-n to move up and down the stack frame. When using these commands instead of the normal C-p and C-n for movement, Slime will automatically pull up the source code as you are moving through the stack. Here is what it would look like if you were to pass a malformed regular expression to cl-ppcre (so that an error will be signaled and you will enter the debugger), and then scroll through the stack trace using M-n:</p>
<p>&nbsp;</p>
<p><a href="../../../../wp-content/uploads/2015/08/ezgif.com-optimize-9.gif"><img class="aligncenter wp-image-732" src="../../../../wp-content/uploads/2015/08/ezgif.com-optimize-9.gif" alt="ezgif.com-optimize (9)" width="600" height="330" /></a></p>
<p>&nbsp;</p>
<p>And now for the most common of all IDE commands, jumping to source. I was recently talking with someone and he mentioned that the only feature he uses an IDE for is to easily find definitions in source code. In Emacs with Slime, it is possible to jump to the source of pretty much anything by hitting &#8220;M-.&#8221; (that is the control key followed by a period). This command works on functions, variables, classes, and more! When you jump to the source of a generic (virtual) function, you are given a list of all of the different methods that implement that function. For example if you weret to jump to the source of <strong>create-matcher-aux</strong> (the function that does most of the work in cl-ppcre), here is what you would see:</p>
<p>&nbsp;</p>
<p><a href="../../../../wp-content/uploads/2015/08/ezgif.com-optimize-8.gif"><img class="aligncenter wp-image-720" src="../../../../wp-content/uploads/2015/08/ezgif.com-optimize-8.gif" alt="ezgif.com-optimize (8)" width="600" height="330" /></a></p>
<p>&nbsp;</p>
<p>To jump back to wherever you were previously, use &#8220;M-,&#8221;.</p>
<p>And that is everything you should need to know about debugging Common Lisp.</p>
					</div><!-- .entry-content -->
				<div class="entry-meta clear">
			<span class="posted-on">Posted on <a href="../../../../2015/08/19/debugging-lisp-part-5-miscellaneous/index.html" rel="bookmark"><time class="entry-date published" datetime="2015-08-19T13:36:31+00:00">August 19, 2015</time><time class="updated" datetime="2015-10-08T10:26:55+00:00">October 8, 2015</time></a></span><span class="byline"> by <span class="author vcard"><a class="url fn n" href="../../index.html">malisper</a></span></span>			<span class="secondary-entry-meta">
																	<span class="comments-link"><a href="../../../../2015/08/19/debugging-lisp-part-5-miscellaneous/index.html#comments">5</a></span>							</span>
		</div><!-- .entry-meta -->
	</article><!-- #post-## -->

				
					
<article id="post-401" class="post-401 post type-post status-publish format-standard hentry category-debugging-common-lisp">
	<header class="entry-header">
					<h1 class="entry-title"><a href="../../../../2015/08/05/debugging-lisp-part-4-restarts/index.html" rel="bookmark">Debugging Lisp Part 4: Restarts</a></h1>			</header><!-- .entry-header -->
			<div class="entry-content">
			<p><em>This is part four of Debugging Lisp. Here are the previous parts on <a href="../../../../2015/07/07/debugging-lisp-part-1-recompilation/index.html">recompilation</a>, <a href="../../../../2015/07/14/debugging-lisp-part-2-inspecting/index.html">inspecting</a>, and <a href="../../../../2015/07/22/debugging-lisp-part-3-redefining-classes/index.html">class redefinition</a>. The next post on miscellaneous debugging techniques can be found <a href="../../../../2015/08/19/debugging-lisp-part-5-miscellaneous/index.html">here</a>.</em></p>
<p>Many languages provide error handling as two distinct parts, throw and catch. Throw is the part that detects something has gone wrong and in some way signals that an error has occurred. In the process, throw creates an exception object which contains information about the problem. The other part, catch, takes the exception object signaled by throw and attempts to recover from the error.</p>
<p>The issue with throw/catch is that throw acts like an unconditional goto to the catch part. Because of this, all of the state information that is available when throw is used that is not given to the exception object is lost. This becomes problematic if the code that catches the error wants to use some information about what happened when the error occurred in order to recover.</p>
<p>As an example, let&#8217;s say you are implementing a library which takes several files and parses a list of numbers from each one. One way to implement this library is as two functions. The first function, <strong>read-file</strong>, will read the contents of a single file and return a list of the results. The second, <strong>read-files</strong>, will take a list of files and return a list of the contents of each one. Here is what the code for those two functions might look like if they did not have any error handling:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defun read-file (file)
  (with-open-file (in file :direction :input)
    (loop for line = (read-line in nil in)
          until (eq in line)
          collect (parse-integer line))))

(defun read-files (files)
  (loop for file in files
        collect (read-file file)))
</pre>
<p>To test the library you have two files. The first file contains the numbers 5, 10, 15, 20, 25 and the second contains 5, 10, 15, 20, a, 30, 40. In order to make sure your library handles errors properly, you decided to put a line which is just &#8220;a&#8221; in the second file. As it stands, <strong>parse-integer</strong> will signal an error when it comes across this line. To make testing the library easy, you have stored a list containing the pathnames of the two files in the variable <em>*files*</em>. Here is what happens when you try running the library on the two files:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(read-files *files*)

=&gt; ERROR
</pre>
<p>An error occurred due to the &#8220;a&#8221; in the second file. As the designer of the library you have to decide what should happen when a situation like this one comes up. Below are several different options you could choose from if your language only provided catch/throw.</p>
<p>Your first option is to just skip the entry that caused the error. To do this, you could use <strong>handler-case</strong>, Common Lisp&#8217;s version of catch:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defun read-file (file)
  (with-open-file (in file :direction :input)
    (loop for line = (read-line in nil in)
          until (eq in line)
          when (handler-case (parse-integer line)
                 ;; C is the name being used to
                 ;; refer to the exception object.
                 (error (c)
                   (declare (ignore c))
                   nil))
          collect it)))

(read-files *files*)

=&gt; ((5 10 15 20 25) (5 10 15 20 30 40))
</pre>
<p>Another option is to provide a dynamic variable<span id='easy-footnote-1' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../../../2015/08/05/debugging-lisp-part-4-restarts/index.html#easy-footnote-bottom-1' title='A dynamic variable is basically a global variable that can be shadowed. When a dynamic variable is shadowed, any reference to it refers to the new binding. Once execution leaves the form that shadowed the dynamic variable, the dynamic variable reverts back to its previous binding.'><sup>1</sup></a></span> which the user of the library can use to specify a value to be used in place of the malformed entry:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defvar *malformed-value* nil)

(defun read-file (file)
  (with-open-file (in file :direction :input)
    (loop for line = (read-line in nil in)
          until (eq in line)
          when (handler-case (parse-integer line)
                 (error (c)
                   (declare (ignore c))
                   *malformed-value*))
          collect it)))

(let ((*malformed-value* :malformed))
  (read-files *files*))

=&gt; ((5 10 15 20 25) (5 10 15 20 :MALFORMED 30 40))
</pre>
<p>A third option is to have <strong>read-files</strong> catch the error and skip the entire file with the malformed entry:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defun read-files (files)
  (loop for file in files
        when (handler-case (read-file file)
               (error (c)
                 (declare (ignore c))
                 nil))
        collect it))

(read-files *files*)

=&gt; ((5 10 15 20 25))
</pre>
<p>Your last option is to let the user of the library handle the exception themselves:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(handler-case (read-files *files*)
  (error (c) (do-something)))
</pre>
<p>To the user, this last option is somewhat useful because it gives them some flexibility into how the error is handled. As mentioned above, the problem with doing this is that it becomes difficult for the user to properly recover from the error. If the user just wanted to skip the one corrupted file, there is no easy way to for them to do that due to the fact that by the time their error handling code is ran, execution would have left <strong>read-files</strong>. This means all of the state information, such as the remaining files that need to be read from, is completely lost by the time their code catches the exception.</p>
<p>Another problem with catch/throw is that of the four possible ways above you could handle the problem, you only get to choose one of them. Any one of them is in conflict with all of the others. Again, this is because throw acts like goto. Once you decide where you are jumping to, you have no control over what happens next. And, if you let the user handle the error themselves, they have no easy way to handle the error gracefully since all of the state information is lost.</p>
<p>This is where restarts come in. In Common Lisp, catch is provided as two separate pieces: handlers and restarts. A handler is bound by the user of the library in order to specify what should happen when an exception is thrown and a restart is defined by the library in order to provide a recovery option to the user. If you are using a language that supports restarts, you could implement the first three options above as restarts. Then when a user is using the library, they will get to select which of those restarts they want to have run when an error occurs. If they do not want to use any of the restarts, they can run their own code instead. Here is the code for the file reading library, but reimplemented to support three different restarts, one for each of the first three ways to handle errors.</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defun ask (string)
  (princ string *query-io*)
  (read *query-io*))

(defun read-file (file)
  (with-open-file (in file :direction :input)
    (loop for line = (read-line in nil in)
          until (eq in line)
          when (restart-case (parse-integer line)
                 (use-value (value)
                   :report &quot;Use a new value.&quot;
                   :interactive (lambda ()
                                  (list (ask &quot;Value: &quot;)))
                   value)
                 (skip-entry ()
                   :report &quot;Skip the entry.&quot;
                   nil))
          collect it)))

(defun read-files (files)
  (loop for file in files
        when (restart-case (read-file file)
               (skip-file ()
                 :report &quot;Skip the entire file.&quot;
                 nil))
        collect it))

;;; The three functions below are predefined
;;; handlers for the most common ways the user
;;; will interact with the restarts.
(defun skip-entry (c)
  (declare (ignore c))
  (invoke-restart 'skip-entry))

(defun skip-file  (c)
  (declare (ignore c))
  (invoke-restart 'skip-file))

(defun use-value-handler (value)
  (lambda (c)
    (declare (ignore c))
    (invoke-restart 'use-value value)))
</pre>
<p>A restart is defined with the macro <strong>restart-case</strong>, and invoked by the function <strong>invoke-restart</strong>. This is a bit of a simplification, but invoking a restart is effectively equivalent to jumping to the body of the restart <em>from where the error was signaled</em>. This means that all of the state stored on the stack before the restart was established is still available when the restart is invoked. This gives the user of the library much finer grained control over what happens when an error is thrown.</p>
<p>To specify what should happen, all the user needs to do is use the macro <strong>handler-bind</strong>. <strong>Handler-bind</strong> takes an error type and a handler (which should be a function) to call when an error of that type is thrown. The handler can then call <strong>invoke-restart</strong> in order to invoke one of the restarts provided by the library. As part of the library, there is one handler per restart provided, since those are the most common kinds of handlers. Here is what happens when each of the handlers are used when running the library on the two test files:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(handler-bind ((error #'skip-entry))
  (read-files files*))

=&gt; ((5 10 15 20 25) (5 10 15 20 30 40))

(handler-bind ((error #'skip-file))
  (read-files files*))

=&gt; ((5 10 15 20 25))

(handler-bind ((error (use-value-handler 0)))
  (read-files files*))

=&gt; ((5 10 15 20 25) (5 10 15 20 0 30 40))
</pre>
<p>The really cool thing about restarts is what happens when the user doesn&#8217;t handle the error. When this happens they will enter the Slime Debugger. From there they will be given a list of the restarts that are available to them and they will be able to invoke them as if the error had been handled in the first place! Here is what happens when a user doesn&#8217;t handle the error, and then invokes the skip-entry restart on the fly:</p>
<p>&nbsp;</p>
<p><a href="../../../../wp-content/uploads/2015/08/ezgif.com-optimize-3.gif"><img class="aligncenter wp-image-678" src="../../../../wp-content/uploads/2015/08/ezgif.com-optimize-3.gif" alt="ezgif.com-optimize (3)" width="600" height="330" /></a></p>
<p>&nbsp;</p>
<p>What&#8217;s really cool about this is that this &#8220;interactive restarting&#8221; can use it to implement breakpoints! As I said in Part 1, Common Lisp provides breakpoints as a function &#8220;<b>break</b>&#8221; instead of as a feature of the editor. Here is code that could be used to implement <strong>break</strong>:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defun break (&amp;optional (format-control &quot;Break&quot;)
              &amp;rest format-arguments)
   (with-simple-restart (continue &quot;Return from BREAK.&quot;)
     (let ((*debugger-hook* nil))
       (invoke-debugger
         (make-condition 'simple-condition
           :format-control   format-control
           :format-arguments format-arguments))))
   nil)
</pre>
<p>The code for <strong>break</strong> works by signalling an error while providing a &#8220;continue&#8221; restart. This means that as soon as the function <strong>break</strong> is called, you will enter the debugger with a restart available which will continue normal execution. Exactly what a breakpoint actually is.</p>
<p>Restarts are another fantastic part of debugging Common Lisp. They give you better control over what happens when an error occurs. And, if your code doesn&#8217;t handle the error itself, you can still recover the process by using an interactive restart.</p>
					</div><!-- .entry-content -->
				<div class="entry-meta clear">
			<span class="posted-on">Posted on <a href="../../../../2015/08/05/debugging-lisp-part-4-restarts/index.html" rel="bookmark"><time class="entry-date published" datetime="2015-08-05T04:00:03+00:00">August 5, 2015</time><time class="updated" datetime="2016-01-04T12:25:34+00:00">January 4, 2016</time></a></span><span class="byline"> by <span class="author vcard"><a class="url fn n" href="../../index.html">malisper</a></span></span>			<span class="secondary-entry-meta">
																	<span class="comments-link"><a href="../../../../2015/08/05/debugging-lisp-part-4-restarts/index.html#comments">5</a></span>							</span>
		</div><!-- .entry-meta -->
	</article><!-- #post-## -->

				
					
<article id="post-530" class="post-530 post type-post status-publish format-standard hentry category-debugging-common-lisp">
	<header class="entry-header">
					<h1 class="entry-title"><a href="../../../../2015/07/22/debugging-lisp-part-3-redefining-classes/index.html" rel="bookmark">Debugging Lisp Part 3: Redefining Classes</a></h1>			</header><!-- .entry-header -->
			<div class="entry-content">
			<p><em>This is part 3 of Debugging Common Lisp</em>. If you haven&#8217;t read either of the previous parts, you can find part 1 <a href="../../../../2015/07/07/debugging-lisp-part-1-recompilation/index.html">here</a>, and part 2 <a href="../../../../2015/07/14/debugging-lisp-part-2-inspecting/index.html">here</a>. <em>You can find part 4, which is on restarts, <a href="../../../../2015/08/05/debugging-lisp-part-4-restarts/index.html">here</a>.</em></p>
<p>The Common Lisp Object System (CLOS) is pretty powerful. It gives you multiple inheritance, multiple dispatch, and many different ways to extend the behavior of methods. Underneath, most implementations use the Metaobject Protocol (MOP), a way of defining CLOS in terms of itself. As part of the MOP, classes are implemented as objects with several instance variables. Among those are variables that hold the class&#8217;s name, its superclasses, and a list of the class&#8217;s own instance variables. If you don&#8217;t believe me, take the point class from the previous post:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defclass point ()
  ((x :accessor point-x :initarg :x :initform 0)
   (y :accessor point-y :initarg :y :initform 0)))
</pre>
<p>And use the Slime Inspector to inspect the point class object, which can be obtained by calling <strong>find-class</strong>:</p>
<p>&nbsp;</p>
<p><a href="../../../../wp-content/uploads/2015/07/ezgif.com-optimize1.gif"><img class="aligncenter wp-image-569" src="../../../../wp-content/uploads/2015/07/ezgif.com-optimize1.gif" alt="ezgif.com-optimize" width="600" height="330" /></a></p>
<p>&nbsp;</p>
<p>The advantage of using the MOP is that it makes it possible to fine tune the behavior of CLOS by using ordinary object-oriented programming. A great example of this is the <a href="https://common-lisp.net/project/closer/filtered.html">filtered-functions</a> library which adds arbitrary predicate based dispatch to CLOS. But enough about the MOP.<span id='easy-footnote-1' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../../../2015/07/22/debugging-lisp-part-3-redefining-classes/index.html#easy-footnote-bottom-1' title='If you are interested in learning more about the MOP, look for a copy of &#8220;The Art of the Metaobject Protocol&#8221;. Alan Kay, the creator of object-oriented programming, called it &#8220;The best book anybody has written in ten years&#8221; in his 1997 OOPSLA talk.'><sup>1</sup></a></span> In this post I&#8217;m going to talk about one tiny piece of CLOS, <strong>update-instance-for-redefined-class</strong>.</p>
<p><strong>Update-instance-for-redefined-class</strong> is a method which is called whenever a class is redefined (at runtime). By overriding it, you can customize what exactly happens at that point in time. For example, let&#8217;s say you are using the above point class to represent complex numbers for some sort of simulation. As part of the simulation, you have a point object saved inside of the <em>*location*</em> variable<em>:</em></p>
<p>&nbsp;</p>
<p><a href="../../../../wp-content/uploads/2015/07/ezgif.com-optimize-1.gif"><img class="aligncenter wp-image-577" src="../../../../wp-content/uploads/2015/07/ezgif.com-optimize-1.gif" alt="ezgif.com-optimize (1)" width="600" height="330" /></a></p>
<p>&nbsp;</p>
<p>After profiling the simulation, you find that one of the bottlenecks is complex multiplication. Since multiplication of complex numbers is much more efficient when they are represented in polar form, you decide that you want to change the implementation of the point class from Cartesian to polar coordinates. To do that (at runtime), all you need to do is run the following code:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defmethod update-instance-for-redefined-class :before
     ((pos point) added deleted plist &amp;key)
  (let ((x (getf plist 'x))
        (y (getf plist 'y)))
    (setf (point-rho pos) (sqrt (+ (* x x) (* y y)))
          (point-theta pos) (atan y x))))

(defclass point ()
  ((rho :initform 0 :accessor point-rho)
   (theta :initform 0 :accessor point-theta)))

(defmethod point-x ((pos point))
  (with-slots (rho theta) pos (* rho (cos theta))))

(defmethod point-y ((pos point))
  (with-slots (rho theta) pos (* rho (sin theta))))
</pre>
<p>Basically, the code extends <strong>update-instance-for-redefined-class</strong> to calculate the values of <em>rho</em> and <em>theta</em> for the polar implementation in terms of the variables x and y from the Cartesian one. After extending <strong>update-instance-for-redefined-class</strong> the code then redefines the class, causing all of the existing instances to be changed over to the new implementation.<span id='easy-footnote-2' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../../../2015/07/22/debugging-lisp-part-3-redefining-classes/index.html#easy-footnote-bottom-2' title='Actually the time at which update-instance-for-redefined-class is called is unspecified. The only guarantee is that it will be called on an instance before a variable of that instance is accessed.'><sup>2</sup></a></span> Finally, two methods are defined, <strong>point-x</strong> and <strong>point-y</strong>, which preserve the interface for the point class.<span id='easy-footnote-3' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../../../2015/07/22/debugging-lisp-part-3-redefining-classes/index.html#easy-footnote-bottom-3' title='There are several other functions that need to be redefined such as initialize-instance in order to truly preserve the interface.'><sup>3</sup></a></span> After running the code and then inspecting the contents of <em>*location*</em>, you should see:</p>
<p>&nbsp;</p>
<p><a href="../../../../wp-content/uploads/2015/07/ezgif.com-optimize-21.gif"><img class="aligncenter wp-image-581" src="../../../../wp-content/uploads/2015/07/ezgif.com-optimize-21.gif" alt="ezgif.com-optimize (2)" width="600" height="330" /></a></p>
<p>&nbsp;</p>
<p>Even though the object inside of <em>*location*</em> is still the same object, it is now implemented using polar coordinates! To make sure that it was converted from Cartesian to polar correctly, you decide to call <strong>point-x</strong> on the object to check that the x-coordinate is still the same:</p>
<p>&nbsp;</p>
<p><a href="../../../../wp-content/uploads/2015/07/ezgif.com-crop1.gif"><img class="aligncenter wp-image-585" src="../../../../wp-content/uploads/2015/07/ezgif.com-crop1.gif" alt="ezgif.com-crop" width="600" height="330" /></a><a href="../../../../wp-content/uploads/2015/07/ezgif.com-optimize-22.gif"><br />
</a></p>
<p>Amazingly, all of the code continues to work even though the implementation of an entire class was completely changed. So anytime you want to change the implementation of a class that is part of a service that needs to be up 24/7 and just happens to be written in Common Lisp, remember to use <strong>update-instance-for-redefined-class</strong>.</p>
					</div><!-- .entry-content -->
				<div class="entry-meta clear">
			<span class="posted-on">Posted on <a href="../../../../2015/07/22/debugging-lisp-part-3-redefining-classes/index.html" rel="bookmark"><time class="entry-date published" datetime="2015-07-22T03:00:03+00:00">July 22, 2015</time><time class="updated" datetime="2016-01-04T12:24:20+00:00">January 4, 2016</time></a></span><span class="byline"> by <span class="author vcard"><a class="url fn n" href="../../index.html">malisper</a></span></span>			<span class="secondary-entry-meta">
																	<span class="comments-link"><a href="../../../../2015/07/22/debugging-lisp-part-3-redefining-classes/index.html#comments">3</a></span>							</span>
		</div><!-- .entry-meta -->
	</article><!-- #post-## -->

				
					
<article id="post-492" class="post-492 post type-post status-publish format-standard hentry category-debugging-common-lisp">
	<header class="entry-header">
					<h1 class="entry-title"><a href="../../../../2015/07/14/debugging-lisp-part-2-inspecting/index.html" rel="bookmark">Debugging Lisp Part 2: Inspecting</a></h1>			</header><!-- .entry-header -->
			<div class="entry-content">
			<p><em>This is part 2 of Debugging Lisp. If you haven&#8217;t read part 1 on dynamic recompilation, you can find it <a href="../../../../2015/07/07/debugging-lisp-part-1-recompilation/index.html">here</a>. For the next post in the series on redefining classes, click <a href="../../../../2015/07/22/debugging-lisp-part-3-redefining-classes/index.html">here</a>.</em></p>
<p>In this post I am going to discuss another tool used for debugging Common Lisp &#8211; the Slime Inspector. The Slime inspector makes it possible to manipulate objects directly from the repl. You can do many different things with it, including clicking on objects to look at their contents and being able to copy and paste objects in order to reuse them in future function calls.<span id='easy-footnote-1' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../../../2015/07/14/debugging-lisp-part-2-inspecting/index.html#easy-footnote-bottom-1' title='Technically these aren&#8217;t features of the Inspector, they are features of &#8220;Presentations&#8221;. The Inspector is just the part that lets you look inside of the objects.'><sup>1</sup></a></span> Let&#8217;s say you have the following point class:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defclass point ()
  ((x :accessor point-x :initarg :x :initform 0)
   (y :accessor point-y :initarg :y :initform 0)))
</pre>
<p>If you were to make an instance of the above class:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(make-instance 'point :x 10 :y 20)
</pre>
<p>You can then right click on it and click on the &#8220;inspect&#8221; option, or just use the Emacs shortcut &#8220;C-c C-v TAB&#8221; to peek inside the object:</p>
<p>&nbsp;</p>
<p><a href="../../../../wp-content/uploads/2015/07/ezgif.com-optimize-5.gif"><img class="aligncenter wp-image-501" src="../../../../wp-content/uploads/2015/07/ezgif.com-optimize-5.gif" alt="ezgif.com-optimize (5)" width="600" height="329" /></a></p>
<p>&nbsp;</p>
<p>This will show you the current values of all of the instance variables of the object. Not only can you look at the object&#8217;s instance variables, you can modify them as well. Note that the power comes from being able to do all of this from within the debugger at runtime.</p>
<p>&nbsp;</p>
<p><a href="../../../../wp-content/uploads/2015/07/ezgif.com-optimize-7.gif"><img class="aligncenter wp-image-510" src="../../../../wp-content/uploads/2015/07/ezgif.com-optimize-7.gif" alt="ezgif.com-optimize (7)" width="600" height="330" /></a></p>
<p>&nbsp;</p>
<p>To make sure that the value of that object was actually changed, you can copy and paste the point object and then call the <strong>point-x</strong> function on it.</p>
<p>&nbsp;</p>
<p><a href="../../../../wp-content/uploads/2015/07/ezgif.com-crop-5.gif"><img class="aligncenter wp-image-522" src="../../../../wp-content/uploads/2015/07/ezgif.com-crop-5.gif" alt="ezgif.com-crop (5)" width="600" height="330" /></a></p>
<p>&nbsp;</p>
<p>One more really cool tool that hooks into the Inspector is the Slime Trace Dialog. The Slime Trace Dialog is like ordinary trace, but it also allows for inspection on the objects that were passed to or returned from the traced functions. For example, let&#8217;s say you are writing a tail call optimized function, <strong>sum</strong>, that sums all of the numbers in a list.</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defun sum (xs &amp;optional (acc 0))
  (if (null xs)
      acc
      (sum (cdr xs) (+ (car xs) acc))))

(sum '(1 2 3))
=&gt; 6
</pre>
<p>You can toggle the use the Slime Trace Dialog to trace <strong>sum</strong> by typing the shortcut &#8220;C-c M-t&#8221; and then typing in the name of function, &#8220;<strong>sum</strong>”. After tracing it and running the code, you can press &#8220;C-c T&#8221; to enter the interactive Trace Dialog buffer. From there you can press &#8220;G&#8221; to refresh it and obtain the most recent trace.</p>
<p>&nbsp;</p>
<p><a href="../../../../wp-content/uploads/2015/07/ezgif.com-crop-4.gif"><img class="aligncenter wp-image-512" src="../../../../wp-content/uploads/2015/07/ezgif.com-crop-4.gif" alt="ezgif.com-crop (4)" width="600" height="330" /></a></p>
<p>&nbsp;</p>
<p>The trace will look like the output from ordinary trace, except it will have some addition goodies. As I said above you can inspect all of the arguments and return values. You can also hide/show branches of the trace tree in order to make it easier to find what you are looking for.</p>
<p>&nbsp;</p>
<p><a href="../../../../wp-content/uploads/2015/07/ezgif.com-optimize-8.gif"><img class="aligncenter wp-image-513" src="../../../../wp-content/uploads/2015/07/ezgif.com-optimize-8.gif" alt="ezgif.com-optimize (8)" width="600" height="330" /></a></p>
<p>&nbsp;</p>
<p>The Slime Trace Dialog is invaluable when you have code which is passing lots of objects around and you aren&#8217;t exactly sure what the value of each variable in each object is. You can just use the Slime Trace Dialog and have it keep track of all of the information for you.</p>
<p>All in all, the Slime Inspector is another amazing part of the Common Lisp debugging tool set. It comes in handy when the program crashes and you are unaware of the current state of the program. When combined with the rest of the features for debugging Common Lisp, the Slime Inspector is just incredible.</p>
					</div><!-- .entry-content -->
				<div class="entry-meta clear">
			<span class="posted-on">Posted on <a href="../../../../2015/07/14/debugging-lisp-part-2-inspecting/index.html" rel="bookmark"><time class="entry-date published" datetime="2015-07-14T16:12:12+00:00">July 14, 2015</time><time class="updated" datetime="2016-01-04T12:23:08+00:00">January 4, 2016</time></a></span><span class="byline"> by <span class="author vcard"><a class="url fn n" href="../../index.html">malisper</a></span></span>			<span class="secondary-entry-meta">
																	<span class="comments-link"><a href="../../../../2015/07/14/debugging-lisp-part-2-inspecting/index.html#comments">8</a></span>							</span>
		</div><!-- .entry-meta -->
	</article><!-- #post-## -->

				
					
<article id="post-425" class="post-425 post type-post status-publish format-standard hentry category-debugging-common-lisp">
	<header class="entry-header">
					<h1 class="entry-title"><a href="../../../../2015/07/07/debugging-lisp-part-1-recompilation/index.html" rel="bookmark">Debugging Lisp Part 1: Recompilation</a></h1>			</header><!-- .entry-header -->
			<div class="entry-content">
			<p><em>This post is the start of a series on how to debug Common Lisp code, specifically with Emacs, Slime, and SBCL. If you do not understand Common Lisp, you should still be able to follow along and recognize just how powerful the facilities provided by the Common Lisp debugger are. Nathan Marz asked me to write these posts since he thought many of the tools for debugging Common Lisp were pretty cool.</em></p>
<p><em>For the next post in the series on inspecting, click <a href="../../../../2015/07/14/debugging-lisp-part-2-inspecting/index.html">here</a>.</em></p>
<p>The first thing you need to do in order to get started debugging Common Lisp is to set your Lisp&#8217;s optimization qualities. Optimization qualities are basically a group of settings which allow you to specify what the compiler should optimize for. These qualities include speed, space, compilation speed, safety, and debugging. If you do not run the code below, which tells the compiler to optimize for debugging, almost none of the examples in this post will work.</p>
<pre class="brush: plain; title: ; notranslate" title="">
CL-USER&gt; (declaim (optimize (debug 3)))
NIL

CL-USER&gt; (your-program)
...
</pre>
<p>With the compiler optimized for debugging, it becomes possible to do pretty much everything at runtime. This post will show you how Tom, an experienced Lisp developer would debug and patch a buggy function at runtime. Let&#8217;s say that Tom has the following code which implements the well known Fibonacci function:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defun fib (n)
  (if (&lt;= 0 n 1)
      (/ 1 0)
      (+ (fib (- n 1))
         (fib (- n 2)))))
</pre>
<p>There&#8217;s just one problem, the code isn&#8217;t correct! Instead of returning <em>n</em> in the base case, the code winds up dividing by zero. When Tom tries to calculate the tenth Fibonacci with this code, a debugger window pops up because an error was signaled.<a href="../../../../wp-content/uploads/2015/07/ezgif.com-resize.html"><br />
</a></p>
<p>&nbsp;</p>
<p><a href="../../../../wp-content/uploads/2015/07/ezgif.com-crop.gif"><img class="aligncenter wp-image-436" src="../../../../wp-content/uploads/2015/07/ezgif.com-crop.gif" alt="ezgif.com-crop" width="600" height="329" /></a></p>
<p>&nbsp;</p>
<p>Realizing that he has entered the debugger, Tom wonders what has gone wrong. In order to find the bug, Tom decides to insert a breakpoint into the function.<span id='easy-footnote-1' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../../../2015/07/07/debugging-lisp-part-1-recompilation/index.html#easy-footnote-bottom-1' title='He may be a great programmer, but he still doesn&#8217;t read the error messages.'><sup>1</sup></a></span> In Common Lisp, breakpoints are implemented as a function called &#8216;<strong>break</strong>’.<span id='easy-footnote-2' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../../../2015/07/07/debugging-lisp-part-1-recompilation/index.html#easy-footnote-bottom-2' title='Break is itself implemented in terms of the Common Lisp restart system which I will cover in Debugging Lisp Part 4.'><sup>2</sup></a></span> To insert his breakpoint, Tom adds a call to <strong>break</strong> at the beginning of <strong>fib</strong>. After adding the breakpoint, Tom then puts his cursor next to one of the frames and hits the &#8216;r&#8217; key in order to restart it. In this case, Tom decided to restart the frame where <em>n</em> was three.</p>
<p>&nbsp;</p>
<p><a href="../../../../wp-content/uploads/2015/07/ezgif.com-optimize.gif"><img class="aligncenter wp-image-441" src="../../../../wp-content/uploads/2015/07/ezgif.com-optimize.gif" alt="ezgif.com-optimize" width="600" height="329" /></a></p>
<p>&nbsp;</p>
<p>By restarting the frame, Tom basically traveled back in time to the beginning of the frame he restarted. After restarting the frame, the debugger immediately hits the breakpoint Tom had just added. From there Tom steps through the code by hitting the &#8216;s&#8217; key. He eventually realizes that the base case is implemented incorrectly and that that is why he received the error.</p>
<p>&nbsp;</p>
<p><a href="../../../../wp-content/uploads/2015/07/ezgif.com-optimize.gif"><img class="aligncenter wp-image-444" src="../../../../wp-content/uploads/2015/07/ezgif.com-optimize-2.gif" alt="ezgif.com-optimize (2)" width="600" height="329" /></a></p>
<p>&nbsp;</p>
<p>After finding the source of the problem, similar to how he had previously inserted the breakpoint, Tom patches the code. He replaces the base case with <em>n</em> and removes the breakpoint he had previously inserted.</p>
<p>&nbsp;</p>
<p><a href="../../../../wp-content/uploads/2015/07/ezgif.com-optimize-3.gif"><img class="aligncenter wp-image-445" src="../../../../wp-content/uploads/2015/07/ezgif.com-optimize-3.gif" alt="ezgif.com-optimize (3)" width="600" height="329" /></a></p>
<p>&nbsp;</p>
<p>After recompiling the code, Tom once again restarts one of the frames. Since he was previously stepping through code, the debugger starts stepping through the frame Tom decided to restart. Tom just taps the &#8216;0&#8217;  (zero) key in order to invoke the step-continue restart<span id='easy-footnote-3' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../../../2015/07/07/debugging-lisp-part-1-recompilation/index.html#easy-footnote-bottom-3' title='Again, restarts will be covered in part four.'><sup>3</sup></a></span> and continue normal execution. Because Tom restarted a frame which occurred before the bug, and now that the bug is gone, the code runs as if there had never a bug in the first place!</p>
<p>&nbsp;</p>
<p><a href="../../../../wp-content/uploads/2015/07/ezgif.com-crop-3.gif"><img class="aligncenter wp-image-446" src="../../../../wp-content/uploads/2015/07/ezgif.com-crop-3.gif" alt="ezgif.com-crop (3)" width="600" height="329" /></a></p>
<p>&nbsp;</p>
<p>Let&#8217;s recap what happened. After the code signaled an error, Tom found himself in the debugger. Tom was able to insert a breakpoint and poke around until he found the source of the problem. After finding the problem, Tom patched the code and restarted the process from a point before it had signaled an error. Because Tom had corrected the code, after he restarted the frame, it acted as if nothing had ever gone wrong!</p>
<p>The ability to recompile code at runtime is just one of the many incredible features provided by Common Lisp. Next time, I&#8217;m going to talk about the Slime inspector, which makes it possible to look into and modify objects from within debugger.</p>
					</div><!-- .entry-content -->
				<div class="entry-meta clear">
			<span class="posted-on">Posted on <a href="../../../../2015/07/07/debugging-lisp-part-1-recompilation/index.html" rel="bookmark"><time class="entry-date published" datetime="2015-07-07T15:37:43+00:00">July 7, 2015</time><time class="updated" datetime="2016-01-04T12:23:25+00:00">January 4, 2016</time></a></span><span class="byline"> by <span class="author vcard"><a class="url fn n" href="../../index.html">malisper</a></span></span>			<span class="secondary-entry-meta">
																	<span class="comments-link"><a href="../../../../2015/07/07/debugging-lisp-part-1-recompilation/index.html#comments">24</a></span>							</span>
		</div><!-- .entry-meta -->
	</article><!-- #post-## -->

				
					
<article id="post-370" class="post-370 post type-post status-publish format-standard hentry category-basics">
	<header class="entry-header">
					<h1 class="entry-title"><a href="../../../../2015/06/30/multiple-value-bind/index.html" rel="bookmark">Multiple-value-bind</a></h1>			</header><!-- .entry-header -->
			<div class="entry-content">
			<p>Common Lisp is a pretty unique language. One of the many features that makes Common Lisp such an awesome language is multiple values. Yes, you read right. In Common Lisp it is possible for a function to return more than a single value. One example of a function that takes advantage of multiple values is <b>floor</b>. <b>Floor</b> takes a number as its argument and returns two values, whatever was passed in rounded down and the remainder.</p>
<pre class="brush: plain; title: ; notranslate" title="">
(floor 3.5)
=&gt;
3
0.5
</pre>
<p>When you use <strong>floor</strong> in the manner above, you get two values back, 3 as the first return value, and 0.5 as the second. What&#8217;s really cool is that the values besides the first are completely ignored unless you explicitly ask for them.<span id='easy-footnote-1' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../../../2015/06/30/multiple-value-bind/index.html#easy-footnote-bottom-1' title='Since we are using floor from the repl, all of the values are shown.'><sup>1</sup></a></span> This means you can pretend that <strong>floor</strong> returns only a single value as long as you don&#8217;t need the other ones. Notice how in the following example, the <strong>+</strong> function is not aware of the second value returned by <strong>floor</strong>:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(+ (floor 3.5) 10)
=&gt; 13
</pre>
<p>Now you may be wondering, &#8220;How can I obtain other values besides the first one?&#8221;. Well, there are several macros for doing that, the main one being <strong>multiple-value-bind</strong>. To use <strong>multiple-value-bind</strong>, you specify a list of the variables you want to bind each value to, followed by the expression that will return multiple values. Let&#8217;s say you want to multiply the two values returned by <strong>floor</strong> together. Here is how you would do that with <strong>multiple-value-bind</strong>:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(multiple-value-bind (val remainder) (floor 3.5)
  (* val remainder))
=&gt; 1.5
</pre>
<p>It is also easy to create your own function that returns multiple values. All you need to do is pass each value you want to return to the <strong>values</strong> function. Below is a function which returns both twice its argument and three times its argument:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defun multiples (x)
  (values (* 2 x) (* 3 x)))

(multiples 10)
=&gt;
20
30
</pre>
<p>There is just one more thing you need to know about multiple values. If the last call of a function is to another that returns multiple values, the first function will return all of the values the second one returns. If you were to write a function that doubles its argument and then uses <strong>floor</strong> to round it down, that function will return both values that are returned by <strong>floor</strong>.</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defun double-and-round-down (x)
  (floor (* 2 x)))

(double-and-round-down 5.25)
=&gt;
10
0.5
</pre>
<p>This behavior may or may not be desired. The standard way to make sure your function only returns a single value is to wrap the function that returns multiple values with a call to <strong>values</strong>. <strong>Values</strong> will pay attention only to the first value and will return just that and nothing else.</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defun double-and-round-down (x)
  (values (floor (* 2 x))))

(double-and-round-down 5.25)
=&gt; 10
</pre>
<p>And that&#8217;s all you need to know to work with multiple values!</p>
					</div><!-- .entry-content -->
				<div class="entry-meta clear">
			<span class="posted-on">Posted on <a href="../../../../2015/06/30/multiple-value-bind/index.html" rel="bookmark"><time class="entry-date published" datetime="2015-06-30T13:24:41+00:00">June 30, 2015</time><time class="updated" datetime="2015-07-04T15:49:11+00:00">July 4, 2015</time></a></span><span class="byline"> by <span class="author vcard"><a class="url fn n" href="../../index.html">malisper</a></span></span>			<span class="secondary-entry-meta">
																	<span class="comments-link"><a href="../../../../2015/06/30/multiple-value-bind/index.html#comments">8</a></span>							</span>
		</div><!-- .entry-meta -->
	</article><!-- #post-## -->

				
					
<article id="post-241" class="post-241 post type-post status-publish format-standard hentry category-basics">
	<header class="entry-header">
					<h1 class="entry-title"><a href="../../../../2015/06/17/hofeach/index.html" rel="bookmark">Hofeach</a></h1>			</header><!-- .entry-header -->
			<div class="entry-content">
			<p>Last time I talked about <a href="../../../../2015/06/14/mapeach/index.html">mapeach</a>, a macro which is a simple wrapper around <strong>mapcar</strong>. After using <strong>mapeach</strong> a couple times, I found that I wanted &#8216;each&#8217; version of many other other functions, <strong>remove</strong>, <strong>find</strong>, and <strong>count</strong> to name a few. One option I had was to write a macro for every single one of these functions. If I were to have done this, I would have wound up with &#8216;remove-each&#8217;, &#8216;find-each&#8217;, and so on. Instead I took door number two, creating a general macro which I call &#8216;<strong>hofeach&#8217;</strong>. <strong>Hofeach</strong>, is just like <strong>mapeach</strong>, except it takes an extra argument for the HOF (higher order function), that you want to use. Below is one possible implementation of <strong>hofeach</strong>.</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defmacro hofeach (hof var list &amp;body body)
  `(funcall ,hof (lambda (,var) ,@body) ,list))
</pre>
<p>Here is what code that uses <strong>hofeach</strong> as a fill in for <strong>mapeach</strong> looks like:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(hofeach #'mapcar x '(1 2 3)
  (* x x))

=&gt; (1 4 9)
</pre>
<p>Now we get to specify which HOF we want to use! If we want to keep all of the numbers in a list that are even, here is how we could do that:<span id='easy-footnote-1' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../../../2015/06/17/hofeach/index.html#easy-footnote-bottom-1' title='Remove-if-not is a pretty bad name. Removing all of the elements that do not satisfy some property can be thought of as keeping all of the ones that do. So instead of being called &#8216;remove-if-not&#8217;, it should be called &#8216;keep-if&#8217;.'><sup>1</sup></a></span> <span id='easy-footnote-2' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../../../2015/06/17/hofeach/index.html#easy-footnote-bottom-2' title='We need to use integerp since evenp signals an error when called with a non-integer value.'><sup>2</sup></a></span></p>
<pre class="brush: plain; title: ; notranslate" title="">
(hofeach #'remove-if-not x '(1.2 5 7 2 3.5 6 9)
  (and (integerp x) (evenp x)))

=&gt; (2 6)
</pre>
<p>So now that I have <strong>hofeach</strong>, I generally will use it instead of passing a complex lambda expression to a HOF. Most of the time I use <strong>hofeach</strong> with <strong>remove-if-not</strong>, but I have also used it with <b>count-if</b> as well. It gives code a nice down and to the right look, which I find pretty easy to read. You get to read the forms in the order that they appear. If you were to use a lambda expression instead, it becomes much more difficult to read since you have to jump around in order to read the code.</p>
					</div><!-- .entry-content -->
				<div class="entry-meta clear">
			<span class="posted-on">Posted on <a href="../../../../2015/06/17/hofeach/index.html" rel="bookmark"><time class="entry-date published" datetime="2015-06-17T10:46:50+00:00">June 17, 2015</time><time class="updated" datetime="2015-07-04T15:57:48+00:00">July 4, 2015</time></a></span><span class="byline"> by <span class="author vcard"><a class="url fn n" href="../../index.html">malisper</a></span></span>			<span class="secondary-entry-meta">
																	<span class="comments-link"><a href="../../../../2015/06/17/hofeach/index.html#comments">10</a></span>							</span>
		</div><!-- .entry-meta -->
	</article><!-- #post-## -->

				
					
<article id="post-210" class="post-210 post type-post status-publish format-standard hentry category-basics">
	<header class="entry-header">
					<h1 class="entry-title"><a href="../../../../2015/06/14/mapeach/index.html" rel="bookmark">Mapeach</a></h1>			</header><!-- .entry-header -->
			<div class="entry-content">
			<p>Many times when using <strong>mapcar</strong>, I find myself using a complex lambda expression for the function argument. This makes the code difficult to read since it breaks apart the flow. My code winds up looking like the following:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(mapcar (lambda (x)
          ...)
        list)
</pre>
<p>First you have to read the possibly massive lambda expression, then you finally find out what you are mapping over. As the lambda expression increases in length, it becomes harder and harder to read. A way to fix this is with the macro <strong>mapeach</strong>. <strong>Mapeach</strong> is a macro which is meant to be used when the lambda expression that would be passed to <strong>mapcar</strong> is much longer than the expression for the list. <strong>Mapeach</strong> works just like <strong>mapcar</strong>, but instead provides an alternative syntax which makes it easier to read when the lambda expression is complicated. Here is one possible implementation of <strong>mapeach</strong>:<span id='easy-footnote-1' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='../../../../2015/06/14/mapeach/index.html#easy-footnote-bottom-1' title='An alternative implementation can expand into loop. That way it will automatically support destructuring over the list elements.'><sup>1</sup></a></span></p>
<pre class="brush: plain; title: ; notranslate" title="">
(defmacro mapeach (var list &amp;body body)
  `(mapcar (lambda (,var) ,@body) ,list))
</pre>
<p><strong>Mapeach</strong>, does two things to fix the problem. First it hides the lambda, making it easier to find the important parts of the code. Second, it inverts the order of the arguments, putting the simple list expression first and the complex body second. As a simple example of <strong>mapeach</strong>, here is how one could square each element in a list using it:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(mapeach x '(1 2 3)
  (* x x))
</pre>
<p>If one wanted to write the above code by using <strong>mapcar</strong>, it would look something like the following:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(mapcar (lambda (x)
          (* x x))
        '(1 2 3))
</pre>
<p>Although it doesn&#8217;t shine for this simple example, you can tell that <strong>mapeach</strong> makes the code a bit clearer. As the body for the lambda expression gets longer and longer, <strong>mapeach</strong> begins to make the code much easier to understand. I find that <strong>mapcar</strong> is nice to use only when the expression for the function is short. This happens either when you are either using a named function or you are using some sort of reader macro. <strong>Mapeach</strong> is another one of those macros that makes what seems like an insignificant difference. Even so, I find that it aids a lot in readability since it puts all of the simple parts in one place.</p>
					</div><!-- .entry-content -->
				<div class="entry-meta clear">
			<span class="posted-on">Posted on <a href="../../../../2015/06/14/mapeach/index.html" rel="bookmark"><time class="entry-date published" datetime="2015-06-14T08:51:57+00:00">June 14, 2015</time><time class="updated" datetime="2015-07-04T15:53:32+00:00">July 4, 2015</time></a></span><span class="byline"> by <span class="author vcard"><a class="url fn n" href="../../index.html">malisper</a></span></span>			<span class="secondary-entry-meta">
																	<span class="comments-link"><a href="../../../../2015/06/14/mapeach/index.html#comments">4</a></span>							</span>
		</div><!-- .entry-meta -->
	</article><!-- #post-## -->

				
			
	<nav class="navigation posts-navigation" role="navigation">
		<h2 class="screen-reader-text">Posts navigation</h2>
		<div class="nav-links"><div class="nav-previous"><a href="../3/index.html" >Older posts</a></div><div class="nav-next"><a href="../../index.html" >Newer posts</a></div></div>
	</nav>
		
		</main><!-- #main -->
	</section><!-- #primary -->


	</div><!-- #content -->

	<footer id="colophon" class="site-footer" role="contentinfo">
		<div class="site-info">
			<a href="http://wordpress.org/">Proudly powered by WordPress</a>
			<span class="sep"> ~ </span>
			Theme: Scrawl by <a href="https://wordpress.com/themes/" rel="designer">WordPress.com</a>.		</div><!-- .site-info -->
	</footer><!-- #colophon -->
</div><!-- #page -->

<script type='text/javascript' src='../../../../wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shCore09b1.js?ver=3.0.9b'></script>
<script type='text/javascript' src='../../../../wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shBrushPlain09b1.js?ver=3.0.9b'></script>
<script type='text/javascript'>
	(function(){
		var corecss = document.createElement('link');
		var themecss = document.createElement('link');
		var corecssurl = "../../../../wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shCore09b1.css?ver=3.0.9b";
		if ( corecss.setAttribute ) {
				corecss.setAttribute( "rel", "stylesheet" );
				corecss.setAttribute( "type", "text/css" );
				corecss.setAttribute( "href", corecssurl );
		} else {
				corecss.rel = "stylesheet";
				corecss.href = corecssurl;
		}
		document.getElementsByTagName("head")[0].insertBefore( corecss, document.getElementById("syntaxhighlighteranchor") );
		var themecssurl = "../../../../wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shThemeEclipse09b1.css?ver=3.0.9b";
		if ( themecss.setAttribute ) {
				themecss.setAttribute( "rel", "stylesheet" );
				themecss.setAttribute( "type", "text/css" );
				themecss.setAttribute( "href", themecssurl );
		} else {
				themecss.rel = "stylesheet";
				themecss.href = themecssurl;
		}
		//document.getElementById("syntaxhighlighteranchor").appendChild(themecss);
		document.getElementsByTagName("head")[0].insertBefore( themecss, document.getElementById("syntaxhighlighteranchor") );
	})();
	SyntaxHighlighter.config.strings.expandSource = '+ expand source';
	SyntaxHighlighter.config.strings.help = '?';
	SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
	SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
	SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
	SyntaxHighlighter.defaults['pad-line-numbers'] = false;
	SyntaxHighlighter.defaults['toolbar'] = false;
	SyntaxHighlighter.all();
</script>
<link rel='stylesheet' id='qtipstyles-css'  href='../../../../wp-content/plugins/easy-footnotes/assets/qtip/jquery.qtip.min167b.css?ver=4.6' type='text/css' media='' />
<link rel='stylesheet' id='easyfootnotescss-css'  href='../../../../wp-content/plugins/easy-footnotes/assets/easy-footnotes167b.css?ver=4.6' type='text/css' media='' />
<link rel='stylesheet' id='dashicons-css'  href='../../../../wp-includes/css/dashicons.min167b.css?ver=4.6' type='text/css' media='all' />
<script type='text/javascript' src='../../../../wp-content/themes/scrawl-wpcom/js/scrawld56c.js?ver=20150309'></script>
<script type='text/javascript' src='../../../../wp-content/themes/scrawl-wpcom/js/skip-link-focus-fix08e0.js?ver=20130115'></script>
<script type='text/javascript' src='../../../../wp-includes/js/wp-embed.min167b.js?ver=4.6'></script>
<script type='text/javascript' src='../../../../wp-includes/js/imagesloaded.min55a0.js?ver=3.2.0'></script>
<script type='text/javascript' src='../../../../wp-content/plugins/easy-footnotes/assets/qtip/jquery.qtip.min167b.js?ver=4.6'></script>
<script type='text/javascript' src='../../../../wp-content/plugins/easy-footnotes/assets/qtip/jquery.qtipcall167b.js?ver=4.6'></script>

</body>

<!-- Mirrored from malisper.me/author/malisper/page/2/ by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 01 Sep 2016 17:46:53 GMT -->
</html>
<!-- Dynamic page generated in 0.181 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2016-09-01 12:23:24 -->

<!-- super cache -->