<!DOCTYPE html>
<html lang="en-US" prefix="og: http://ogp.me/ns#">

<!-- Mirrored from malisper.me/2015/09/ by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 01 Sep 2016 17:46:28 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>September 2015 - Macrology</title>
<link rel="profile" href="http://gmpg.org/xfn/11">
<link rel="pingback" href="../../xmlrpc.php">


<!-- This site is optimized with the Yoast SEO plugin v3.4.2 - https://yoast.com/wordpress/plugins/seo/ -->
<meta name="robots" content="noindex,follow"/>
<link rel="canonical" href="index.html" />
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="object" />
<meta property="og:title" content="September 2015 - Macrology" />
<meta property="og:url" content="index.html" />
<meta property="og:site_name" content="Macrology" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="September 2015 - Macrology" />
<!-- / Yoast SEO plugin. -->

<link rel='dns-prefetch' href='http://fonts.googleapis.com/'>
<link rel="alternate" type="application/rss+xml" title="Macrology &raquo; Feed" href="../../feed/index.html" />
<link rel="alternate" type="application/rss+xml" title="Macrology &raquo; Comments Feed" href="../../comments/feed/index.html" />
<link rel='stylesheet' id='scrawl-style-css'  href='../../wp-content/themes/scrawl-wpcom/style167b.css?ver=4.6' type='text/css' media='all' />
<link rel='stylesheet' id='scrawl-fonts-css'  href='https://fonts.googleapis.com/css?family=Lora:400,700|Merriweather:400italic,400,700,700italic&amp;subset=latin%2Clatin-ext' type='text/css' media='all' />
<link rel='stylesheet' id='genericons-css'  href='../../wp-content/themes/scrawl-wpcom/fonts/genericons6de8.css?ver=3.3' type='text/css' media='all' />
<script type='text/javascript' src='../../wp-includes/js/jquery/jqueryb8ff.js?ver=1.12.4'></script>
<script type='text/javascript' src='../../wp-includes/js/jquery/jquery-migrate.min330a.js?ver=1.4.1'></script>
<link rel='https://api.w.org/' href='../../wp-json/index.html' />
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="../../xmlrpc0db0.php?rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="../../wp-includes/wlwmanifest.xml" /> 
<meta name="generator" content="WordPress 4.6" />
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-63547056-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
<style type="text/css" id="syntaxhighlighteranchor"></style>

<script type="text/javascript">
  window.heap=window.heap||[],heap.load=function(e,t){window.heap.appid=e,window.heap.config=t=t||{};var n=t.forceSSL||"https:"===document.location.protocol,a=document.createElement("script");a.type="text/javascript",a.async=!0,a.src=(n?"https:":"http:")+"//cdn.heapanalytics.com/js/heap-"+e+".js";var o=document.getElementsByTagName("script")[0];o.parentNode.insertBefore(a,o);for(var r=function(e){return function(){heap.push([e].concat(Array.prototype.slice.call(arguments,0)))}},p=["clearEventProperties","identify","setEventProperties","track","unsetEventProperty"],c=0;c<p.length;c++)heap[p[c]]=r(p[c])};
    heap.load("931515525");
</script>
</head>

<body class="archive date">
	<button class="menu-toggle x">
		<span class="lines"></span>
		<span class="screen-reader-text">Primary Menu</span>
	</button>
	<div class="slide-menu">
				
		<h1 class="site-title"><a href="../../index.html" rel="home">Macrology</a></h1>
		<h2 class="site-description">Case Studies in Lisp Macros</h2>
		
				
				
			<div id="secondary" class="widget-area" role="complementary">
		<aside id="search-2" class="widget widget_search"><form role="search" method="get" class="search-form" action="http://malisper.me/">
				<label>
					<span class="screen-reader-text">Search for:</span>
					<input type="search" class="search-field" placeholder="Search &hellip;" value="" name="s" />
				</label>
				<input type="submit" class="search-submit" value="Search" />
			</form></aside><aside id="pages-3" class="widget widget_pages"><h1 class="widget-title">Pages</h1>		<ul>
			<li class="page_item page-item-55"><a href="../../about-me/index.html">About Michael Malis</a></li>
<li class="page_item page-item-44"><a href="../../about-this-site-2/index.html">About This Site</a></li>
		</ul>
		</aside><aside id="nav_menu-3" class="widget widget_nav_menu"><h1 class="widget-title">Contact Me</h1><div class="menu-contact-me-container"><ul id="menu-contact-me" class="menu"><li id="menu-item-60" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-60"><a href="mailto:michaelmalis2@gmail.com">Email</a></li>
<li id="menu-item-58" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-58"><a href="https://github.com/malisper">Github</a></li>
<li id="menu-item-59" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-59"><a href="https://news.ycombinator.com/user?id=malisper">Hacker News</a></li>
</ul></div></aside><aside id="archives-2" class="widget widget_archive"><h1 class="widget-title">Archives</h1>		<ul>
			<li><a href='../../2016/06/index.html'>June 2016</a></li>
	<li><a href='../../2016/04/index.html'>April 2016</a></li>
	<li><a href='../../2016/01/index.html'>January 2016</a></li>
	<li><a href='../12/index.html'>December 2015</a></li>
	<li><a href='../11/index.html'>November 2015</a></li>
	<li><a href='../10/index.html'>October 2015</a></li>
	<li><a href='index.html'>September 2015</a></li>
	<li><a href='../08/index.html'>August 2015</a></li>
	<li><a href='../07/index.html'>July 2015</a></li>
	<li><a href='../06/index.html'>June 2015</a></li>
	<li><a href='../05/index.html'>May 2015</a></li>
		</ul>
		</aside><aside id="categories-2" class="widget widget_categories"><h1 class="widget-title">Categories</h1>		<ul>
	<li class="cat-item cat-item-2"><a href="../../category/basics/index.html" title="These are basic Lisp macros that should be trivial to understand.">Basic Macros</a>
</li>
	<li class="cat-item cat-item-5"><a href="../../category/intermediate-macros/index.html" >Intermediate Macros</a>
</li>
	<li class="cat-item cat-item-6"><a href="../../category/advanced-macros/index.html" >Advanced Macros</a>
</li>
	<li class="cat-item cat-item-7"><a href="../../category/debugging-common-lisp/index.html" >Debugging Lisp</a>
</li>
	<li class="cat-item cat-item-8"><a href="../../category/loops-in-lisp/index.html" >Loops in Lisp</a>
</li>
		</ul>
</aside>	</div><!-- #secondary -->
	</div><!-- .slide-menu -->
<div id="page" class="hfeed site">
	<a class="skip-link screen-reader-text" href="#content">Skip to content</a>

	<header id="masthead" class="site-header" role="banner">

		<div class="site-branding">
						<h1 class="site-title"><a href="../../index.html" rel="home">Macrology</a></h1>
		</div>

	</header><!-- #masthead -->

	
	
	<div id="content" class="site-content">


	<section id="primary" class="content-area">
		<main id="main" class="site-main" role="main">

		
			<header class="page-header">
				<h1 class="page-title">Month: September 2015</h1>			</header><!-- .page-header -->

			
				
					
<article id="post-988" class="post-988 post type-post status-publish format-standard hentry category-basics">
	<header class="entry-header">
					<h1 class="entry-title"><a href="29/zap/index.html" rel="bookmark">Zap</a></h1>			</header><!-- .entry-header -->
			<div class="entry-content">
			<p><em>This post makes use of places. If you are unfamiliar with how places work, see my post <a href="22/getting-places/index.html">Getting Places</a>.</em></p>
<p>Many languages provide syntactic sugar for evaluating an expression involving a variable and assigning the result of that expression to the variable at the same time. In these languages you can do something such as the following:</p>
<pre class="brush: plain; title: ; notranslate" title="">
x += 5
</pre>
<p>The above expression both adds five to the value of <em>x</em> and writes that new value back to <em>x</em>. In this post, I&#8217;m going to show you how you can write a macro <b>zap</b> that is a generalized version of this technique. With <strong>zap</strong> the above example would look like the following:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(zap #'+ x 5)
</pre>
<p>There are a couple things that make <strong>zap</strong> really cool. First of all, it can be used with any function. For example, if you wanted to cube the value in <em>x</em>, you could use the following:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(zap #'expt x 3)
</pre>
<p>The other thing that makes <strong>zap</strong> so awesome is that it can be used on any place. If you want to use <strong>zap</strong> on the value stored in a hash table with key 5, you can do that:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(zap #'+ (gethash 5 table) 5)
</pre>
<p>Now that you&#8217;ve seen how <strong>zap</strong> is used, here is how it can be implemented:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defmacro zap (fn place &amp;rest args)
  (multiple-value-bind 
        (temps exprs stores store-expr access-expr) 
      (get-setf-expansion place)
    `(let* (,@(mapcar #'list temps exprs)
            (,(car stores) 
              (funcall ,fn ,access-expr ,@args)))
       ,store-expr)))
</pre>
<p>You should be able to see that the code for <strong>zap</strong> is eerily similar to that of <strong>incf</strong> (from <a href="22/getting-places/index.html">Getting Places</a>). They are the exact same except instead of binding the gensym that will hold the new value to one plus the value already in the place:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(,(car stores) (+ 1 ,access-expr))
</pre>
<p>The gensym is bound to the result of calling the function with the value in the place and all of the other arguments passed to <strong>zap</strong>:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(,(car stores) (funcall ,fn ,access-expr ,@args))
</pre>
<p>Although <strong>zap</strong> is just a nice syntactic shortcut, it is a great example of the crazy things you can do with places.</p>
					</div><!-- .entry-content -->
				<div class="entry-meta clear">
			<span class="posted-on">Posted on <a href="29/zap/index.html" rel="bookmark"><time class="entry-date published" datetime="2015-09-29T11:38:35+00:00">September 29, 2015</time></a></span><span class="byline"> by <span class="author vcard"><a class="url fn n" href="../../author/malisper/index.html">malisper</a></span></span>			<span class="secondary-entry-meta">
																	<span class="comments-link"><a href="29/zap/index.html#respond">0</a></span>							</span>
		</div><!-- .entry-meta -->
	</article><!-- #post-## -->

				
					
<article id="post-270" class="post-270 post type-post status-publish format-standard hentry category-advanced-macros">
	<header class="entry-header">
					<h1 class="entry-title"><a href="22/getting-places/index.html" rel="bookmark">Getting Places</a></h1>			</header><!-- .entry-header -->
			<div class="entry-content">
			<p><em>This post will serve as an introduction to writing macros that work with places. I will refer back to it whenever I examine a macro which deals with places.</em></p>
<p>Places are an incredible part of Common Lisp. In short, a &#8220;place&#8221; is any location that can hold a value. The obvious example of a place is a variable. Less obvious examples include the elements of an array, or the slots of an object. What makes the concept of places special is that Common Lisp provides a standard interface for reading and writing to them. You can write macros on top of this interface that work for every kind of place. As an example, look at the macro <strong>incf</strong>. It takes a place as an argument, adds one to its value, and stores the new value back into the place. If you want to increment a variable <em>x,</em> you would use:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(incf x)
</pre>
<p>And if you wanted to increment the element at index <em>x</em> of a sequence, you would use:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(incf (elt seq x))
</pre>
<p>They use the exact same syntax even though a variable is very different from an element of a sequence. Because it takes advantage of the interface for places, <strong>incf</strong> will work on any place, be it a variable, the slot of an object, or a user defined place.</p>
<p>So at this point you are probably wondering how does <strong>incf</strong> work and more generally, how do you write macros that use places? To write such a macro, you need to use the function <strong>get-setf-expansion</strong>.<span id='easy-footnote-1' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='22/getting-places/index.html#easy-footnote-bottom-1' title='There is an easier way through the macro define-modify-macro, but that only works in a few basic cases.'><sup>1</sup></a></span> <strong>Get-setf-expansion</strong> takes an expression representing a place and returns a total of five values (if you are unfamiliar with multiple values, see my post on <a href="../06/30/multiple-value-bind/index.html">multiple-value-bind</a>). Altogether, these five values tell you everything you need to know about the place in order to read and write to it.</p>
<p>To show you how you are supposed to use <strong>get-setf-expansion</strong>, I&#8217;m first going to demonstrate how you could use it to write the expansion of <strong>incf</strong> by hand. After that, I will show code that will automate this, which winds up being an implementation of <strong>incf</strong>. Let&#8217;s start by writing the expansion of the example above. The one where the element of a sequence is being incremented. To write the expansion of that by hand, you would first call <strong>get-setf-expansion</strong> to obtain all of the information:<span id='easy-footnote-2' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='22/getting-places/index.html#easy-footnote-bottom-2' title='You are actually supposed to call get-setf-expansion with an environment object so that locally defined macros can be expanded properly. An environment object can be obtained through the &amp;environment keyword in a macro argument list. For the sake of simplicity, I will be ignoring the environment object.'><sup>2</sup></a></span></p>
<pre class="brush: plain; title: ; notranslate" title="">
(get-setf-expansion '(elt seq x))
</pre>
<p>In SBCL this call will return the following values:</p>
<pre class="brush: plain; title: ; notranslate" title="">
;; (1) temps
(#:seq1017 #:x1016)

;; (2) exprs
(seq x) 

;; (3) stores
(#:new1015) 

;; (4) store-expr
(sb-kernel:%setelt #:seq1017 #:x1016 #:new1015) 

;; (5) access-expr
(elt #:seq1017 #:x1016))
</pre>
<p>From now on, I will refer to each value returned by <strong>get-setf-expansion</strong> by the name in the comment before it (e.g. <em>temps</em> refers to the first value).</p>
<p>In order to uniquely identify the element of a sequence (the place we are working with in this example), you need two things. You need the sequence itself and the index into the sequence. That is exactly what the two expressions in <em>exprs</em> evaluate to! Since <strong>incf</strong> needs to use these values multiple times, the two values have to be bound to gensyms in order to prevent multiple evaluation (see my post on <a href="../06/06/once-only/index.html">once-only</a> for why multiple evaluation is a problem). You are supposed to bind the values of the expressions to the gensyms in <em>temps</em> so that the other expressions returned by <strong>get-setf-expansion</strong> can use those gensyms to easily determine the place being worked with. The bindings need to be made with <strong>let*</strong> because it is possible for an expression in <em>exprs</em> to refer to the value of a previous expression in <em>exprs</em>. So the first part of the expansion will bind all of the symbols in <em>temps</em> to values of the expressions in <em>exprs</em> with <strong>let*</strong>:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(let* ((#:seq1017 seq) (#:x1016 x))
  ...)
</pre>
<p>Now the gensyms in <em>temps</em> can be used to uniquely identify the place. As I mentioned previously, the other expressions can now easily determine the place through the gensyms. For example, <em>access-expr</em> can be used to retrieve the value currently in the place. Since the place we are dealing with is the element of a sequence,  <em>access-expr</em> is just a call to <strong>elt</strong> using the gensyms in <em>temps</em> as the arguments. We are going to use <em>access-expr</em> in a moment, but first I have to talk about how to write to the place.</p>
<p>In order to write to the place, you need to use <em>stores</em> and <em>store-expr</em>. <em>Stores</em> is a list of gensyms that need to be bound to the values that are to be stored in the place (it is possible for a single place to hold multiple values).  In this case we want to bind the gensym in <em>stores</em> to one plus the value already in the place. We can easily obtain the value in the place through <i>access-expr</i>. Once the gensyms have been bound, you can use <em>store-expr</em> to actually write the values in <em>stores</em> to the place. Notice how <em>store-expr</em> is a call to an internal SBCL function <strong>sb-kernel:setelt%</strong> that uses the gensyms in <em>temps</em> and <em>stores</em> as arguments. Presumably <strong>sb-kernel:setelt%</strong> sets the element of a sequence. After adding the binding for the gensym in <em>stores</em> and <em>store-expr</em>, we wind up with the final expansion which looks like:<span id='easy-footnote-3' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='22/getting-places/index.html#easy-footnote-bottom-3' title='If you try to evaluate the code, there are two things you have to. First you have to make sure you are using SBCL because sb-kernel:%setelt is a function specific to SBCL. Second, you have to remove the &#8216;#:&#8217; from all of the symbols that use it because every use of #: creates a new symbol.'><sup>3</sup></a></span></p>
<pre class="brush: plain; title: ; notranslate" title="">
(let* ((#:seq1017 seq) 
       (#:x1016 x) 
       (#:new1015 (+ 1 (elt #:seq1017 #:x1016))))
  (sb-kernel:%setelt #:seq1017 #:x1016 #:new1015))
 </pre>
<p>To review, the above code first binds the gensyms in <em>temps</em> to the values of the expressions in <em>exprs</em>. This allows <i>access-expr</i> and <em>store-expr</em> to use the gensyms in <em>temps</em> in order to determine the place being worked with. Then the code uses <em>access-expr</em> to retrieve the value, adds one to that, and binds that value to the gensym in <em>stores</em>. This is because the value of the gensym in <em>stores</em> is ultimately going to be the one written to the place. Finally the code evaluates <em>store-expr</em> in order to actually store the value in the gensym into the place.</p>
<p>Now here is one possible implementation of <strong>incf</strong>,<span id='easy-footnote-4' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='22/getting-places/index.html#easy-footnote-bottom-4' title='As I mentioned in a previous footnote, you are actually supposed to pass get-setf-expansion an environment object'><sup>4</sup></a></span> which is code for everything we just did by hand. I called it <strong>incf%</strong> so that it doesn&#8217;t have the same name as the builtin version.</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defmacro incf% (place)
  (multiple-value-bind
        (temps exprs stores store-expr access-expr)
      (get-setf-expansion place)
    `(let* (,@(mapcar #'list temps exprs)
            (,(car stores) (+ 1 ,access-expr)))
       ,store-expr)))
</pre>
<p>The above code first binds the five values returned by <strong>get-setf-expansion</strong> to variables. It then generates a <strong>let*</strong> binding which binds the symbols in <em>temps</em> to the expressions in <em>exprs</em> and also binds the gensym in <em>stores</em> to one plus the result of evaluating <em>access-expr</em>. Finally the above code splices in <em>store-expr</em> to actually write the value. And that is everything there is to <strong>incf</strong>.</p>
<p><b>Incf</b> is but a single example of what can be done with places. In the next couple of posts, I plan to cover some really cool macros that encapsulate a bunch of common patterns related to places.</p>
					</div><!-- .entry-content -->
				<div class="entry-meta clear">
			<span class="posted-on">Posted on <a href="22/getting-places/index.html" rel="bookmark"><time class="entry-date published" datetime="2015-09-22T18:00:58+00:00">September 22, 2015</time><time class="updated" datetime="2015-09-20T14:12:49+00:00">September 20, 2015</time></a></span><span class="byline"> by <span class="author vcard"><a class="url fn n" href="../../author/malisper/index.html">malisper</a></span></span>			<span class="secondary-entry-meta">
																	<span class="comments-link"><a href="22/getting-places/index.html#comments">3</a></span>							</span>
		</div><!-- .entry-meta -->
	</article><!-- #post-## -->

				
					
<article id="post-831" class="post-831 post type-post status-publish format-standard hentry category-advanced-macros">
	<header class="entry-header">
					<h1 class="entry-title"><a href="08/defasm/index.html" rel="bookmark">Defasm</a></h1>			</header><!-- .entry-header -->
			<div class="entry-content">
			<p><em>This post is the second part of a two part series exploring the emulator <a href="https://github.com/kingcons/cl-6502">cl-6502</a>. If you haven&#8217;t read the first part exploring the implementation of addressing modes in cl-6502, you can find it <a href="../08/27/defaddress/index.html">here</a>.</em></p>
<p>This post is going to go over how cl-6502 implements the instruction set of the 6502. Most of the work in defining the instruction set is done by a single macro, <strong>defasm</strong>. But before I can go into the details of <strong>defasm</strong>, I have to explain how cl-6502 represents instructions.</p>
<p>cl-6502 represents each instruction as a function inside an array called <em>*array-funs*</em>. The function for a specific instruction is indexed by that instruction&#8217;s opcode.<span id='easy-footnote-1' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='08/defasm/index.html#easy-footnote-bottom-1' title='If you don&#8217;t know, the opcode is the byte used in machine code to represent the instruction.'><sup>1</sup></a></span> To execute an instruction, cl-6502 looks up the opcode of the current instruction and calls the function at that location inside of <em>*array-funs*</em>. There is also a second array, <em>*opcode-metadata*,</em> which keeps track of some metadata about each instruction such as the number of bytes each one takes up. All <strong>d</strong><strong>efasm</strong> does is make it easy to generate all of the functions and metadata that wind up inside of those two arrays.</p>
<p>To show you just how easy it is to implement instructions with <strong>defasm</strong>, here is the implementation of the adc (add with carry) instruction:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defasm adc (:docs &quot;Add to Accumulator with Carry&quot;)
    ((#x61 6 2 indirect-x)
     (#x65 3 2 zero-page)
     (#x69 2 2 immediate)
     (#x6d 4 3 absolute)
     (#x71 5 2 indirect-y)
     (#x75 4 2 zero-page-x)
     (#x79 4 3 absolute-y)
     (#x7d 4 3 absolute-x))

  (let ((result (+ (cpu-ar cpu) 
                   (getter) 
                   (status-bit :carry))))
    (set-flags-if 
      :carry (&gt; result #xff)
      :overflow (overflow-p result (cpu-ar cpu) (getter))
      :negative (logbitp 7 result)
      :zero (zerop (wrap-byte result)))
    (setf (cpu-ar cpu) (wrap-byte result))))
</pre>
<p>There are two main parts to the above code. The first part specifies all of the addressing modes the instruction is compatible with along with the metadata for each variant of the instruction (there is a different version of the instruction for every possible addressing mode the instruction can be used with).</p>
<p>After that is the body &#8211; the code that actually implements the instruction being defined. The body is responsible for setting all of the appropriate flags and memory locations to the values they should have after executing the instruction. Make sure you note that just like in <strong>defaddress</strong>, the variable <em>cpu</em> can be used in the body to reference an object that represents the current state of the cpu.</p>
<p><b>Defasm</b> takes these two pieces, and generates one lambda expression for each variant of the instruction. All of the generated lambda expressions use the same body, except <strong>defasm</strong> generates some additional code that allows the body to work across all of the different addressing modes.</p>
<p>Now to get into the specifics of the DSL. In the addressing mode part of the DSL, there are four pieces of metadata that need to be associated with each version of the instruction. The first part is the opcode, the machine code representation of the instruction. Next up is the number of cycles it takes for the instruction to execute. After that is the size of the instruction, the number of bytes it takes up in memory. Last is the name of the addressing mode used for that specific variant of the instruction. As an example, here is the metadata for the adc instruction in the indirect-x addressing mode:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(#x61 6 2 indirect-x)
</pre>
<p>What it is saying is that this version of the instruction has the opcode #x61, takes six cycles to run, takes two bytes in memory, and uses the indirect-x addressing mode. The fact that when an instruction is used in different addressing modes, it uses a different number of clock cycles and takes up a different amount of space is one reason why different addressing modes are provided in assembly language.</p>
<p>For the body, <strong>defasm</strong> does something very clever to have the body work for every possible addressing modes. Within the body, the functions <b>getter</b> and <strong>setter</strong> are bound to local functions that can be used to obtain and modify the argument to the instruction. For each variant of the instruction, <strong>defasm</strong> generates the definition of these two functions differently so that they will always calculate the correct argument for the given addressing mode.</p>
<p>For example, in the version of adc that uses immediate addressing, <strong>getter</strong> will just return the value of the operand, but in the version that uses absolute addressing, <b>getter</b> will use the operand as an address and look up the value at that location in memory. In the definition of the adc instruction above, the body uses <strong>getter</strong> to obtain the argument, adds that to the value in the accumulator, adds in the carry, and then sets all of the appropriate flags and registers depending on the final value it winds up with. Since <strong>getter</strong> and <strong>setter</strong> work across all of the different addressing modes, so does the body!</p>
<p>Now let&#8217;s look at the actual implementation of <strong>defasm</strong>:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(defmacro defasm (name (&amp;key (docs &quot;&quot;) raw-p (track-pc t))
                  modes &amp;body body)
  `(progn

     ,@(loop for (op cycles bytes mode) in modes collect
         `(setf (aref *opcode-meta* ,op) 
                ',(list name docs cycles bytes mode)))

     ,@(loop for (op cycles bytes mode) in modes collect
         `(setf (aref *opcode-funs* ,op)
                (lambda (cpu)
                  (incf (cpu-pc cpu))
                  (flet ((getter ()
                           ,(make-getter name mode raw-p))
                         (setter (x)
                           (setf (,mode cpu) x)))
                    ,@body)
                  ,@(when track-pc
                     `((incf (cpu-pc cpu) ,(1- bytes))))
                  (incf (cpu-cc cpu) ,cycles))))))
</pre>
<p>As usual, I&#8217;m going to show a snippet of the implementation of <strong>defasm</strong> and then show what the macroexpansion of that piece looks like. The first part of the implementation handles the addressing modes and metadata:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(loop for (op cycles bytes mode) in modes collect
  `(setf (aref *opcode-meta* ,op) 
         ',(list name docs cycles bytes mode)))
</pre>
<p>For each addressing mode, this generates code which will store a list containing the metadata into the proper place in the <em>*opcode-meta*</em> array. In other words it takes each part that looks like:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(#x61 6 2 indirect-x)
</pre>
<pre>and generates code that looks like:</pre>
<pre class="brush: plain; title: ; notranslate" title="">
(setf (aref *opcode-meta* #x61)
     '(adc &quot;Add to accumulator with carry&quot; 6 2 indirect-x))
</pre>
<p>After that we have the part that will generate the actual lambda expressions for the functions that will be stored in <em>*array-funs*</em>:</p>
<pre class="brush: plain; title: ; notranslate" title="">
(loop for (op cycles bytes mode) in modes collect
  `(setf (aref *opcode-funs* ,op)
         (lambda (cpu)
           (incf (cpu-pc cpu))
           (flet ((getter ()
                   ,(make-getter name mode raw-p))
                 (setter (x)
                   (setf (,mode cpu) x)))
             ,@body)
          ,@(when track-pc
              `((incf (cpu-pc cpu) ,(1- bytes))))
          (incf (cpu-cc cpu) ,cycles))))
</pre>
<p>This code loops over all of the metadata for the different addressing modes and uses this information to generate the expression for each variant of the instruction. As mentioned previously, the function will be stored by the variant&#8217;s opcode. As for the actual function itself, it does something along these lines. First, it advances the pc. This is done so that the pc now points to the operand of the instruction. By doing this, the job of <strong>defaddress</strong> becomes much easier since it can use the pc as a pointer to the operand. Next, the function evaluates the body in an environment with <strong>getter</strong> and <strong>setter</strong> bound to functions that can be used to read and write to the argument. After that it will advance the pc forward to the next instruction (unless <em>track-pc</em> was false, which happens for instructions that modify the pc themselves such as jumps). Finally, the function will increment the cycle count by the number of cycles it takes the instruction to execute.</p>
<p>The definitions of <strong>getter</strong> and <strong>setter</strong> are really just calls to the function with the same name as the addressing mode associated with the variant of the instruction.<span id='easy-footnote-2' class='easy-footnote-margin-adjust'></span><span class='easy-footnote'><a href='08/defasm/index.html#easy-footnote-bottom-2' title='Getter actually uses a function make-getter along with the raw-p argument. This is just to smooth out some differences between instructions.'><sup>2</sup></a></span> If you look back at the last post, you will see that <strong>defaddress</strong> automatically generates these &#8220;mode&#8221; functions. All they do is calculate the effective argument for the given addressing mode! Exactly what <strong>getter</strong> does. As an example of what the expansion looks like, here is the lambda expression generated for the adc instruction in the indirect-x addressing mode.</p>
<pre class="brush: plain; title: ; notranslate" title="">
(setf (aref *opcode-funs* #x61)
      (lambda (cpu)
        (incf (cpu-pc cpu))
        (flet ((getter ()
                 (get-byte (indirect-x cpu)))
               (setter (x)
                 (setf (indirect-x cpu) x)))
         (let ((result (+ (cpu-ar cpu) 
                          (getter) 
                          (status-bit :carry))))
          (set-flags-if :carry (&gt; result 255) 
                        :overflow (overflow-p result 
                                              (cpu-ar cpu)
                                              (getter))
                        :negative (logbitp 7 result) 
                        :zero (zerop (wrap-byte result)))
          (setf (cpu-ar cpu) (wrap-byte result))))
        (incf (cpu-pc cpu) 1)
        (incf (cpu-cc cpu) 6)))
</pre>
<p>And that&#8217;s all there is to <strong>defasm</strong>! There are a couple really cool things you should note about cl-6502. First off, the macros expand into a lot of code. The definition of adc at the beginning of this post expands into roughly 500 lines of code. <a href="https://gist.github.com/malisper/610f691e7b3919d6a421">Here</a> is a link to a gist of it if you want to see it. More incredibly, cl-6502 implements an entire emulator in under 1000 lines of code. cl-6502 is a fantastic example of how effective macros are at creating concise DSLs.</p>
					</div><!-- .entry-content -->
				<div class="entry-meta clear">
			<span class="posted-on">Posted on <a href="08/defasm/index.html" rel="bookmark"><time class="entry-date published" datetime="2015-09-08T12:48:05+00:00">September 8, 2015</time><time class="updated" datetime="2015-10-11T23:06:33+00:00">October 11, 2015</time></a></span><span class="byline"> by <span class="author vcard"><a class="url fn n" href="../../author/malisper/index.html">malisper</a></span></span>			<span class="secondary-entry-meta">
																	<span class="comments-link"><a href="08/defasm/index.html#comments">2</a></span>							</span>
		</div><!-- .entry-meta -->
	</article><!-- #post-## -->

				
			
		
		</main><!-- #main -->
	</section><!-- #primary -->


	</div><!-- #content -->

	<footer id="colophon" class="site-footer" role="contentinfo">
		<div class="site-info">
			<a href="http://wordpress.org/">Proudly powered by WordPress</a>
			<span class="sep"> ~ </span>
			Theme: Scrawl by <a href="https://wordpress.com/themes/" rel="designer">WordPress.com</a>.		</div><!-- .site-info -->
	</footer><!-- #colophon -->
</div><!-- #page -->

<script type='text/javascript' src='../../wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shCore09b1.js?ver=3.0.9b'></script>
<script type='text/javascript' src='../../wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/scripts/shBrushPlain09b1.js?ver=3.0.9b'></script>
<script type='text/javascript'>
	(function(){
		var corecss = document.createElement('link');
		var themecss = document.createElement('link');
		var corecssurl = "../../wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shCore09b1.css?ver=3.0.9b";
		if ( corecss.setAttribute ) {
				corecss.setAttribute( "rel", "stylesheet" );
				corecss.setAttribute( "type", "text/css" );
				corecss.setAttribute( "href", corecssurl );
		} else {
				corecss.rel = "stylesheet";
				corecss.href = corecssurl;
		}
		document.getElementsByTagName("head")[0].insertBefore( corecss, document.getElementById("syntaxhighlighteranchor") );
		var themecssurl = "../../wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shThemeEclipse09b1.css?ver=3.0.9b";
		if ( themecss.setAttribute ) {
				themecss.setAttribute( "rel", "stylesheet" );
				themecss.setAttribute( "type", "text/css" );
				themecss.setAttribute( "href", themecssurl );
		} else {
				themecss.rel = "stylesheet";
				themecss.href = themecssurl;
		}
		//document.getElementById("syntaxhighlighteranchor").appendChild(themecss);
		document.getElementsByTagName("head")[0].insertBefore( themecss, document.getElementById("syntaxhighlighteranchor") );
	})();
	SyntaxHighlighter.config.strings.expandSource = '+ expand source';
	SyntaxHighlighter.config.strings.help = '?';
	SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
	SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
	SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
	SyntaxHighlighter.defaults['pad-line-numbers'] = false;
	SyntaxHighlighter.defaults['toolbar'] = false;
	SyntaxHighlighter.all();
</script>
<link rel='stylesheet' id='qtipstyles-css'  href='../../wp-content/plugins/easy-footnotes/assets/qtip/jquery.qtip.min167b.css?ver=4.6' type='text/css' media='' />
<link rel='stylesheet' id='easyfootnotescss-css'  href='../../wp-content/plugins/easy-footnotes/assets/easy-footnotes167b.css?ver=4.6' type='text/css' media='' />
<link rel='stylesheet' id='dashicons-css'  href='../../wp-includes/css/dashicons.min167b.css?ver=4.6' type='text/css' media='all' />
<script type='text/javascript' src='../../wp-content/themes/scrawl-wpcom/js/scrawld56c.js?ver=20150309'></script>
<script type='text/javascript' src='../../wp-content/themes/scrawl-wpcom/js/skip-link-focus-fix08e0.js?ver=20130115'></script>
<script type='text/javascript' src='../../wp-includes/js/wp-embed.min167b.js?ver=4.6'></script>
<script type='text/javascript' src='../../wp-includes/js/imagesloaded.min55a0.js?ver=3.2.0'></script>
<script type='text/javascript' src='../../wp-content/plugins/easy-footnotes/assets/qtip/jquery.qtip.min167b.js?ver=4.6'></script>
<script type='text/javascript' src='../../wp-content/plugins/easy-footnotes/assets/qtip/jquery.qtipcall167b.js?ver=4.6'></script>

</body>

<!-- Mirrored from malisper.me/2015/09/ by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 01 Sep 2016 17:46:28 GMT -->
</html>
<!-- Dynamic page generated in 0.109 seconds. -->
<!-- Cached page generated by WP-Super-Cache on 2016-09-01 12:22:12 -->

<!-- super cache -->